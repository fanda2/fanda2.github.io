<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6新特性学习02</title>
      <link href="/2022/04/01/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A002/"/>
      <url>/2022/04/01/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A002/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6新特性学习02"><a href="#ES6新特性学习02" class="headerlink" title="ES6新特性学习02"></a>ES6新特性学习02</h1><h2 id="一、ES6新特性"><a href="#一、ES6新特性" class="headerlink" title="一、ES6新特性"></a>一、ES6新特性</h2><ol><li><p>ES6-Peomise基本使用</p><ul><li>Promise是ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并获取其成功或失败的结果。<ul><li>Promise 构造函数：Promise(excutor){}</li><li>Promise.prototype.then方法</li><li>Promise.prototype.catch方法</li></ul></li><li>使用Promise的一般步骤<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//实例化Promise对象</span></span><br><span class="line"><span class="keyword">const</span> p=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>{</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="comment">// let data="数据库中的数据";</span></span><br><span class="line">   <span class="comment">// resolve(data);   //成功时调用resolve()</span></span><br><span class="line">   <span class="keyword">let</span> err=<span class="string">"数据读取失败"</span>;</span><br><span class="line">   reject(err);</span><br><span class="line">   },<span class="number">1000</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//调用Promise中的then方法</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">},<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(reason);</span><br><span class="line">}) </span><br></pre></td></tr></tbody></table></figure></li><li>使用Peomise发送ajax请求</li><li>Promise.prototype.then方法<ul><li>then方法的返回结果是Promise对象，对象状态由回调函数的执行结果决定</li><li>如果回调函数中返回的结果是非 Promise类型的属性，状态为成功，返回值为对象的成功值</li><li>如果回调函数返回的结果是 Promise对象，状态取决于Peomise返回的状态，值为Promise返回值</li><li>如果回调函数抛出错误，状态也为失败，返回值就是抛出值<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> res=p.then(<span class="function"><span class="params">value</span>=&gt;</span>{</span><br><span class="line"><span class="comment">//返回非Promise类型，p为true;</span></span><br><span class="line"><span class="comment">// return "111"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是Promise对象</span></span><br><span class="line"><span class="comment">//return new Promise((resolve,reject)=&gt;{</span></span><br><span class="line"><span class="comment">//resolve("成功")</span></span><br><span class="line"><span class="comment">// })</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 抛出错误，状态也是错误</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="string">"出错了！"</span>;</span><br><span class="line">},<span class="function"><span class="params">reason</span>=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"错误信息"</span>)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>Promise的then方法实现链式调用，异步请求，避免回调地狱  <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//实例化Promise对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>{</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="keyword">let</span> data=<span class="number">20</span>;</span><br><span class="line">   resolve(data);   <span class="comment">//成功时调用resolve()</span></span><br><span class="line">   },<span class="number">1000</span>);</span><br><span class="line">}).then(<span class="function"><span class="params">value</span>=&gt;</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>{</span><br><span class="line">resolve(value+<span class="number">2</span>);</span><br><span class="line">})</span><br><span class="line">}).then(<span class="function"><span class="params">value</span>=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(value+<span class="number">2</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>Promise.prototype.catch方法  <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.error(reason);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-新的数据结构set</p><ul><li><p>ES6中提供的新的数据结构set（集合），它类似于数组，但成员的值都是唯一的，集合实现iterator接口，所以可以使用[扩展运算符]和[for…of]进行遍历</p></li><li><p>集合的属性和方法</p><ul><li><code>size</code> 返回集合的元素个数  </li><li><code>add</code> 增加一个新元素，返回当前集合</li><li><code>delete</code> 删除元素，返回Boolean值</li><li><code>has</code> 检测集合中包含某个元素，返回Boolean值</li><li><code>clear</code> 清空集合里面的所有元素<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">let</span> s=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'张三'</span>,<span class="string">'李四'</span>,<span class="string">'王五'</span>,<span class="string">'张三'</span>,<span class="string">'小华'</span>]);</span><br><span class="line"><span class="comment">//去重输出</span></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">//输出集合元素个数</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br><span class="line"><span class="comment">// 向集合中添加新元素</span></span><br><span class="line">s.add(<span class="string">"小红"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>集合实际操作</p><ul><li><p>实现数组<code>去重</code></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">let</span> result=[...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">//输出[1,2,3,4,5,6]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>实现两个数组<code>交集</code>运算</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> res=<span class="keyword">new</span> <span class="built_in">Set</span>(arr2);  <span class="comment">//数组arr2去重类型为集合</span></span><br><span class="line"><span class="keyword">let</span> result=[...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span>=&gt;</span>{</span><br><span class="line"><span class="keyword">return</span> res.has(item);</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">//输出[2,3,4]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>实现两个数组<code>并集</code>运算</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//并集</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> result=[...new <span class="built_in">Set</span>([...arr,...arr2])];</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">//输出[1,2,3,4,5,6,9,8]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>实现两个数组<code>差集</code>运算</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 差集（arr对arr2求差集）</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> res=<span class="keyword">new</span> <span class="built_in">Set</span>(arr2);  <span class="comment">//数组arr2去重类型为集合</span></span><br><span class="line"><span class="keyword">let</span> result=[...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span>=&gt;</span>{</span><br><span class="line"><span class="keyword">return</span> !res.has(item);</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>ES6-新的数据结构Map</p><ul><li>ES6提供了Map数据结构，它类似于<code>对象</code>，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用[扩展运算符]和[for…of]进行遍历。</li><li>Map的属性和方法<ul><li><code>size</code> 返回Map的元素个数  </li><li><code>set</code> 增加一个新元素，返回当前Map</li><li><code>get</code> 返回键名对应的键值</li><li><code>has</code> 检测集合中包含某个元素，返回Boolean值</li><li><code>clear</code> 清空Map里面的所有元素,返回undefined<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//声明Map</span></span><br><span class="line"><span class="keyword">let</span> m=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//新增元素</span></span><br><span class="line">m.set(<span class="string">'name'</span>,<span class="string">'fanda'</span>);</span><br><span class="line">   m.set(<span class="string">'change'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"这是一个函数"</span>)</span><br><span class="line">})</span><br><span class="line"><span class="keyword">let</span> key={</span><br><span class="line"><span class="attr">cityt</span>:<span class="string">"北京"</span></span><br><span class="line">}</span><br><span class="line">m.set(key,[<span class="string">"上海"</span>,<span class="string">"广东"</span>,<span class="string">"深圳"</span>]);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">m.delete(<span class="string">'change'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"><span class="comment">//遍历Map</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> m){</span><br><span class="line"><span class="built_in">console</span>.log(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>Class类</p><ul><li>引入class（类）这个概念，作为对象模板。通过class关键之字，可以定义类。基本上，ES6的class类可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只有让对象原型的写法更加清晰、更像面向对象编程的语法而已。</li><li>知识点<ul><li>class 声明类</li><li>constructor 定义构造函数初始化</li><li>extends 继承父类</li><li>super 调用父级构造方法</li><li>static 定义静态方法和属性</li><li>父类方法可以重写<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">           <span class="comment">//ES5构造函数的方法</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">phone</span>(<span class="params">brand,price</span>)</span>{</span><br><span class="line">     <span class="built_in">this</span>.brand=brand;</span><br><span class="line">     <span class="built_in">this</span>.price=price;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//添加方法</span></span><br><span class="line">     phone.prototype.call=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"可以用来打电话"</span>);</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//实例化对象</span></span><br><span class="line">     <span class="keyword">let</span> huawei=<span class="keyword">new</span> phone(<span class="string">"华为"</span>,<span class="number">5699</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(huawei);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>{</span><br><span class="line"><span class="comment">//构造函数，名字不能修改</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span> {</span><br><span class="line">        <span class="built_in">this</span>.brand=brand;</span><br><span class="line">    <span class="built_in">this</span>.price=price;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//方法名必须使用该语法，不能使用ES5的对象完整模式</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"手机可以用来打电话！"</span>)</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">          <span class="comment">//实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> xiaomi=<span class="keyword">new</span> phone(<span class="string">"mi"</span>,<span class="number">2699</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(xiaomi);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>class静态成员<ul><li>实例对象不具备构造函数对象的属性和方法，实例对象的属性和构造函数原型对象是相通的。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">phone</span>(<span class="params"></span>)</span>{</span><br><span class="line">}</span><br><span class="line">phone.name=<span class="string">"手机"</span>;</span><br><span class="line">phone.prototype.user=<span class="string">"root"</span>;  <span class="comment">//原型对象</span></span><br><span class="line">phone.change=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"可以用来打电话"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> nkia=<span class="keyword">new</span> phone();</span><br><span class="line"><span class="built_in">console</span>.log(phone.name);  <span class="comment">//输出 "手机"</span></span><br><span class="line"><span class="built_in">console</span>.log(nkia.name);  <span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(nkia.user);   <span class="comment">// 输出root</span></span><br></pre></td></tr></tbody></table></figure></li><li>对于static标志的方法，它属于类而<code>不属于</code>实例对象。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>{</span><br><span class="line"><span class="comment">//静态属性</span></span><br><span class="line"><span class="keyword">static</span> name=<span class="string">"手机"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"可以用来打电话"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> nokia=<span class="keyword">new</span> phone();</span><br><span class="line"><span class="built_in">console</span>.log(phone.name);   <span class="comment">//输出 "手机"</span></span><br><span class="line"><span class="built_in">console</span>.log(nokia.name);  <span class="comment">//输出undefined</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><code>ES5</code>使用构造函数实现继承 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 手机父级</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phone</span>(<span class="params">brand,price</span>)</span>{</span><br><span class="line"><span class="built_in">this</span>.brand=brand;</span><br><span class="line"><span class="built_in">this</span>.price=price;</span><br><span class="line">}</span><br><span class="line">phone.prototype.call=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"可以用来打电话！"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//智能手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmartPhone</span>(<span class="params">brand,price,color,size</span>)</span>{</span><br><span class="line">phone.call(<span class="built_in">this</span>,brand,price);</span><br><span class="line"><span class="built_in">this</span>.color=color;</span><br><span class="line"><span class="built_in">this</span>.size=size;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//设置子集构造函数的原型</span></span><br><span class="line">SmartPhone.prototype=<span class="keyword">new</span> phone;</span><br><span class="line">SmartPhone.prototype.constructor=SmartPhone;</span><br><span class="line"><span class="comment">//声明子类的方法</span></span><br><span class="line">SmartPhone.prototype.photo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"可以用来拍照"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">const</span> chuizi=<span class="keyword">new</span> SmartPhone(<span class="string">'锤子'</span>,<span class="number">3322</span>,<span class="string">'黑色'</span>,<span class="string">'5.5英寸'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chuizi);</span><br><span class="line">chuizi.photo();</span><br></pre></td></tr></tbody></table></figure></li><li>ES6中的类继承<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>{</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">brand,price</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.brand=brand;</span><br><span class="line"><span class="built_in">this</span>.price=price;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="title">change</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以打电话"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//继承父类extends</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">phone</span></span>{</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">brand,price,color,size</span>)</span> {</span><br><span class="line"><span class="built_in">super</span>(brand,price);  <span class="comment">//phone.call(this,brand,price)</span></span><br><span class="line"><span class="built_in">this</span>.color=color;</span><br><span class="line"><span class="built_in">this</span>.size=size;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//定义方法</span></span><br><span class="line"><span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以用来拍照！"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="title">playGame</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以用来打游戏"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> meizu=<span class="keyword">new</span> SmartPhone(<span class="string">"魅族"</span>,<span class="number">1999</span>,<span class="string">"白色"</span>,<span class="string">"6.2inch"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(meizu);</span><br><span class="line">meizu.photo();   <span class="comment">//调用自己的方法</span></span><br><span class="line">meizu.change();  <span class="comment">//调用继承自父类的方法</span></span><br></pre></td></tr></tbody></table></figure></li><li>子类对父类方法的重写<ul><li>js的类中，子类是不能直接调用父类的同名方法的</li><li>方法的重写就是在子类中声明一个和父类的同名方法进行重写</li></ul></li><li>getter和setter设置<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">phone</span></span>{</span><br><span class="line"><span class="keyword">get</span> <span class="title">price</span>(){</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"价格属性被读取"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"price:100"</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">set</span> <span class="title">price</span>(<span class="params">val</span>){</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"价格属性被设置"</span>+val)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> s=<span class="keyword">new</span> phone();</span><br><span class="line">s.price=<span class="number">199</span>;   <span class="comment">//调用set  </span></span><br><span class="line"><span class="built_in">console</span>.log(s.price);  <span class="comment">//调用get</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6扩展数值</p><ul><li><code>Number.EPSILON</code>是JavaScript表示的最小精度<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//1.Number.EPSILON</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a,b</span>)</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Math</span>.abs(a-b)&lt;<span class="built_in">Number</span>.EPSILON)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(equal(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>));</span><br></pre></td></tr></tbody></table></figure></li><li>二进制和八进制。二进制<code>0b</code>,八进制<code>0o</code></li><li><code>Number.inFinite</code> 检测一个数值是否为有限数</li><li><code>Number.isNaN</code> 检测一个数的数值是否为NaN</li><li><code>Number.parseInt</code>字符串转为整数，<code>Number.ParseFlot</code> 字符串转为浮点数。</li><li><code>Number.isInteger</code> 判断一个数是否为整数</li><li><code>Math.trunc</code> 将数字的小数部分抹去</li><li><code>Math.sign</code> 判断一个数到底为正数，负数 还是零</li></ul></li><li><p>ES6对象方法扩展</p><ul><li><code>Object.is</code> 判断两个值是否完全相等。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">11</span>,<span class="number">11</span>));  <span class="comment">//输出true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>));  <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>);   <span class="comment">//输出false</span></span><br></pre></td></tr></tbody></table></figure></li><li><code>Object.assign</code> 对象的合并<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">11</span>,<span class="number">11</span>));  <span class="comment">//输出true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>));  <span class="comment">//输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>);   <span class="comment">//输出false</span></span><br></pre></td></tr></tbody></table></figure></li><li><code>Object.setPrototypeOf</code>设置原型对象 和 <code>Object.getPrototypeOf</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">const</span> school={</span><br><span class="line"><span class="attr">name</span>:<span class="string">"xhu"</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> cities={</span><br><span class="line"><span class="attr">city</span>:[<span class="string">"北京"</span>,<span class="string">"上海"</span>,<span class="string">"广东"</span>,<span class="string">"深圳"</span>]</span><br><span class="line">}</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(school,cities);</span><br><span class="line"><span class="built_in">console</span>.log(school);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6模块化</p><ul><li>模块化是指将一大堆程序文件拆分成许多小的文件，让后将小文件组合起来。</li><li>模块化的好处：<ul><li>防止命名冲突</li><li>代码复用</li><li>高效维护</li></ul></li><li>模块化规范产品，ES6之前的模块化规范有：<ul><li>CommonJs  =&gt; NodeJs、Browserify</li><li>AMD   =&gt; requireJs</li><li>CMD   =&gt; seaJs </li></ul></li><li>ES6 模块化语法<ul><li>模块功能主要由两个命令构成：export和import</li><li><code>export</code> 命令用于规定模块的对外接口。</li><li><code>import</code> 命令用于输入其他模块提供的功能。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// m1.js</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> user =<span class="string">"fanda"</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在其他文件引入</span></span><br><span class="line">    &lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">"./js/m1.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(m1);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>ES6暴露数据语法汇总<ul><li>分别暴露<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">let</span> user =<span class="string">"fanda"</span>;</span><br><span class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></li><li>统一暴露<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user =<span class="string">"fanda"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//统一暴露</span></span><br><span class="line"><span class="keyword">export</span> {user,fn};</span><br></pre></td></tr></tbody></table></figure></li><li>默认暴露，注意在引入使用时为<code>m3.default.user</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//默认暴露m3.js</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span>{</span><br><span class="line"><span class="attr">user</span>:<span class="string">"fanda"</span>,</span><br><span class="line"><span class="attr">change</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"默认暴露方法"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>ES6引入模块语法汇总<ul><li>通用导入方式<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">"./js/m1.js"</span></span><br></pre></td></tr></tbody></table></figure></li><li>解构赋值形式（应对分别暴露）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> {user,fn} <span class="keyword">from</span> <span class="string">"./js/m2.js"</span></span><br><span class="line"><span class="comment">//重名后使用别名</span></span><br><span class="line">  <span class="keyword">import</span> {user <span class="keyword">as</span> newuser,fn} <span class="keyword">from</span> <span class="string">"./js/m1.js"</span></span><br><span class="line"><span class="comment">// 暴露默认暴露模块，必须进行别名</span></span><br><span class="line"><span class="keyword">import</span> {<span class="keyword">default</span> <span class="keyword">as</span> m3} <span class="keyword">from</span> <span class="string">"./js/m3.js"</span></span><br></pre></td></tr></tbody></table></figure></li><li>简便形式，针对于默认暴露<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  m3 <span class="keyword">from</span> <span class="string">"./js/m3.js"</span></span><br><span class="line"><span class="built_in">console</span>.log(m3.user);  <span class="comment">// 不用加 default</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>浏览器使用ES6模块的方式二（针对于需要引入大量文件）<ul><li>首先新建一个Js文件<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"> <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">"./js/m1.js"</span></span><br><span class="line"> <span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">"./js/m2.js"</span></span><br><span class="line"> <span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">"./js/m3.js"</span></span><br></pre></td></tr></tbody></table></figure></li><li>然后利用<code>script</code>标签引入使用<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"./js/app.js"</span> type=<span class="string">"module"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>Babel对ES6模块化代码转换<ul><li>Babel官网：<a href="https://www.babeljs.cn/">https://www.babeljs.cn/</a></li><li>使用babel将Js比较新的语法转化为浏览器能够识别的ES5语法</li><li>（1）安装工具<code>babel-cli</code> , <code>babel-preset-env</code> , <code>browserify(webpack)</code></li><li>（2）通过 <code>npx babel js(js文件位置) -d dist/js --presets-label-preset-env    </code></li><li>（3）打包 <code>npx browserify dist/js/app.js -o dist/bundle.js</code></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性学习001</title>
      <link href="/2022/04/01/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A001/"/>
      <url>/2022/04/01/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A001/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6新特性学习01"><a href="#ES6新特性学习01" class="headerlink" title="ES6新特性学习01"></a>ES6新特性学习01</h1><h2 id="一、关于ES-x"><a href="#一、关于ES-x" class="headerlink" title="一、关于ES(x)"></a>一、关于ES(x)</h2><ol><li><code>ES</code>全称为ECMAScript，是脚本语言的规范，而平时编写的javascript是ECMAScript的一种实现。所以ES新特性其实就是指的JavaScript新特性。</li><li>在2015年发布ES6，每年更新一版。</li><li><code>ES6</code>的重要意义：<ul><li>ES6的版本变动内容最多，具有里程碑意义。</li><li>ES6中加入了许多新的语法特征，编程实现更加简单高效</li><li>ES6是前端发展的趋势，就业必备技能</li></ul></li></ol><h2 id="二、ES6新特性"><a href="#二、ES6新特性" class="headerlink" title="二、ES6新特性"></a>二、ES6新特性</h2><ol><li><p><code>let</code>声明变量以及声明特性</p><ul><li>声明格式<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> b,c,d;</span><br><span class="line"><span class="keyword">let</span> f=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> g=[],h=<span class="string">"1234"</span>,s={};</span><br></pre></td></tr></tbody></table></figure></li><li>let声明变量的特性<ul><li>变量不能重复声明（var声明可以重复）</li><li>块级作用域，只能在块内有效（比如 if else for while等）</li><li>不存在变量提升,不允许在变量声明之前使用变量<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(username);</span><br><span class="line"><span class="keyword">var</span> username=<span class="string">"fanda"</span>;   <span class="comment">//输出undefined</span></span><br><span class="line"><span class="comment">//如果使用let声明则会报错，不允许在变量声明之前使用变量</span></span><br></pre></td></tr></tbody></table></figure></li><li>不影响<code>作用域链</code>效果<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> age=<span class="number">19</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"年龄："</span>+age);</span><br><span class="line">    }</span><br><span class="line">    fn();  <span class="comment">//输出：年龄：18 ,需要与块作用域进行区分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>运用let块级作用域的特性可以实现点击方块变色效果 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;btn.length;i++)</span><br><span class="line">{</span><br><span class="line">btn[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">   btn[i].style.background=<span class="string">"pink"</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><code>const</code>定义常量（常量：值不能修改的量 ）</p><ul><li>一定要赋初始值</li><li>一般的常量需要使用大写（潜规则）</li><li>常量的值不能进行修改</li><li>块级作用域</li><li>对于数组和对象的元素修改，不算做对常量的修改，不会报错</li></ul></li><li><p>ES6-变量的结构赋值</p><ul><li>ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值</li><li>数组的解构赋值<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> F4=[<span class="string">'张三'</span>,<span class="string">'李四'</span>,<span class="string">'王五'</span>,<span class="string">'刘能'</span>];</span><br><span class="line"><span class="keyword">let</span> [z,l,w,n]=F4;</span><br><span class="line"><span class="built_in">console</span>.log(z);</span><br><span class="line"><span class="built_in">console</span>.log(l);</span><br><span class="line"><span class="built_in">console</span>.log(w);</span><br><span class="line"><span class="built_in">console</span>.log(n);  <span class="comment">//按顺序输出数组中的值</span></span><br></pre></td></tr></tbody></table></figure></li><li>对象的解构赋值<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zhao={<span class="attr">name</span>:<span class="string">"赵本山"</span>,<span class="attr">age</span>:<span class="number">65</span>,<span class="attr">xiaopin</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{<span class="built_in">console</span>.log(<span class="string">"我可以演小品!"</span>)}}</span><br><span class="line"><span class="keyword">let</span> {name,age,xiaopin}=zhao;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(xiaopin);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-模板字符串</p><ul><li>声明模板字符串<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">`这是一个模板字符串`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str,<span class="keyword">typeof</span> str);  <span class="comment">//输出字符串和元素类型</span></span><br></pre></td></tr></tbody></table></figure></li><li>内容中可以直接出现换行符   <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li&gt;用户名&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li&gt;密码&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li&gt;确认密码&lt;/li&gt;&lt;/ul&gt;`</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>变量拼接<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username=<span class="string">'fanda'</span>;</span><br><span class="line"><span class="keyword">let</span> out=<span class="string">`<span class="subst">${username}</span>是天下无敌帅！`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(out);   <span class="comment">//实现字符串的拼接</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-简化对象</p><ul><li>ES6允许在大括号中，直接写入变量和函数，作为对象的属性值和方法。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username=<span class="string">'fanda'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我们可以改变！"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> obj={</span><br><span class="line">  username,</span><br><span class="line">  change,</span><br><span class="line">  <span class="function"><span class="title">improve</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是利用简便方法定义的函数！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-箭头函数及其声明特点</p><ul><li>ES6中允许使用【箭头】<code>(=&gt;)</code>定义函数</li><li>声明一个函数 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line"><span class="keyword">let</span> fn()=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="comment">//函数体内容</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//箭头函数的写法</span></span><br><span class="line"><span class="keyword">let</span> fn=<span class="function">(<span class="params">a,b</span>)=&gt;</span>{</span><br><span class="line">  <span class="comment">// 函数体内容</span></span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>,<span class="number">5</span>));</span><br></pre></td></tr></tbody></table></figure></li><li>箭头函数声明的特性：<ul><li><code>this</code>是静态的，始终指向函数声明时所在作用域下的this值   <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">let</span> getName2=<span class="function">()=&gt;</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line"> }</span><br><span class="line">  <span class="built_in">window</span>.name=<span class="string">"fanda"</span>;</span><br><span class="line">  <span class="keyword">const</span> school={</span><br><span class="line">  <span class="attr">name</span>:<span class="string">'ASDFGH'</span></span><br><span class="line">  }</span><br><span class="line"><span class="comment">//普通调用函数</span></span><br><span class="line">getName();</span><br><span class="line">getName2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//call方法调用</span></span><br><span class="line">getName.call(school);</span><br><span class="line">getName2.call(school);</span><br></pre></td></tr></tbody></table></figure></li><li>不能作为构造函数实例化对象</li><li>不能使用 <code>arguments</code>变量</li><li>箭头函数的简写<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1)省略小括号，当形参有且只有一个时</span></span><br><span class="line"><span class="keyword">let</span> add=<span class="function"><span class="params">n</span>=&gt;</span>{</span><br><span class="line">  <span class="keyword">return</span> n+n;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">9</span>));  <span class="comment">//输出18</span></span><br><span class="line"><span class="comment">//2）省略花括号，当代码体只有一条语句时，此时return也必须省略。</span></span><br><span class="line"><span class="comment">//而且语句的执行结果就是函数的返回值。   </span></span><br><span class="line"><span class="keyword">let</span> pow=<span class="function"><span class="params">n</span>=&gt;</span>n*n;</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">9</span>));   <span class="comment">//输出结果为81</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>箭头函数的一般使用场景<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>];  <span class="comment">//选中偶数</span></span><br><span class="line"><span class="keyword">const</span> result=arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>{</span><br><span class="line"> <span class="keyword">if</span>(item%<span class="number">2</span>==<span class="number">0</span>){</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> }<span class="keyword">else</span>{</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> }</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(result);  </span><br><span class="line">  <span class="comment">// 使用箭头函数简化操作</span></span><br><span class="line">  <span class="keyword">const</span> result=arr.filter(<span class="function"><span class="params">item</span>=&gt;</span>item%<span class="number">2</span>===<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure><ul><li>箭头函数<code>适合</code>与 this无关的回调，定时器，数组的方法回调。</li><li>箭头函数<code>不适合</code>与 this有关的回调，事件回调，对象的方法。</li></ul></li></ul></li><li><p>ES6-函数参数默认值</p><ul><li>形参初始值(具有默认值的参数一般位置靠后)<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b,c=<span class="number">10</span></span>)</span>{</span><br><span class="line"><span class="keyword">return</span> a+b+c;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">//输出6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">//输出13</span></span><br></pre></td></tr></tbody></table></figure></li><li>默认值可以与解构赋值一起使用<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">{host,username,password,port=<span class="string">"8000"</span>}</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(host);</span><br><span class="line"><span class="built_in">console</span>.log(username);</span><br><span class="line"><span class="built_in">console</span>.log(password);</span><br><span class="line"><span class="built_in">console</span>.log(port);</span><br><span class="line">}</span><br><span class="line">connect({</span><br><span class="line"><span class="attr">host</span>:<span class="string">'www.baidu.com'</span>,</span><br><span class="line"><span class="attr">username</span>:<span class="string">'root'</span>,</span><br><span class="line"><span class="attr">password</span>:<span class="string">'root'</span>,</span><br><span class="line"><span class="attr">prot</span>:<span class="string">'3306'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-rest参数</p><ul><li>rest参数用于获取函数的实参，用来代替arguments。<code>注：rest参数必须放在其他参数最后</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5中的arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);  <span class="comment">//是对象类型</span></span><br><span class="line">}</span><br><span class="line">date(<span class="string">"abc"</span>,<span class="string">"张三"</span>)</span><br><span class="line"><span class="comment">//ES6中rest参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date2</span>(<span class="params">...args</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(args);</span><br><span class="line">}</span><br><span class="line">date2(<span class="string">"abc"</span>,<span class="string">"张三"</span>);  <span class="comment">//数据类型是数组</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-扩展运算符</p><ul><li>[…] 扩展运算符能将【数组】转换为  逗号隔开的参数序列<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> user=[<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myname</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">}</span><br><span class="line">nyname(user);  <span class="comment">//直接输出数组</span></span><br><span class="line">myname(...user);  <span class="comment">//输出一个对象包含三个元素</span></span><br></pre></td></tr></tbody></table></figure></li><li>扩展运算符的运用：<code>数组合并</code><ul><li>数组合并,ES5的方法可以用<code>concat()</code>方法<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> arr1=[<span class="string">"张三"</span>,<span class="string">"李四"</span>];</span><br><span class="line"><span class="keyword">const</span> arr2=[<span class="string">"小红"</span>,<span class="string">"小王"</span>];</span><br><span class="line"><span class="comment">// const arr=arr1.concat(arr2);</span></span><br><span class="line"><span class="keyword">const</span> arr=[...arr1,...arr2];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></tbody></table></figure></li><li>数组克隆<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> arr1=[<span class="string">"张三"</span>,<span class="string">"李四"</span>];</span><br><span class="line"><span class="keyword">const</span> arr2=[...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></tbody></table></figure></li><li>将伪数组转换为真正的数组</li></ul></li></ul></li><li><p>ES6-Symbol数据类型</p><ul><li>ES6引入了一种新的原始数据类型Symbol,表示独一无二的值。是一种类似于字符串的数据类型</li><li>Symbol特点：<ul><li>Symbol的值是唯一的，用来解决命名冲突问题；</li><li>Symbol值不能与其他数据类型进行运算；</li><li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象所有键名。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//创建symbol</span></span><br><span class="line"><span class="keyword">let</span> s=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s,<span class="keyword">typeof</span> s);</span><br><span class="line"><span class="keyword">let</span> s1=<span class="built_in">Symbol</span>(<span class="string">"李四"</span>);</span><br><span class="line"><span class="keyword">let</span> s2=<span class="built_in">Symbol</span>(<span class="string">"李四"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1==s2); <span class="comment">//返回false</span></span><br><span class="line"><span class="comment">//Symbol.for()创建</span></span><br><span class="line"><span class="keyword">let</span> s3=<span class="built_in">Symbol</span>.for(<span class="string">"张三"</span>);</span><br><span class="line"><span class="keyword">let</span> s4=<span class="built_in">Symbol</span>.for(<span class="string">"张三"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s3==s4); <span class="comment">//返回true</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>对象添加Symbol类型的属性<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//对象扩展方法，当不知道对象中具有哪些属性和方法时</span></span><br><span class="line"><span class="keyword">let</span> game={</span><br><span class="line"><span class="attr">name</span>:<span class="string">"狼人杀"</span>,</span><br><span class="line"><span class="attr">number</span>:<span class="number">12</span>,</span><br><span class="line"><span class="attr">up</span>:<span class="number">22</span>,</span><br><span class="line"><span class="attr">down</span>:<span class="string">"下降"</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//自定义对象</span></span><br><span class="line"><span class="keyword">let</span> methods={</span><br><span class="line"><span class="attr">up</span>:<span class="built_in">Symbol</span>(),</span><br><span class="line"><span class="attr">down</span>:<span class="built_in">Symbol</span>()</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对象扩展方法</span></span><br><span class="line">game[methods.up]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以向上"</span>);</span><br><span class="line">}</span><br><span class="line">game[methods.down]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以向下"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(game);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">let</span> photo={</span><br><span class="line"><span class="attr">name</span>:<span class="string">"天空"</span>,</span><br><span class="line">[<span class="built_in">Symbol</span>(<span class="string">'say'</span>)]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以说话"</span>);</span><br><span class="line">},</span><br><span class="line">[<span class="built_in">Symbol</span>(<span class="string">'see'</span>)]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我可以看见"</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(photo);</span><br></pre></td></tr></tbody></table></figure></li><li>Symbol内置值，除了定义自己使用的Symbol值外，ES6还提供了11个内置的Symbol值，指向语法内部使用的方法。<table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Symbol.hasInstance</td><td align="left">当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法</td></tr><tr><td align="left">Symbol.isConcatSpreadable</td><td align="left">对象的Symbol.isConcatSpreadable属性等于的是一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开</td></tr><tr><td align="left">Symbol.unscopables</td><td align="left">该对象指向使用with关键字时，哪些属性会被with环境排除</td></tr><tr><td align="left">Symbol.match</td><td align="left">当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值</td></tr><tr><td align="left">Symbol.replace</td><td align="left">当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值</td></tr><tr><td align="left">Symbol.search</td><td align="left">当该对象被str.search(myObject)方法调用时，会返回该方法的返回值</td></tr><tr><td align="left">Symbol.split</td><td align="left">当该对象被str.split(myObject)方法调用时，会返回该方法的返回值</td></tr><tr><td align="left">Symbol.iterator</td><td align="left">对象进行for…of循环时，会调用此方法，返回对象的默认遍历器</td></tr><tr><td align="left">Symbol.toPrimitive</td><td align="left">该对象被转为原始类型的值时，会调用这个方法返回该对象对应的原始类型值</td></tr><tr><td align="left">Symbol.toStringTag</td><td align="left">当该对上面调用tostring方法时，会返回该方法的返回值</td></tr><tr><td align="left">Symbol.species</td><td align="left">创建衍生对象时，会使用该属性</td></tr></tbody></table></li></ul></li><li><p>ES6-迭代器</p><ul><li>迭代器（iterator）是一种接口，为各种不同的数据类型提供统一的访问机制。任何数据结构只要部署到<code>Iterator</code>接口上，就可以完成遍历操作。</li><li>ES6创建了一种新的遍历命令<code>for...of</code>循环，Iterator接口主要提供for…of消费。</li><li>原生具备iterator接口的数据（可用for…of遍历）,Array , Arguments , Set , Map ,  String , TypedArray , NodeList</li><li>工作原理：<ul><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用对象的next方法指针自动指向数据结构的第一个成员。</li><li>接下来不断调用next方法，指针一直往后移动，指到指向最后一个成员。</li><li>每次调用next方法返回一个包含value和done属性的对象。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> xiyou=[<span class="string">"唐僧"</span>,<span class="string">"孙悟空"</span>,<span class="string">"猪八戒"</span>,<span class="string">"沙僧"</span>];</span><br><span class="line"><span class="keyword">let</span> iter=xiyou[<span class="built_in">Symbol</span>.iterator]();  <span class="comment">//创建指针</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br><span class="line"><span class="built_in">console</span>.log(iter.next());</span><br></pre></td></tr></tbody></table></figure><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2Fes61.png" alt="运行返回结果"></li></ul></li><li>迭代器的运用，自定义遍历对象<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//定义对象</span></span><br><span class="line">    <span class="keyword">const</span> obj={</span><br><span class="line"><span class="attr">major</span>:<span class="string">"软件工程"</span>,</span><br><span class="line"><span class="attr">stus</span>:[<span class="string">"小红"</span>,<span class="string">"小李"</span>,<span class="string">"小张"</span>,<span class="string">"小华"</span>], <span class="comment">//对象中包含数组</span></span><br><span class="line">[<span class="built_in">Symbol</span>.iterator](){   <span class="comment">//创建一个指针对象</span></span><br><span class="line"><span class="keyword">let</span> index=<span class="number">0</span>;  </span><br><span class="line">_this=<span class="built_in">this</span>;  </span><br><span class="line"><span class="keyword">return</span>{</span><br><span class="line"><span class="attr">next</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{   <span class="comment">//此处运用箭头函数可以直接使用this</span></span><br><span class="line"><span class="keyword">if</span>(index&lt;_this.stus.length){</span><br><span class="line"><span class="keyword">const</span> res={<span class="attr">value</span>:_this.stus[index],<span class="attr">done</span>:<span class="literal">false</span>}</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> {<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">  <span class="comment">//通过for...of遍历得出对象中数组的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj){</span><br><span class="line"><span class="built_in">console</span>.log(v);  <span class="comment">//输出 "小红","小李","小张","小华"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>ES6-生成器函数声明与调用</p><ul><li>生成器函数是ES6提供的一种异步编程解决方案，语法行为和传统函数完全不同</li><li>生成器函数的声明与调用<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> * <span class="title">fn</span>(<span class="params"></span>)</span>{</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"生成器函数"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> iterator=fn();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//以迭代器的形式输出内容</span></span><br></pre></td></tr></tbody></table></figure></li><li>生成器函数的参数传递（实现异步编程） <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> * <span class="title">fn</span>(<span class="params">arg</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(arg);   <span class="comment">//打印出“AAA” (最先显示)</span></span><br><span class="line"><span class="keyword">let</span> one=<span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(one);  <span class="comment">//打印出“BBB”  （第三显示）</span></span><br><span class="line">  <span class="keyword">let</span> two=<span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line"><span class="built_in">console</span>.log(two);  <span class="comment">//打印出“CCC”</span></span><br><span class="line"> }</span><br><span class="line"><span class="keyword">let</span> iterator=fn(<span class="string">"AAA"</span>);</span><br><span class="line">  <span class="comment">// next()方法传参，参数将作为上一个yield语句的返回结果（实现异步编程）</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());   <span class="comment">// 打印出迭代第一个对象{value:111,done:false} （第二显示）</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">"BBB"</span>));   <span class="comment">// 打印出迭代第二个对象{value:222,done:false}</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">"CCC"</span>));   <span class="comment">// 打印出迭代第三个对象{value:undefined,done:true}</span></span><br></pre></td></tr></tbody></table></figure></li><li>实现异步请求的案例<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//实现1s后输出111,2s后输出222,3s后输出333</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">iterator.next();  <span class="comment">//调用函数</span></span><br><span class="line">},<span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">iterator.next(); <span class="comment">//调用函数</span></span><br><span class="line">},<span class="number">2000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">},<span class="number">3000</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//生成器函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> * <span class="title">fn</span>(<span class="params"></span>)</span>{</span><br><span class="line"> <span class="keyword">yield</span> one(),</span><br><span class="line"> <span class="keyword">yield</span> two(),</span><br><span class="line"> <span class="keyword">yield</span> three()</span><br><span class="line"> }</span><br><span class="line"> <span class="keyword">let</span> iterator=fn();</span><br><span class="line"> iterator.next();  <span class="comment">//初始调用函数</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax学习笔记</title>
      <link href="/2022/03/31/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/31/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="学习Ajax"><a href="#学习Ajax" class="headerlink" title="学习Ajax"></a>学习Ajax</h1><h2 id="一、原生Ajax"><a href="#一、原生Ajax" class="headerlink" title="一、原生Ajax"></a>一、原生Ajax</h2><ol><li>AJAX<ul><li>AJAX（Asynchronous JavaScript AND XML），就是异步JS和XNL。通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势为<code>无刷新获取数据</code>。AJAX不是新的编程语言，而是将现有标准结合在一起使用的新方式。</li></ul></li><li>XML介绍<ul><li>XML可扩展标记语言，被设计用来传输和存储数据。现在已被JSON取代</li></ul></li><li>AJAX的特点：<ul><li>AJAX的优点：<ul><li>可以无需刷新页面与服务器端进行通信</li><li>允许根据用户事件来更新部分页面内容</li></ul></li><li>AJAX的缺点：<ul><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好 （SEO搜索引擎优化）</li></ul></li></ul></li><li>AJAX的使用<ul><li>express基于Node.js平台，快速、开放、极简的Web开发框架。</li><li>发送文件的方法是<code>response.sendFile(_dirname+'文件路径')</code>，可以发送文件，比如html页面<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入express</span></span><br><span class="line"> <span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>)</span><br><span class="line"> <span class="comment">//2.创建应用对象</span></span><br><span class="line"> <span class="keyword">const</span> app = express()</span><br><span class="line"> <span class="comment">//3.创建路由规则</span></span><br><span class="line"> <span class="comment">//request是对请求报文的封装</span></span><br><span class="line"> <span class="comment">//response是对响应报文的一个封装</span></span><br><span class="line"> app.get(<span class="string">'/server'</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> {</span><br><span class="line">     response.send(<span class="string">'hello express'</span>);</span><br><span class="line"> });</span><br><span class="line"> <span class="comment">// 4.监听端口</span></span><br><span class="line"> app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"服务端已经启动 8000端口"</span>);</span><br><span class="line"> });</span><br></pre></td></tr></tbody></table></figure></li><li>用户端发送ajax请求的步骤(GET请求)<ul><li>创建对象</li><li>初始化，设置请求方法和URL</li><li>发送请求</li><li>事件绑定，处理服务端返回的数据</li><li>若要添加参数可以直接在请求URL后面添加,<code>URL?a=100&amp;b=200</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1.创建对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//2.初始化，设置请求方法和URL</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://192.168.1.104:8000/server'</span>);</span><br><span class="line"><span class="comment">//3.发送</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">//4.事件绑定 处理服务端返回的结果</span></span><br><span class="line"><span class="comment">// on when 当...的时候</span></span><br><span class="line"><span class="comment">//readystate 是xhr对象中的属性，表示状态0，1，2，3，4</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">//判断服务端返回所有的结果时候调用</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) {</span><br><span class="line">        <span class="comment">//判断响应状态码,2xx均表示成功</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;= <span class="number">300</span>) {</span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.status); <span class="comment">// 响应状态码</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText); <span class="comment">// 状态字符串</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.getAllResponseHeaders()); <span class="comment">// 所有响应头</span></span><br><span class="line">            <span class="built_in">console</span>.log(xhr.response); <span class="comment">//响应体</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            alert(<span class="string">"请求失败!"</span>)</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>用户端发送ajax请求的步骤(POST请求)<ul><li>创建对象</li><li>初始化，设置请求方法和URL</li><li>发送请求,可以写要发送的数据到<code>xhr.send('发送的数据')</code></li><li>事件绑定，处理服务端返回的数据</li></ul></li><li>AJAX发送请求设置请求头：<code>xhr.setRequestHeader('content-type':'application/x-www-form-urlencoded')</code><ul><li>content-type:用来设置请求体内容类型的</li><li>一般会将身份校验的信息放在请求头信息里。</li></ul></li><li>后端返回JSON数据（字符串）转换<ul><li>手动转换，使用<code>JSON.parse()</code>方法进行转换</li><li>自动转换，设置响应体数据类型：<code>xhr.responseType='json'</code></li></ul></li><li>node.js中使用express开发，安装nodemon改变代码自动重启服务<code>npm install -g nodemon</code></li><li>AJAX发送请求，IE缓存问题 <ul><li>问题描述：IE浏览器对请求结果具有缓存操作，会将上一次的请求放入缓存。这样导致不能实时更新请求结果。</li><li>解决问题：在请求初始化的时候，在URL后面加入事件戳，使得每次请求都不同。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           xhr.open(<span class="string">'GET'</span>,<span class="string">'http://192.168.1.104:8000/ie?t='</span>+<span class="built_in">Date</span>.now())</span><br><span class="line">        <span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">5. AJAX请求超时与网络异常处理</span></span><br><span class="line"><span class="string">    - 超时`</span>取消请求<span class="string">`：`</span>xhr.timeout=<span class="number">2000</span><span class="string">`</span></span><br><span class="line"><span class="string">    - 超时执行的回调：`</span>xhr.ontimeout<span class="string">`</span></span><br><span class="line"><span class="string">      `</span><span class="string">``</span>javascript</span><br><span class="line">          xhr.ontimeout=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">              alert(<span class="string">"网络超时，请稍后重试!"</span>);</span><br><span class="line">          }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>网络异常回调：<code>xhr.onerror</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    alert(<span class="string">"网络似乎出了一些问题!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>AJAX取消请求<ul><li>手动取消请求<code>abort()</code> </li><li>abort()是声明请求对象的一个方法，使用:<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.abort();   <span class="comment">//取消请求</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>AJAX请求重复发送问题<ul><li>当用户重复发送请求时，可以在每次发送请求之前取消该请求。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">document</span>.querySelector(<span class="string">'.result'</span>);</span><br><span class="line"><span class="keyword">let</span> isSending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="literal">null</span>;</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (isSending) xhr.abort(); <span class="comment">//如果为true则取消请求</span></span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'http://192.168.1.103:8000/server'</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        isSending = <span class="literal">true</span>; <span class="comment">//修改标识符变量的值</span></span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">            <span class="comment">//判断服务端返回所有的结果时候调用</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) {</span><br><span class="line">                isSending = <span class="literal">false</span>; <span class="comment">//请求成功则修改标识符的值</span></span><br><span class="line">                <span class="comment">// 判断响应状态码,2xx均表示成功</span></span><br><span class="line">                <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) {</span><br><span class="line">                    res.innerHTML = xhr.response;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>jQuery发送AJAX请求<ul><li>jQuery发送GET请求<code>$.get('请求路径',{请求参数，键值对1的形式},回调函数,设置响应体数据类型)</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'http://192.168.1.103:8000/server'</span>,{<span class="attr">name</span>:<span class="string">'fanda'</span>,<span class="attr">age</span>:<span class="number">22</span>},<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"返回的结果是"</span>+data); </span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>jQuery发送POST请求：<code>$.post('请求路径',{请求参数，键值对1的形式},回调函数,设置响应体数据类型)</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'http://192.168.1.103:8000/server'</span>,{<span class="attr">name</span>:<span class="string">'fanda'</span>,<span class="attr">age</span>:<span class="number">22</span>},<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"返回的结果是"</span>+data); </span><br><span class="line"> },<span class="string">'json'</span>)</span><br></pre></td></tr></tbody></table></figure></li><li>通用型方法发送ajax请求:<code>$.ajax({url,发送参数，请求类型，成功的回调})</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$.ajax({</span><br><span class="line">    <span class="comment">//url</span></span><br><span class="line">    <span class="attr">url</span>:<span class="string">'http://192.168.1.103:8000/server'</span>,</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    <span class="attr">data</span>:{<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>},</span><br><span class="line">    <span class="comment">//请求类型</span></span><br><span class="line">    <span class="attr">type</span>:<span class="string">'GET'</span>,</span><br><span class="line">    <span class="comment">//响应体结果类型</span></span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">'json'</span>,</span><br><span class="line">    <span class="comment">//c成功的回调</span></span><br><span class="line">    <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">2000</span>,</span><br><span class="line">    <span class="comment">//失败请求的回调</span></span><br><span class="line">    <span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求出错了！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>Axios发送ajax请求<ul><li>Axios是一个基于 promise 的 HTTP 库</li><li>设置baseURL：<code>axios.defaults.baseURL=''</code></li><li>发送get请求的基本格式：<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'http://192.168.1.103:8000'</span></span><br><span class="line">btn[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">//get请求</span></span><br><span class="line">    axios.get(<span class="string">'/server'</span>, {</span><br><span class="line">        <span class="comment">//url参数</span></span><br><span class="line">        <span class="attr">params</span>: {</span><br><span class="line">            <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">        },</span><br><span class="line">        <span class="comment">//设置请求头信息</span></span><br><span class="line">        <span class="attr">headers</span>: {</span><br><span class="line">            <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">        }</span><br><span class="line">    }).then(<span class="function"><span class="params">value</span>=&gt;</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2F001.png" alt="请求打印出的结果"></li><li>发送POST请求：<code>axios.post('url'[,data[,config]])</code>,config为其他配置</li><li>Axios通用方式发送请求<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">axios({</span><br><span class="line">    <span class="comment">//url</span></span><br><span class="line">    <span class="attr">url</span>:<span class="string">'/server'</span>,</span><br><span class="line">    <span class="comment">//url参数</span></span><br><span class="line">    <span class="attr">params</span>:{</span><br><span class="line">        <span class="attr">i</span>:<span class="number">10</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">22</span>,</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//头信息参数</span></span><br><span class="line">    <span class="attr">headers</span>:{</span><br><span class="line">        <span class="attr">a</span>:<span class="number">100</span>,</span><br><span class="line">        <span class="attr">b</span>:<span class="number">200</span>,</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//请求体参数</span></span><br><span class="line">    <span class="attr">data</span>:{</span><br><span class="line">        <span class="attr">username</span>:<span class="string">'admin'</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">'admin'</span></span><br><span class="line">    }</span><br><span class="line">}).then(<span class="function"><span class="params">response</span>=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="comment">//响应状态码</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="comment">//响应状态字符串</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="comment">//响应头信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="comment">// 响应体细腻些</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>使用fetch函数发送AJAX请求<ul><li>fetch()函数的基本使用<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line"> fetch(<span class="string">'http://192.168.1.103:8000/fetch'</span>, {</span><br><span class="line">     <span class="comment">//请求方法</span></span><br><span class="line">     <span class="attr">method</span>: <span class="string">'POST'</span>,</span><br><span class="line">     <span class="comment">//请求头</span></span><br><span class="line">     <span class="attr">headers</span>: {</span><br><span class="line">         <span class="attr">name</span>: <span class="string">'fanda'</span></span><br><span class="line">     },</span><br><span class="line">     <span class="comment">//请求体</span></span><br><span class="line">     <span class="attr">body</span>: <span class="string">'username=admin&amp;password=admin'</span></span><br><span class="line"> }).then(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">     <span class="comment">//return response.text();</span></span><br><span class="line">     <span class="keyword">return</span> response.json()</span><br><span class="line"> }).then(<span class="function"><span class="params">response</span> =&gt;</span> {</span><br><span class="line">     <span class="built_in">console</span>.log(response);</span><br><span class="line"> })  </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>AJAX关于跨域<ul><li>ajax同源策略：<ul><li>同源策略（Same-Origin Policy）最早由Netscape公司提出，是浏览器的一种安全策略。</li><li>同源：协议、域名、端口号 必须完全相同</li><li>违背同源策略就是<code>跨域</code></li><li>ajax默认遵循同源策略。</li></ul></li><li>解决跨域问题的几个方案：<code>JSONP</code>, <code>CORS</code></li><li>JSONP解决跨域<ul><li>JSONP(JSON with Padding),是一个非官方的跨域解决方案，纯粹凭借程序员开发出来。只支持get请求。</li><li>JSONP的工作原理：由于网页中有一些标签天生具有跨域能力，比如:<code>img</code> , <code>link</code> , <code>iframe</code> , <code>script</code>。于是JSONP就利用script标签的跨域能力来发送请求。 请求返回带参数的函数引用，前端接收数据当成js代码执行。 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>)</span><br><span class="line">val.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> username = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="comment">//创建script标签</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">        <span class="comment">//设置标签的src属性</span></span><br><span class="line">    script.src = <span class="string">'http://192.168.1.103:8000/check-name'</span></span><br><span class="line">        <span class="comment">//将标签插入到文档中</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">}</span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>{</span><br><span class="line">    val.style.border = <span class="string">"1px solid red"</span></span><br><span class="line">    p.innerHTML = data.msg</span><br><span class="line">}</span><br><span class="line">val.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        p.innerHTML = <span class="string">""</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>CORS解决跨域<ul><li>CORS（Cross-Origin Resource Sharing）,跨域资源共享。<code>CORS</code>是官方的跨域解决方案，他的特点是不需要在客户端做任何特殊操作，完全在服务器中进行处理。支持<code>get</code>和<code>post</code>请求。跨域资源共享新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</li><li>CORS工作原理：通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到响应后会对响应放行。</li><li>CORS的使用： <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">response.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'*'</span>);</span><br><span class="line">response.setHeader(<span class="string">'Access-Control-Allow-Method'</span>, <span class="string">'*'</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ajax学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记08</title>
      <link href="/2022/03/29/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B008/"/>
      <url>/2022/03/29/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B008/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记08——本地存储"><a href="#javascript学习笔记08——本地存储" class="headerlink" title="javascript学习笔记08——本地存储"></a>javascript学习笔记08——本地存储</h1><h2 id="一、-本地存储sessionStorage和localStorage"><a href="#一、-本地存储sessionStorage和localStorage" class="headerlink" title="一、 本地存储sessionStorage和localStorage"></a>一、 本地存储sessionStorage和localStorage</h2><ol><li>本地存储的特征<ul><li>数据存储在用户浏览器中</li><li>设置，读取方便，甚至页面刷新不丢失数据</li><li>容量较大，<code>sessionStorage</code>约5M，<code>localStorage</code>约20M</li><li>只能存储字符串，可以将对象<code>JSON.stringify()</code>编码后存储</li></ul></li><li>window.sessionStroage<ul><li>生命周期为关闭浏览器窗口</li><li>在同一个窗口（页面）下数据可以共享</li><li>以键值对的形式存储使用,</li><li>存储数据：<code>sessionStorage.setItem(key,value);</code></li><li>获取数据：<code>sessionStorage.getItem(key);</code></li><li>删除数据：<code>sessionStorage.removeItem(key);</code></li><li>删除所有数据：<code>sessionStorage.clear()</code></li></ul></li><li>window.localStorage<ul><li>生命周期是<code>永久生效</code>，除非手动删除，否则关闭页面也会存在。\</li><li>可以多窗口（页面）共享（同一个浏览器可以共享）</li><li>以键值对的形式存储</li><li>存储数据：<code>localStorage.setItem(key,value)</code></li><li>获取数据：<code>localStorage.getItem(key)</code></li><li>删除数据：<code>localStorage.removeItem(key)</code></li><li>删除所有数据：<code>localStorage.clear()</code></li></ul></li><li><code>案例：</code>记住用户名<ul><li>把数据存储起来，用到本地存储</li><li>关闭页面，可以显示用户名，故为使用localStorage</li><li>打开页面，先判断是否有这个用户名，如果有则在表单里面显示用户名，并且勾选复选框</li><li>当复选框发生改变的时候change事件</li></ul></li></ol><h2 id="二、jQuary基础知识"><a href="#二、jQuary基础知识" class="headerlink" title="二、jQuary基础知识"></a>二、jQuary基础知识</h2><ol><li>jquery概述 <ul><li>JavaScript库：即library,是一个封装好的特定的集合（方法和函数），从封装一大堆函数的角度理解库，就是在这个库中，封装了很对预先定义好的函数在里面，比如动画animate，hide，show。比如获取元素等</li><li>常见的JavaScript库：这些库都是对原生JavaScript的封装，<code>内部都是用JavaScript实现的</code>，主要学习jQuery<ul><li>jQuery</li><li>prototype</li><li>YUI</li><li>Dojo</li><li>Ext Js</li><li>移动端的zepto</li></ul></li></ul></li><li>jQuery的概念<br> -jQuery是一个快速的、简洁的JavaScript库 ，其设计的宗旨是”write Less,Do More“,即提倡写更少的代码，做更多的事情。<ul><li>jQuery封装了JavaScript常用的功能代码，优化了DOM操作，事件处理，动画设计和Ajax请求。</li><li>优点：<ul><li>轻量级。核心文件才几十kb，不会影响页面加载速度</li><li>垮浏览器兼容，基本兼容了现在主流的浏览器</li><li>链式编程，隐式迭代</li><li>对事件，样式，动画的支持。大大简化了DOM操作</li><li>支持插件扩展开发。有着丰富的第三方插件。例如：树形菜单、日期控件、轮播图等</li></ul></li></ul></li><li>jQuery使用<ul><li>jQuery的下载：<a href="https://jquery.com/">https://jquery.com/</a></li><li>引入jQuery函数</li><li>jQuery入口函数:等着DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源都加载完。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">// 此处是页面DOM加载完成后的入口（更常用）</span></span><br><span class="line">});</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">     <span class="comment">// 此处是页面DOM加载完成后的入口</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li>jQuery的顶级对象<code>$</code><ul><li>$是jQuery的别称（另外的名字），在代码中可以使用jQuery代替$,通常使用<code>$</code></li><li><code>$</code>是jQuery的顶级对象，相当于原生JavaScript中的window，把元素利用$包装成jQuery对象，就可以调用jQuery的方法。</li></ul></li><li>jQuery对象和DOM对象<ul><li>用原生JS获取来的对象就是DOM对象</li><li>用jQuery获取来的元素就是jQuery对象</li><li>jQuery对象的本质是：利用$对DOM对象包装后产生的对象（伪数组的形式存储）</li><li>jQuery只能使用jQuery方法，DOM对象则使用原生的JavaScript方法。</li></ul></li><li>DOM对象与jQuery对象之间可以相互转换<ul><li>DOM对象转换为jQuery对象：<code>$(DOM对象)</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>);  </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> mydiv=<span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line">$(mydiv); <span class="comment">// z转换为jQuery对象 </span></span><br></pre></td></tr></tbody></table></figure></li><li>jQuery对象转换为DOM对象<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>)[index];   <span class="comment">//index是索引号</span></span><br><span class="line">$(<span class="string">'div'</span>).get(index);  <span class="comment">//index是索引号</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol><h2 id="三、jQuery常用的API"><a href="#三、jQuery常用的API" class="headerlink" title="三、jQuery常用的API"></a>三、jQuery常用的API</h2><ol><li><p>jQuery选择器 </p><ul><li><p>jQuery基础选择器将原生JS做了封装，使获取元素统一标准</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'选择器'</span>)    <span class="comment">//里面选择器直接写CSS选择器即可，添加引号</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>常用选择器</p><table><thead><tr><th align="center">名称</th><th align="left">用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">ID选择器</td><td align="left">$(‘#ID’)</td><td align="left">获取固定ID的元素</td></tr><tr><td align="center">全选选择器</td><td align="left">$(‘*’)</td><td align="left">匹配所有元素</td></tr><tr><td align="center">类选择器</td><td align="left">$(‘.class’)</td><td align="left">获取同一类class元素</td></tr><tr><td align="center">标签选择器</td><td align="left">$(‘div’)</td><td align="left">获取同一标签所有元素</td></tr><tr><td align="center">并集选择器</td><td align="left">$(‘div,p,li’)</td><td align="left">选取多个元素</td></tr><tr><td align="center">交集选择器</td><td align="left">$(‘li.current’)</td><td align="left">交集元素</td></tr><tr><td align="center">子代选择器</td><td align="left">$(‘ul&gt;li’)</td><td align="left">使用<code>&gt;</code>号，获取亲儿子的层级元素，注：并不会获取孙子层的元素</td></tr><tr><td align="center">后代选择器</td><td align="left">$(‘ul li’)</td><td align="left">使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等</td></tr></tbody></table></li><li><p>jQuery样式设置<code>$('div').css("属性","值")</code></p></li><li><p>隐式迭代（重要）</p><ul><li>遍历内部DOM元素（伪数组形式存储）的过程就叫做<code>隐式迭代</code></li><li>简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环迭代，简化操作，方便调用。</li></ul></li><li><p>jQuery筛选选择器</p><table><thead><tr><th align="center">语法</th><th align="left">用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">:first</td><td align="left">$(‘li:first’)</td><td align="left">获取第一个li元素</td></tr><tr><td align="center">:last</td><td align="left">$(‘li:last’)</td><td align="left">获取最后一个li元素</td></tr><tr><td align="center">:eq(index)</td><td align="left">$(‘li:eq(2)’)</td><td align="left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始</td></tr><tr><td align="center">:odd</td><td align="left">$(‘li:odd’)</td><td align="left">获取到的li元素中，选择索引号为奇数的元素</td></tr><tr><td align="center">:even</td><td align="left">$(‘li:even’)</td><td align="left">获取到的li元素中，选择索引号为偶数的元素</td></tr></tbody></table></li><li><p>jQuery筛选方法</p><table><thead><tr><th align="center">语法</th><th align="left">用法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">parent()</td><td align="left">$(‘li’).parent();</td><td align="left">查找父级</td></tr><tr><td align="center">children(selector)</td><td align="left">$(‘ul’).children(‘li’);</td><td align="left">相当于<code>$('ul&gt;li')</code>，最近一级（亲儿子）</td></tr><tr><td align="center">find(selector)</td><td align="left">$(‘ul’).find(‘li’);</td><td align="left">相当于<code>$('ul li')</code>后代选择器</td></tr><tr><td align="center">siblings(selector)</td><td align="left">$(‘.first’).siblings(‘li’);</td><td align="left">查找兄弟节点，不包括自己本身</td></tr><tr><td align="center">nextAll([expr])</td><td align="left">$(‘.first’).nextAll()</td><td align="left">查找当前元素<code>之后</code>所有同辈元素</td></tr><tr><td align="center">prevtAll([]expr)</td><td align="left">$(‘.last’).prevtAll()</td><td align="left">查找当前元素<code>之前</code>所有同辈元素</td></tr><tr><td align="center">hasClass(class)</td><td align="left">$(‘div’).hasClass(‘protected’);</td><td align="left">检查当前元素是否含有某个特定类，如果有则返回true</td></tr><tr><td align="center">eq(index)</td><td align="left">$(‘li’).eq(2);</td><td align="left">相当于<code>$('li:eq(2)')</code>,index从0开始</td></tr></tbody></table></li><li><p>jQuery里面的排他思想</p><ul><li>想要多选一的效果，排他思想：当前元素设置样式，其余元素清除样式 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    $(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="comment">//点击的元素背景变为蓝色</span></span><br><span class="line">$(<span class="built_in">this</span>).css(<span class="string">'background'</span>,<span class="string">'blue'</span>);</span><br><span class="line"><span class="comment">//其余兄弟去除背景</span></span><br><span class="line">$(<span class="built_in">this</span>).siblings(<span class="string">'button'</span>).css(<span class="string">'background'</span>,<span class="string">''</span>);</span><br><span class="line">   })</span><br><span class="line">   })</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>jQuery中得到元素索引号<code>$(this).index()</code></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    $(<span class="string">'.left li'</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="keyword">var</span> index=$(<span class="built_in">this</span>).index();</span><br><span class="line"><span class="built_in">console</span>.log(index);  <span class="comment">//打印出鼠标经过1元素的索引号</span></span><br><span class="line">$(<span class="string">'.right div'</span>).eq(index).show();</span><br><span class="line">$(<span class="string">'.right div'</span>).eq(index).siblings().hide();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li><p>链式编程：节省代码量，使代码看起来更加简洁</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//实现排他思想，当前元素文字颜色变为红色，其余元素去除样式</span></span><br><span class="line">$(<span class="built_in">this</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>);</span><br><span class="line">$(<span class="built_in">this</span>).siblings().css(<span class="string">'color'</span>,<span class="string">''</span>);</span><br><span class="line"><span class="comment">// 简化写法，运用链式编程</span></span><br><span class="line">$(<span class="built_in">this</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>).siblings().css(<span class="string">'color'</span>,<span class="string">''</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用链式编程需要注意是在为哪个元素执行样式</li></ul></li></ul></li><li><p>jQuery样式操作</p><ul><li>jQuery可以使用CSS方法来修改简单元素样式；同时也可以操作类修改多个样式</li><li>参数只写属性名，则是返回属性值<code>$(this).css("color")</code>,（带有单位的字符串）</li><li>参数是<code>属性名</code>，<code>属性值</code>，使用逗号分隔，是设置样式，属性必须加引号，值如果是数字可以可以不用跟单位和引号。</li><li>参数可以是对象形式，方便设置多个样式。属性名和属性值用冒号隔开，属性可以不用加引号。<ul><li>基本写法<code>$(this).css({'color':'white','font-size':'24px'});</code></li><li>如果是复合属性则必须使用驼峰命名法，例如<code>background-color</code>必须写为<code>backgroundColor</code></li><li>如果值不是数字则需要添加引号</li></ul></li><li>设置类样式方法<ul><li>作用等同于以前的classList,可以操作类样式。注：操作类里面的样式不用加点。</li><li>添加类：<code>$('div').addClass('current');</code> (addClass)</li><li>删除类：<code>$('div').removeClass('current');</code> (removeClass)</li><li>切换类：<code>$('div').toggleClass('current');</code>  (toggleClass) 如果元素没有这个类则添加上这个类名，如存在这个类则删除掉。</li></ul></li><li>类操作与className区别<ul><li>原生JS中className会覆盖元素原先里面的类名。</li><li>jQuery里面的类操作只是对指定类进行操作，不影响原先的类名。</li></ul></li></ul></li><li><p>Jquery效果</p><ul><li>常见的动画效果：<ul><li>显示与隐藏：<code>show()</code> , <code>hide()</code> , <code>toggle()</code></li><li>滑动：<code>slideDown()</code> , <code>slideUp()</code> , <code>slideToggle()</code></li><li>淡入淡出：<code>fadeIn()</code> , <code>fadeOut()</code> , <code>fadeToggle()</code> , <code>fadeTo()</code></li><li>自定义动画：<code>animate()</code></li></ul></li><li>显示隐藏元素效果<ul><li>显示元素语法规范：<code>show([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li><li>隐藏元素：<code>hide([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li><li>切换元素：<code>toggle([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li><li>speed：三种预定速度之一的字符串（’slow’ , ‘noeral’ , ‘fast’ ）或表示动画时长的<code>毫秒数值</code>。</li><li>easing：（Optional）用来指定切换效果,默认是”swing”，可用参数“linear”。</li><li>fn：回调函数，在动画完成时执行的函数，每个元素执行一次。</li></ul></li><li>滑动效果：<ul><li>下滑：<code>slideDown([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li><li>上滑：<code>slideUp([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li><li>滑动切换：<code>slideToggle([speed],[easing],[fn])</code>，参数可以都省略，无动画直接显示</li></ul></li><li>事件切换：<ul><li><code>hover([over],out)</code></li><li>over：鼠标移动到元素上需要触发的<code>函数</code>(相当于mouseenter)</li><li>out: 鼠标移出元素需要触发的<code>函数</code> (相当于mouseleave)、<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//鼠标移动到元素上触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"鼠标移动到元素上"</span>);</span><br><span class="line">},<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//鼠标移出元素触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"鼠标移出元素"</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>如果只写一个函数，鼠标移动到元素上和鼠标移出元素都会触发这个函数</li></ul></li><li>动画队列及其停止排队的方法<ul><li>动画或效果队列：动画或者效果一旦触发就会执行，如果多次触发就会造成多个动画或者效果排队执行。</li><li>停止排队<code>stop() </code> 用于停止动画或效果。<code>注：</code>stop()写到动画或者效果的前面，相当于停止结束<code>上一次的动画</code>。</li></ul></li><li>淡入淡出效果<ul><li>淡入效果语法规范：<code>fadeIn([speed],[easing],[fn])</code> ,参数都可以省略</li><li>淡出效果：<code>fadeOut([speed],[easing],[fn])</code> ,参数都可以省略</li><li>切换效果：<code>fadeToggle([speed],[easing],[fn])</code> ,参数都可以省略</li><li>渐进方式调整到指定的不透明度<code>fandeTo([speed],opacity,[easing],[fn])</code>。其中<code>opacity</code>透明度为<code>必填项</code>，取值为0~1之间。有两个必须的参数。</li></ul></li><li>自定义动画animate<ul><li>语法：<code>animate(params,[speed],[easing],[fn])</code></li><li>params:想要更改的样式属性，以对象形式传递，<code>必须写</code>。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名方法borderLeft。其余参数都可以省略。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">   $(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  $(<span class="string">'div'</span>).animate({</span><br><span class="line">  <span class="attr">left</span>:<span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>:<span class="number">400</span>,</span><br><span class="line">  <span class="attr">opacity</span>:<span class="number">0.5</span></span><br><span class="line"> },<span class="number">1000</span>)</span><br><span class="line">  })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>Jquery属性操作</p><ul><li>设置或获取元素固有属性值<code>prop()</code>方法<ul><li>元素固有属性是指元素自带的属性，比如<code>&lt;a&gt;</code>标签自带href属性，<code>&lt;input&gt;</code> 自带type</li><li>获取属性值：<code>prop('属性')</code></li><li>设置属性值：<code>prop('属性','属性值')</code></li></ul></li><li>元素自定义属性的获取使用<code>attr()</code>方法<ul><li>获取属性值：<code>attr('属性')</code> ,类似于原生的getAttribute()</li><li>设置属性值：<code>attr('属性','属性值')</code>, 类似于原生的setAttribute()</li></ul></li><li>数据缓存<code>data()</code><ul><li>data()方法可以在指定的元素上存取数据，并不会修改DOM元素结构，一旦页面被刷新，之前存放的数据都将被移除。</li><li>附加数据：<code>data('数据名称','数据值')</code>，向被选元素附加属性</li><li>获取数据：<code>data('数据名称');</code>，向被选元素获取属性</li><li>这个方法获取<code>data-index</code> H5自定义属性,第一个不用写<code>data-</code> 。并且返回的是数字型的值。</li></ul></li><li>复选框被选中的<code>:checked</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($(<span class="string">'.checkbox:checked'</span>).length===$(<span class="string">'.checkbox'</span>).length){  <span class="comment">//如果选中个数等于复选框个数</span></span><br><span class="line">  $(<span class="string">'.checkall'</span>).prop(<span class="string">'checked'</span>,<span class="literal">true</span>);   <span class="comment">// 则全选按钮选中</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">   $(<span class="string">'.checkall'</span>).prop(<span class="string">'checked'</span>,<span class="literal">false</span>);  <span class="comment">//否则全选按钮不选中</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>jQuery内容文本值</p><ul><li>主要针对<code>元素的内容</code>和<code>表单的值</code>进行操作。</li><li>普通元素内容：<code>html（）</code>,相当于原生innerHTML<ul><li>获取元素内容：<code>html()</code></li><li>设置元素内容：<code>html('内容')</code></li></ul></li><li>普通元素文本内容<code>text()</code>，相当于原生innerText<ul><li>获取元素内容：<code>text()</code></li><li>设置元素内容：<code>text('内容')</code></li></ul></li><li>表单的值val()，相当于原生的value <ul><li>获取元素内容：<code>val()</code></li><li>设置元素内容：<code>val('内容')</code></li></ul></li><li><code>parents('选择器')</code>可以返回其祖先级元素，不价值可以返回所有的祖先元素</li><li>保留两位小数shiyong<code>toFixed(2)</code>方法</li></ul></li><li><p>jQuery元素操作</p><ul><li>主要是遍历、创建、添加、删除元素操作</li><li>遍历元素：jQuery隐式迭代是对同一元素做了相同的操作。如果想要给同一元素做不同的操作，就需要用到遍历。<ul><li>语法：<code>$('div').each(function(index,doEle){xxx;})</code></li><li>each()方法遍历匹配的每一个元素。主要用DOM处理，each每一个元素</li><li>里面回调函数有两个参数：index是每个元素的索引号；domEle是每个DOM对象，不是jQuery对象</li><li>所以想要使用jQuery方法。需要给这个DOM元素转换为jQuery对象<code>$(domEle)</code></li><li><code>$.each()</code>方法遍历元素，主要用于遍历数据，处理数据。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>,<span class="string">'pink'</span>];</span><br><span class="line">$.each(arr,<span class="function"><span class="keyword">function</span>(<span class="params">index,Ele</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(index);   <span class="comment">//输出索引号</span></span><br><span class="line">  <span class="built_in">console</span>.log(Ele);    <span class="comment">//输出元素</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>创建元素<ul><li>语法：<code>$("&lt;li&gt;&lt;/li&gt;");</code> 动态创建一个li标签</li></ul></li><li>添加元素<ul><li>内部添加：<code>Element.append("内容")</code>，把内容方到匹配元素内部的<code>后面</code>，类似于原生的appendChild。 <code>Element.prepend("内容")</code> ，把内容方到匹配元素内部的<code>前面</code>。</li><li>外部添加：<code>Element.after("内容")</code>, 把元素放到目标元素的后面。 <code>Element.before("内容")</code>，把元素放到目标元素的前面。</li><li><code>注：</code> 内部添加元素，生成之后它们是父子关系。外部添加元素，生成之后它们是兄弟关系。</li></ul></li><li>删除元素<ul><li><code>Element.remove()</code>,删除匹配到的元素本身</li><li><code>Element.empty()</code>，删除匹配到的元素集合中的所有子元素</li><li><code>Element.html()</code> ，清空匹配的元素内容里面的子节点</li></ul></li></ul></li><li><p>jQuery尺寸位置操作</p><ul><li>jQuery尺寸操作<table><thead><tr><th align="left">语法</th><th align="left">用法</th></tr></thead><tbody><tr><td align="left">width()/height()</td><td align="left">取得匹配元素宽度和高度的值 只算width/height</td></tr><tr><td align="left">innerWidth()/innerHeight()</td><td align="left">取得匹配元素宽度和高度的值 包含<code>padding</code></td></tr><tr><td align="left">outerWidth()/outerHeight()</td><td align="left">取得匹配元素宽度和高度的值 包含<code>padding，border</code></td></tr><tr><td align="left">outerWidth(true)/outerHeight(true)</td><td align="left">取得匹配元素宽度和高度的值 包含<code>padding,border,margin</code></td></tr></tbody></table><ul><li>以上参数为空，则是获取相应值，返回的是数字类型</li><li>如果参数为数字，则是修改相应值</li><li>参数不用加单位</li></ul></li><li>jQuery位置<ul><li>位置主要有三个：offset() , position() , scrollTop()/scrollLeft()</li><li>offset()设置或获取元素偏移。设置或返回被选元素相对于<code>文档</code>的偏移量，<code>跟父级没有关系</code>。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素偏移量</span></span><br><span class="line"> $(<span class="string">'div'</span>).offset();</span><br><span class="line"><span class="comment">//   设置文档偏移量使用  </span></span><br><span class="line"> $(<span class="string">'div'</span>).offset({<span class="attr">left</span>:<span class="number">100</span>,<span class="attr">top</span>:<span class="number">100</span>});</span><br></pre></td></tr></tbody></table></figure></li><li>position()获取元素偏移量。返回被选元素相对于<code>带有定位的父级</code>偏移坐标，如果父级都没有坐标则以文档为准。<code>z这个方法只能获取不能设置偏移</code></li><li>scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧</li><li>带有动画的返回顶部，使用animate动画函数里面的scrollTop属性，可以设置位置<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"body,html"</span>).animate({<span class="attr">scrollTop</span>:<span class="number">0</span>})</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>jQuery事件</p><ul><li>jQuery事件注册<br>  -单个事件注册：<code>$('div').click(function(){事件处理函数})</code></li><li>jQuery事件处理on()绑定事件<ul><li>on()方法在匹配元素上绑定一个或多个事件的事件处理函数。</li><li>语法：<code>element.on(events,[selector],fn)</code></li><li>events：一个或多个用空格分隔的事件类型，入’click’ ,或’keydowm’</li><li>selector:元素的子元素选择器</li><li><code>on()</code>方法优势：（1）可以绑定多个事件，多个处理事件处理函数；（2）可以实现事件委派操作，事件委派的定义是：把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。 （3）动态创建的元素，click()没有办法绑定事件，<code>on()</code>可以给动态生成的元素绑定事件。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).on({</span><br><span class="line">  <span class="attr">mouseover</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{},</span><br><span class="line">  <span class="attr">mouseout</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{},</span><br><span class="line">  <span class="attr">click</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{}</span><br><span class="line">})</span><br><span class="line"><span class="comment">//如果事件处理函数相同则</span></span><br><span class="line">$(<span class="string">'div'</span>).om(<span class="string">"mouseover mouseout"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{$(<span class="built_in">this</span>).toggleClass(<span class="string">"current"</span>)})</span><br><span class="line"><span class="comment">//事件委派,click是绑定在ul上面的，但是触发对象是ul里面的li</span></span><br><span class="line">$(<span class="string">'ul'</span>).on(<span class="string">'click'</span>,<span class="string">'li'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  alert(<span class="string">"hello world"</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>案例：发布微博案例<ul><li>运用动态添加元素生成列表</li><li>点击删除按钮使用<code>on()</code>方法可以给动态生成的元素绑定事件</li></ul></li><li>事件处理<code>off()</code>解绑事件<ul><li>off()方法可以移除通过on()方法添加的事件处理程序。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).off();    <span class="comment">//解除div身上发所有事件</span></span><br><span class="line">$(<span class="string">'div'</span>).off(<span class="string">'click'</span>);  <span class="comment">//解除div上的点击 事件</span></span><br><span class="line">$(<span class="string">'div'</span>).off(<span class="string">'click'</span>,<span class="string">'li'</span>);  <span class="comment">//解绑事件委托</span></span><br></pre></td></tr></tbody></table></figure></li><li>如果有的事件只想触发一次，可以使用one()来绑定事件。</li></ul></li><li>自动触发事件trigger()<ul><li>有些事件希望自动触发，比如轮播图自动播放功能跟点击左右侧按钮一致。可以利用定时器自动触发左右按钮点击事件，不必鼠标点击触发。</li><li><code>element.click()</code> ,简写方式</li><li><code>element.trigger("type")</code> ，第二种自动触发模式</li><li><code>element.triggerHandler(type)</code>,第三种默认触发模式，不会触发元素的<code>默认行为</code>~</li></ul></li><li>jQuery事件对象<ul><li>事件被触发就会有事件对象的产生。</li><li><code>element.on(events,[selector],function(event){})</code></li><li>阻止默认行为：event.preventDefault() 或者 return false</li><li>阻止冒泡：event.stopPropagation() </li></ul></li></ul></li><li><p>jQuery其他方法</p><ul><li>jQuery对象拷贝<ul><li>如果想要把某个对象拷贝（合并）给另一个对象使用，此时可以使用$.extebd()方法</li><li>语法：<code>$.extend([deep],target,object1,[objectN])</code></li><li>deep：如果设置为true为深拷贝，默认为false浅拷贝</li><li>target：要拷贝的目标对象</li><li>object1：待拷贝到第一个对象的对象</li><li>objectN：待拷贝到第N个对象的对象</li><li>浅拷贝：是把拷贝的对象<code>复杂数据类型中的地址</code>拷贝给目标对象，修改目标对象<code>会影响</code>拷贝对象。</li><li>深拷贝：完全克隆（拷贝的对象而不是地址），修改目标对象不会影响拷贝对象。把里面的数据完全复制一份给目标对象，如果里面有不冲突属性，会合并到一起。</li></ul></li><li>jQuery多库共存<ul><li>jQuery使用<code>$</code>作为标识符,其他js库也会使用到<code>$</code>作为标识符，这样一起使用会引起冲突。</li><li>需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。</li><li>jQuery解决方案：(1)把里面的<code>$</code>符号统一改为jQuery，比如<code>jQuery('div')</code>; (2)jQuery变量规定新的名称：<code>$.noConflict()  var xx=$.noConflict();</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果$符号冲突 可以使用jquery代替</span></span><br><span class="line">jQuery.each();</span><br><span class="line"><span class="comment">//让jQuery释放对$符号的控制权，让用户自己决定</span></span><br><span class="line"><span class="keyword">var</span> newname=jQuery.noConflict();</span><br><span class="line">newname(<span class="string">'div'</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>jQuery插件<ul><li>jQuery插件常用的网站：<a href="http://www.htmlleaf.com/">http://www.htmlleaf.com/</a>  </li><li>jQuery插件使用步骤：（1）引入相关文件；（2）复制相关html，css，js</li></ul></li><li>图片懒加载：当页面滑动到可视区域再加载图片</li><li>全屏滚动效果：<a href="http://www.dowebok.com/">http://www.dowebok.com/</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记07</title>
      <link href="/2022/03/27/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B007/"/>
      <url>/2022/03/27/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B007/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记07——PC端网页特效-移动端网页特效"><a href="#javascript学习笔记07——PC端网页特效-移动端网页特效" class="headerlink" title="javascript学习笔记07——PC端网页特效,移动端网页特效"></a>javascript学习笔记07——PC端网页特效,移动端网页特效</h1><h2 id="一、PC端网页特效"><a href="#一、PC端网页特效" class="headerlink" title="一、PC端网页特效"></a>一、PC端网页特效</h2><ol><li><p>元素偏移量offset系列</p><ul><li>oofset翻译过来就是偏移量，使用offset系列相关属性可以动态得到该元素的位置（偏移），大小等。<ul><li>获取元素距离带有定位父元素的位置</li><li>获取元素自身的大小（宽度和高度）</li><li><code>注：</code>返回的数值不带单位</li></ul></li><li>offset系列常用属性<table><thead><tr><th align="center">offset系列属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">element.offsetParent</td><td align="left">返回作用该元素带有定位的父级元素 如果父亲都没有定位则返回body</td></tr><tr><td align="center">element.offsetTop</td><td align="left">返回元素相对于<code>带有定位</code>父亲元素上方的偏移量,如果没有父元素或者父元素没有定位，则以body为准</td></tr><tr><td align="center">element.offsetLeft</td><td align="left">返回元素相对<code>带有定位</code>父元素左边框的偏移量,如果没有父元素或者父元素没有定位，则以body为准</td></tr><tr><td align="center">element.offsetWidth</td><td align="left">返回自身<code>包括padding、边框、内容区的宽度</code>，返回数值不带单位</td></tr><tr><td align="center">element.offsetHright</td><td align="left">返回自身<code>包括padding、边框、内容区的宽度</code>，返回内容不带单位</td></tr></tbody></table></li><li>offset与style区别<ul><li>offset:(1)可以获得任意样式表中的样式值；（2）获得数值没有单位；（3）offsetWidth包含padding+border+width；（4）offsetWidth等是只读属性，只能获取不能赋值。<code>想要获取元素大小位置，用offset合适</code>。</li><li>style：（1）只能得到行内样式表中的样式值；（2）style.width获得的是带有单位的字符串；（3）style.width获得不包含padding和border的值；（4）style.width等是可读写属性，可以获取也可以赋值；<code>想要给元素更改央视值，只能用style实现</code></li></ul></li></ul></li><li><p>元素可视区client系列</p><ul><li>client翻译是客户端，使用client系列的相关属性来获取元素可视区的相关信息，可以动态得到该元素的边框大小，元素大小等。<table><thead><tr><th align="center">client系列属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">element.clientTop</td><td align="left">返回元素上边框大小</td></tr><tr><td align="center">element.clientLeft</td><td align="left">返回元素左边框大小</td></tr><tr><td align="center">element.clientWidth</td><td align="left">返回自身包括padding、内容区的<code>宽度</code>、<code>不含边框</code>，返回数值不带单位</td></tr><tr><td align="center">element.clientHeight</td><td align="left">返回自身包括padding、内容区的<code>高度</code>、<code>不含边框</code>，返回数值不带单位</td></tr></tbody></table></li><li>立即执行函数<code>(function(){})()</code>,主要作用为创建一个独立的作用域。<ul><li>立即函数的特点：不需要调用，立马能够自己执行。</li><li>两种写法：<code>(function(){})()</code>  和 <code>(function(){}())</code></li><li>后面空的括号相当于调用函数，可以传参<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(num);  <span class="comment">// 函数立即执行，输出数值为22</span></span><br><span class="line">})(<span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure></li><li>立即函数最大的作用就是 独立创建了一个作用域。所有变量均为局部变量。</li></ul></li><li>以下三种情况都会刷新页面，都会触发load事件<ul><li>a标签的超链接</li><li>F5或者刷新按钮（强制刷新）</li><li>前进后退按钮</li><li><code>注：</code>在火狐浏览器中，有个”往返缓存”，这个缓存不仅保留了页面数据，还保留着JavaScript的状态；实际上是把整个页面都保存在了内存里。所以点击后退按钮将不再执行<code>load</code>刷新页面。所以需要pageshow事件。pageshow是给window添加的</li></ul></li></ul></li><li><p>元素滚动Scroll系列</p><ul><li>scroll翻译过来就是滚动的意思，使用scroll系列的相关属性可以动态的得到该<code>元素的大小</code>，<code>滚动距离</code>等。<table><thead><tr><th align="center">scroll系列属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">element.scrollTop</td><td align="left">返回被卷去的上侧距离，返回数值不带单位</td></tr><tr><td align="center">element.scrollLeft</td><td align="left">返回被卷去的左侧距离，返回数值不带单位</td></tr><tr><td align="center">element.scrollWidth</td><td align="left">返回<code>自身实际宽度</code> ，不含边框，返回数值不带单位</td></tr><tr><td align="center">element.scrollHeight</td><td align="left">返回<code>自身实际高度</code> ，不含边框，返回数值不带单位</td></tr></tbody></table></li><li>页面被卷去的头部<ul><li>如果浏览器的高度（宽度）不足以显示整个页面时，会自动出现滚动条。当滚动条向上滚动时，页面上面被隐藏的高度，就称之为<code>被卷上去的头部</code>。滚动条在滚动时触发onscroll事件。</li><li><code>页面滚动距离</code>：新方法window.pageYoffset和window.pageXOffset,从IE9开始支持。</li><li>声明DTD，使用document.documentElement.scrollTop</li><li>未声明TDT，使用document.body.scrollTop</li></ul></li></ul></li><li><p>mouseenter和mouseover的区别</p><ul><li>mouseenter鼠标事件：当鼠标移动到元素上时就会触发<code>mouseenter事件</code></li><li><code>mouseover</code>鼠标经过自身盒子会触发，经过子盒子还会触发，<code>mouseenter</code>只有经过自身盒子才会触发。mouseenter不会冒泡</li></ul></li><li><p>动画函数封装。</p><ul><li>动画实现原理：通过定时器setInterval() 不断移动盒子位置</li><li>实现步骤：<ul><li>获取盒子当前位置；</li><li>让盒子在当前位置加上一个移动距离；</li><li>利用定时器不断重复这个操作；</li><li>加上一个结束定时器的条件；</li><li><code>注：</code>一定要给元素添加定位，才能使用element.style.left</li></ul></li><li>动画函数简单封装<ul><li>注意：动画函数需要传递2个参数，动画对象和移动到的距离。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj目标对象，target目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj,target</span>)</span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>动画函数给不同的元素记录不同的定时器：<code>核心原理</code>是利用JS 是一门动态语言，可以很方便的为当前对象添加属性。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj目标对象，target目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj,target</span>)</span>{</span><br><span class="line">   <span class="built_in">clearInterval</span>(obj.timer);  <span class="comment">//防止重复调用产生多个计时器。</span></span><br><span class="line">   obj.timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">if</span>(obj.offsetLeft&gt;=target)</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">    }</span><br><span class="line">    obj.style.left=obj.offsetLeft+<span class="number">1</span>+<span class="string">'px'</span>;</span><br><span class="line">  },<span class="number">30</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line">animate(div,<span class="number">300</span>);  <span class="comment">//调用函数</span></span><br></pre></td></tr></tbody></table></figure></li><li>缓动效果原理：缓动动画就是让元素运动的速度有所变化，常见的就是让速度慢慢的降下来。  （1）让盒子每次移动的距离慢慢变下，速度就会慢慢降下来。（2）<code>核心算法:</code>（目标值-现在位置）/10作为每次移动的距离步长。（3）<code>停止的条件:</code>让当前盒子位置等于目标位置就停止计时器。  <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//obj目标对象，target目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target</span>) </span>{</span><br><span class="line"> <span class="built_in">clearInterval</span>(obj.timer); <span class="comment">//防止重复调用产生多个计时器。</span></span><br><span class="line"> obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> step=(target-obj.offsetLeft)/<span class="number">10</span>;</span><br><span class="line">   step=step&gt;<span class="number">0</span>? <span class="built_in">Math</span>.ceil(step):<span class="built_in">Math</span>.floor(step);  <span class="comment">//是正数则往上取整，负数则往下取整</span></span><br><span class="line"><span class="keyword">if</span> (obj.offsetLeft == target) {</span><br><span class="line"> <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">}</span><br><span class="line"> obj.style.left = obj.offsetLeft + step + <span class="string">'px'</span>;</span><br><span class="line">}, <span class="number">30</span>)</span><br><span class="line"> }</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line">    animate(div, <span class="number">300</span>); <span class="comment">//调用函数</span></span><br></pre></td></tr></tbody></table></figure></li><li>动画函数添加回调函数</li><li><code>回调函数原理：</code>函数可以作为一个参数。将这个函数作为参数传递到另一个函数里面，当那个函数执行完成之后，再执行传进去的这个函数。这就是回调函数。</li><li>回调函数写的位置：计时器结束的位置。</li></ul></li><li>轮播图效果的实现<ul><li>实现轮播图滚动可以使用封装好的animate函数</li><li>到最后一张图片时切换到第一张的方法是：先利用克隆节点方法<code>cloneNode(true)</code>对第一张图进行克隆。当轮播图播放时，检测图片现在播放到第几张，若图片已经到最后一张，则下一张播放克隆图片，然后将真个<code>ul</code>的定位设置为<code>left=0</code>跳回真正的第一张图片的位置。</li><li>左右点击与底部小圆点的数值绑定</li></ul></li></ul></li><li><p><code>节流阀</code></p><ul><li>问题：轮播图按钮连续点击造成图片播放过快。</li><li>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个动画，让事件无法连续触发。</li><li><code>核心实现思路：</code>利用<code>回调函数</code>添加一个变量控制，锁住函数和解锁函数。</li></ul></li><li><p>返回页面顶部</p><ul><li>滚动窗口到文档中的特定位置<code>window.scroll(x,y)</code>,直接到指定位置。</li><li>带有动画的返回顶部，使用封装的动画函数。</li><li>页面滚动了多少可以通过window.pageYOffset`得到。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">obj, target, callback</span>) </span>{</span><br><span class="line">  <span class="built_in">clearInterval</span>(obj.timer); <span class="comment">//防止重复调用产生多个计时器。</span></span><br><span class="line">  obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">   <span class="keyword">var</span> step = (target - <span class="built_in">window</span>.pageYOffset) / <span class="number">10</span>;</span><br><span class="line">   step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">window</span>.pageYOffset == target) {</span><br><span class="line">  <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">  <span class="comment">// if(callback){</span></span><br><span class="line">  <span class="comment">// callback();</span></span><br><span class="line">  <span class="comment">// }或者</span></span><br><span class="line">   callback &amp;&amp; callback()</span><br><span class="line"> }</span><br><span class="line"> <span class="built_in">window</span>.scroll(<span class="number">0</span>,<span class="built_in">window</span>.pageYOffset+step)</span><br><span class="line">}, <span class="number">15</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二、移动端网页特效"><a href="#二、移动端网页特效" class="headerlink" title="二、移动端网页特效"></a>二、移动端网页特效</h2></li></ul></li><li><p>触屏事件</p><ul><li>移动端浏览器的兼容性较好可以放心使用原生JS书写效果，移动端具有自己独特的地方，<code>触屏事件touch</code>(也称为触摸事件)。</li><li>touch对象代表一个触摸点。触屏事件可响应用户手指对屏幕的操作。</li><li>常见的触屏事件：<table><thead><tr><th align="center">触屏touch事件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">touchstart</td><td align="left">手指触摸到一个DOM元素时触发</td></tr><tr><td align="center">touchmove</td><td align="left">手指在一个DOM元素上滑动时触发</td></tr><tr><td align="center">touchend</td><td align="left">手指在一个DOM元素上移开时触发</td></tr></tbody></table></li></ul></li><li><p>触摸事件对象（TouchEvent）</p><ul><li><code>TouchEvent</code> 是一类描述手指在触摸平面（触摸屏，触摸板）等的状态变化的事件。这类事件用于描述一个或多个触点。使开发者可以检测触点的移动，触点的增加和减少。</li><li>touchstart , touchmove , touchend 三个事件都会各自有事件对象。 </li><li>触摸事件对象三个常见的对象列表<table><thead><tr><th align="center">触摸列表</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">touches</td><td align="left">正在触摸屏幕的所有手指的一个列表</td></tr><tr><td align="center">targetTouches</td><td align="left">正在触摸当前DOM元素上的手指的一个列表</td></tr><tr><td align="center">changedTouches</td><td align="left">手指状态发生了改变的列表，从无到有，从有到无的变化</td></tr></tbody></table></li><li>移动端拖动元素<ul><li>touchstart , touchmove , touchend可以实现拖动元素</li><li>拖动元素需要当前手指的坐标值，targetTouch[0]里面的<code>pageX</code>和<code>pageY</code></li><li>原理：手指移动中，计算出手指移动的距离。然后用盒子原来的位置+手指移动的距离。</li><li>手指移动的距离：手指滑动中的位置减去 手指刚开始触摸的位置。</li><li><code>注: </code>手指移动也会触发默认的滚动屏幕，所以这里要阻止默认的屏幕滚动<code>e.preventDefault()</code></li></ul></li></ul></li><li><p>移动端常见的特效</p><ul><li>轮播图案例：<ul><li><code>自动播放</code>：开启定时器，移动端移动可以使用<code>translate</code>移动，添加过渡效果</li><li><code>无缝滚动</code>：添加检测过渡完成事件<code>transitionend</code>，判断条件，如果索引号等于3说明走到最后一张图片，此时索引号要复原为0。此时图片去掉过渡，然后移动到第一张 </li><li><code>小圆点跟随效果：</code>（1）把ol里面li带有current类名的选出来去掉类名；（2）让当前索引号的li加上current；（3）但是，是等着过渡结束之后变化，所以这个写道transitionend事件里面。</li><li><code>手指滑动轮播图：</code>本质就是ul跟随手指移动，简单说就是移动端拖动元素。(1)触摸元素touchstart，获取手指初始坐标。（2）移动手指touchmove计算手指的滑动距离并且移动盒子。（3）手指离开touchend 根据滑动距离区分不同情况。（4）如果移动小于某个距离就回弹，如果拖动具体大于某个值就上一张或者下一张滑动。</li></ul></li><li>classList属性<ul><li>classList属性是HTML5新增的属性，返回元素的类名，IE10以上支持。</li><li>该属性用于在元素中添加，移除及切除CSS类</li><li>添加类名：<code>element.classList.add('类名')</code> 是在后面追加类名，不会覆盖已知类名</li><li>移除类：<code>element.classList.remove('类名')</code> 移除指定类名</li><li>切换类：<code>element.classList.toggle('类名')</code>  如果元素存在这个类则删除，如果没有这个类则添加。</li></ul></li><li><code>click</code>点击延时解决方案<ul><li>移动端click事件会有300ms的延时原因是移动端屏幕双击会缩放（double tap to zoom）页面。</li><li>解决方法1：（1）禁止缩放。浏览器禁止默认的双击缩放行为，并且去掉300ms的点击延迟。 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mate name=<span class="string">"viewport"</span> content=<span class="string">"user-scalable=no"</span>&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>解决方法2 ：利用touch事件自己封装这个事件,原理是，当我们手指触摸屏幕，记录当前触摸时间，当我们手指离开屏幕，用离开的时间减去触摸的时间。如果小于150ms并且没有滑动过屏幕，那我们就定义为点击. <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//解决移动端点击有300ms延时</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">obj,callback</span>)</span></span><br><span class="line"><span class="function">   </span>{</span><br><span class="line"><span class="keyword">var</span> isMove=<span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">var</span> startTime=<span class="number">0</span>;   <span class="comment">//记录触摸时候的时间变化</span></span><br><span class="line">  obj.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{</span><br><span class="line"> startTime=<span class="built_in">Date</span>.now();  <span class="comment">//记录触摸开始时间</span></span><br><span class="line">   })</span><br><span class="line"> obj.addEventListener(<span class="string">'touchmove'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{</span><br><span class="line">     isMove=<span class="literal">true</span>; <span class="comment">//判断是否有触摸滑动，若有滑动则不算点击</span></span><br><span class="line">  })</span><br><span class="line"> obj.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{</span><br><span class="line"><span class="keyword">if</span>(!isMove&amp;&amp;(<span class="built_in">Date</span>.now()-startTime)&lt;<span class="number">150</span>){  <span class="comment">//如果手触摸的时间（即触摸结束减去触摸开始）小于150ms算点击</span></span><br><span class="line"> callback&amp;&amp;callback();  <span class="comment">//回调函数</span></span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line">isMove=<span class="literal">false</span>;</span><br><span class="line"> startTime=<span class="number">0</span>;  <span class="comment">//重置</span></span><br><span class="line">  </span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"> <span class="comment">//调用</span></span><br><span class="line">   <span class="comment">//  tap(div,function(){回调函数})</span></span><br><span class="line">  tap(div,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{alert(<span class="string">"111"</span>)})</span><br></pre></td></tr></tbody></table></figure></li><li>解决方法3:fastclick插件解决300ms延时</li></ul></li></ul></li><li><p>移动端常用开发插件</p><ul><li>JS插件就是JS文件,它遵循一定的开发规范,方便程序展示效果,拥有特定功能且方便调用。</li><li>特点:一般为了解决某个问题而专门存在,其功能单一并且比较小。</li><li><code>Swiper官网</code>: <a href="https://3.swiper.com.cn/">https://3.swiper.com.cn/</a></li><li>移动端视频插件 zy.media.js 实现在不同浏览器上视频播放的效果统一</li></ul></li><li><p>移动端常用的开发框架</p><ul><li>框架：顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架规定的某种规范进行开发。</li><li>前端框架有<code>Bootstrap</code> , <code>Vue </code>, <code>Angular</code> , <code>React</code>等。既能开发Pc端也能开发移动端。</li><li>框架：大而全，一整套解决方案</li><li>插件：小而单一，某个功能的解决方案</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> js样例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记06</title>
      <link href="/2022/03/25/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B006/"/>
      <url>/2022/03/25/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B006/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——事件高级-BOM浏览器对象模型"><a href="#javascript学习笔记——事件高级-BOM浏览器对象模型" class="headerlink" title="javascript学习笔记——事件高级,BOM浏览器对象模型"></a>javascript学习笔记——事件高级,BOM浏览器对象模型</h1><ul><li>注册事件（绑定事件）</li><li>删除事件（解绑事件）</li><li>DOM事件流</li><li>事件对象</li><li>阻止事件冒泡</li><li>事件委托（代理，委派）</li><li>常用的鼠标事件</li><li>常用键盘事件</li></ul><h2 id="一、事件高级"><a href="#一、事件高级" class="headerlink" title="一、事件高级"></a>一、事件高级</h2><ol><li><p>注册事件（绑定事件）：给元素添加事件</p><ul><li>注册事件的两种方式：<code>传统方式</code> , <code>方法监听注册方式</code></li><li>传统方式：<ul><li>以on开头的事件，如onclick</li><li><code>特点:</code> 注册事件的唯一性</li><li>同一个元素，同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数。</li></ul></li><li>方法监听注册方式：<ul><li><code>addEventListener()</code> 是一个方法 。</li><li>IE9之前的IE浏览器不支持，可以使用<code>attachEvent()</code>代替</li><li><code>特点：</code>同一个元素，同一个事件可以注册多个监听器</li><li>按照注册顺序依次执行</li><li><code>eventTarget.addEventListener(type,listener,useCapture)</code> 将指定的监听器注册到eventTatget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</li><li><code>type:</code> 事件类型字符串，比如click,mouseover等。</li><li><code>listener:</code> 事件处理函数，事件发生时会调用该函数。</li><li><code>useCapture:</code> 可选参数，是一个布尔值，默认为false。</li><li><code>eventTarget.attachEvent(eventNameWithOn,callBack)</code>将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，指定回调函数就会被执行。（作为了解）</li><li><code>eventNameWithOn</code> 事件类型字符串，比如click,mouseover等</li><li><code>callback</code> 事件处理函数，当目标触发事件时回调函数被调用。</li></ul></li></ul></li><li><p>删除事件</p><ul><li>传统注册事件的删除事件：<ul><li>eventTarget.onclick=null;</li></ul></li><li>方法监听注册方式<ul><li>eventTarget.removeEventListener(type,listener,useCapture)</li><li>eventTarget.detachEvent(eventNameWithOn,callBack)</li></ul></li></ul></li><li><p>DOM事件流</p><ul><li><p>事件流是描述从页面中接收事件的顺序，事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程叫做DOM事件流。</p></li><li><p>DOM事件流分为三个阶段：</p><ul><li>捕捉阶段</li><li>当前目标阶段</li><li>冒泡阶段</li></ul><p>   <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2FDOM.png" alt="DOM事件流分为三个阶段"></p><ul><li>事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。</li><li>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程。</li><li><code>注：</code>(1)JS代码中只能执行捕获或者冒泡其中的一个阶段; (2)<code>onclick</code>和<code>attachEvent</code>只能得到冒泡阶段。 (3)<code>eventTarget.addEventListener(type,listener,useCapture)</code>第三个参数如果是true表示在事件捕捉阶段调用事件处理函数，如果是false（默认），表示在事件冒泡阶段调用事件处理函数。<code>实际开发中更加关注冒泡，事件捕获很少关注。有些事件没有冒泡，比如：onblur,onfocus,onmouseenter,onmouseleae</code></li></ul></li></ul></li><li><p>事件对象</p><ul><li>event就是一个事件对象，写在监听函数的小阔号中，当形参来看。</li><li>事件对象只有有了事件才会存在。它是系统给我们自动创建的。不需要我们传递参数。</li><li>事件对象是事件的一系列相关数据的集合，跟事件相关，如果是鼠标事件，就包含了鼠标的相关信息，比如鼠标坐标等。</li><li>这个事件对象可以自己命名：event， evt , e 等</li><li><code>兼容性问题：</code> 对于IE6,7,8 只有通过window.event获取。<code>e=e||window.event</code>兼容性写法</li><li>事件对象常见的属性和方法<table><thead><tr><th align="center">事件对象属性方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">e.target</td><td align="left">返回触发事件的对象 (标准)</td></tr><tr><td align="center">e.srcElement</td><td align="left">返回触发事件的对象  （非标准 IE6,7,8使用）</td></tr><tr><td align="center">e.type</td><td align="left">返回事件类型 比如click,mouseover等</td></tr><tr><td align="center">e.cancelBUbble</td><td align="left">该属性阻止冒泡   （非标准 IE6,7,8使用）</td></tr><tr><td align="center">e.returnValue</td><td align="left">该属性阻止默认事件（默认行为），比如不让连接跳转（非标准 IE6,7,8使用）</td></tr><tr><td align="center">e.preventDefault()</td><td align="left">该属性阻止默认事件（默认行为），比如不让连接跳转  标准</td></tr><tr><td align="center">e.stopPropagation()</td><td align="left">阻止冒泡  标准</td></tr></tbody></table></li></ul></li><li><p>阻止事件冒泡</p><ul><li>事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点。</li><li><code>e.stopPropagation()</code> 标准写法</li><li><code>e.cancelBUbble=true;</code>  非标准 IE6,7,8使用</li></ul></li><li><p>事件委托（代理，委派）</p><ul><li>事件委托也称为事件代理，在jQuery里面称为事件委派。</li><li><code>事件委托的原理*</code>:不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个节点。</li></ul></li><li><p>鼠标事件</p><ul><li>常用的鼠标事件：<ul><li>禁止鼠标右键菜单:<code>contextmenu</code>主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'contextmenu'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{</span><br><span class="line">  e.preventDefault();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li>禁止鼠标选中（selectstart 开始选中） <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'selectstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{</span><br><span class="line">  e.preventDefault();</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>鼠标事件对象<ul><li><code>event</code>对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要使用鼠标事件对象<code>MouseEvent</code>和键盘事件对象<code>KeyboardEvent</code><table><thead><tr><th align="center">鼠标事件对象</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">e.clientX</td><td align="left">返回鼠标相对于<code>浏览器窗口可视区</code>的<code>X</code>坐标</td></tr><tr><td align="center">e.clientY</td><td align="left">返回鼠标相对于<code>浏览器窗口可视区</code>的<code>Y</code>坐标</td></tr><tr><td align="center">e.pageX</td><td align="left">返回鼠标相对于<code>文档页面</code>的<code>X</code>坐标 IE9+z支持</td></tr><tr><td align="center">e.pageY</td><td align="left">返回鼠标相对于<code>文档页面</code>的<code>Y</code>坐标 IE9+z支持</td></tr><tr><td align="center">e.screeX</td><td align="left">返回鼠标相对于<code>电脑屏幕</code>的<code>X</code>坐标</td></tr><tr><td align="center">e.screeY</td><td align="left">返回鼠标相对于<code>电脑屏幕</code>的<code>Y</code>坐标</td></tr></tbody></table></li></ul></li></ul></li><li><p>键盘事件</p><ul><li>常用的键盘事件<table><thead><tr><th align="center">键盘事件</th><th align="left">触发条件</th></tr></thead><tbody><tr><td align="center">onkeyuo</td><td align="left">某个键盘案件被松开时触发</td></tr><tr><td align="center">onkeydown</td><td align="left">某个键盘按键被按下时触发</td></tr><tr><td align="center">onkeypress</td><td align="left">某个键盘按键被按下时触发 <code>但它不识别功能键 比如ctrl shift箭头等</code></td></tr><tr><td align="center"></td><td align="left"></td></tr></tbody></table><ul><li>三个事件的执行顺序 keydown-&gt; keypress-&gt; keyup</li></ul></li><li>键盘事件对象<table><thead><tr><th align="center">键盘事件对象 （属性）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">keyCode</td><td align="left">返回该键的ASCLL码值</td></tr></tbody></table><ul><li><code>keyup</code>和<code>keydowm</code>通过keyCdoe获取按键的ASCALL码值时是不区分大小写的（a和A都是得到65），只有<code>keypress</code>才区分大小写。</li><li><code>keypress</code>和<code>keydown</code> 在文本框里面的特点：它们两个事件触发的时候，文字还没有落入到文本框中。</li><li><code>keyup</code> 事件触发的时候，文字已经落入到文本框中</li></ul></li></ul></li></ol><h2 id="二、BOM浏览器对象模型"><a href="#二、BOM浏览器对象模型" class="headerlink" title="二、BOM浏览器对象模型"></a>二、BOM浏览器对象模型</h2><ol><li>BOM是浏览器对象模型，它提供了独立于  内容而与<code>浏览器窗口进行交互</code>的对象，其核心对象是window<ul><li>浏览器对象模型</li><li>把<code>浏览器</code>当作一个<code>对象</code>来看待</li><li>BOM的顶级对象是<code>window</code></li><li>BOM学习的是浏览器窗口交互的一些对象</li><li>BOM是浏览器厂商在各浏览器上定义的，兼容性差。</li></ul></li><li>BOM构成<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2Fbom9.png" alt="BOM的构成"><ul><li>是JS访问浏览器窗口的一个接口</li><li>是一个全局对象，定义在全局作用域中的一个变量、函数 都会变成window对象的属性和方法 。在调用的时候可以省略window</li></ul></li><li>window对象常见的事件<ul><li>窗口加载事件：当文档内容完全加载完成之后会触发该事件（包括图像，脚本文件，CSS 文件等），就调用的处理函数。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{})</span><br></pre></td></tr></tbody></table></figure><ul><li>使用  window.onload 传统方法只能注册一次，若多次注册则以最后一个为准</li><li>使用   window.addEventListener(‘load’,function(){}) 则没有次数限制，可以注册多个事件。</li><li><code>DOMcontentLoaded</code> 事件触发时，仅当DOM加载完成，不包含样式表，图片，flash等等。（IE9+支持）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMcontentLoaded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{})</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>调整窗口大小事件<ul><li><code>window.onresize</code> 是调整窗口大小加载事件，当触发时就调用处理函数。</li><li>只要窗口像素变化就会触发这个事件。</li><li>经常利用这个事件来完成响应式布局，window.innerWidth当前屏幕的宽度。</li></ul></li></ul></li><li>定时器<ul><li>两种定时器：页面中可能存在多个计时器，通常会给计时器添加标志符来区别不同定时器。<ul><li><code>setTimeout()</code>  定时器，隔多少时间后调用里面的函数。只调用一次。</li><li><code>setInterval() </code> 每隔这个延迟时间，就调用一次这个回调函数。重复调用。</li></ul></li><li><code>setTimeout()</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.setTimeout(<span class="string">'调用函数'</span>,[延迟的毫秒数]);  <span class="comment">//[]可以省略</span></span><br></pre></td></tr></tbody></table></figure><ul><li>回调函数</li><li>停止setTimeout()计时器使用<code>window.clearTimeout(timeoutID)</code><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击停止倒计时<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> timer=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"倒计时结束"</span>);</span></span><br><span class="line"><span class="javascript"> },<span class="number">5000</span>);</span></span><br><span class="line"><span class="javascript"> btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript"><span class="built_in">clearTimeout</span>(<span class="string">'timer'</span>);</span></span><br><span class="line"><span class="javascript"> <span class="built_in">console</span>.log(<span class="string">"倒计时停止！"</span>)</span></span><br><span class="line"><span class="javascript"> })</span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><code>setInterval() </code><ul><li>每隔设定的时间就会调用这个函数，可以用来做倒计时</li><li>用于做倒计时时会遇到刷新页面时没有时间显示，因为这个函数设置会在1秒后调用函数，因此我们可以在这个回调函数之前先调用一次时间显示函数，避免了刷新显示空白。</li><li>停止setInterval()定时器使用<code>clearInterval()</code>方法。参数为定时器的标识符。</li></ul></li><li><code>this *</code><ul><li>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</li><li>在<code>全局作用域</code>或者<code>普通函数</code>中this指向全局对象window。（定时器里面的this指向window）</li><li><code>方法调用中</code>谁调用this指向谁。</li><li><code>构造函数中</code>this指向构造函数的实例。</li></ul></li></ul></li><li>JS执行机制<ul><li>js是<code>单线程</code>的：JavaScript语言的一大特点是单线程，也就是说<code>同一个时间只能做一件事</code>。<ul><li>单线程意味着所有任务均需要排队，前一个任务结束后才会执行后一个任务。这样可能会导致若JS执行时间过长，会造成页面渲染不连贯，页面渲染加载产生阻塞的感觉。</li></ul></li><li><code>同步</code>和<code>异步</code><ul><li>为例解决页面加载阻塞的问题，利用多核CPU的计算能力，<code>HTML5</code>提出Web Worker标准，允许JavaScript脚本创建多线程，这样JS中就出现了<code>同步</code>和<code>异步</code>。</li><li>同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</li><li>异步：在做一件事时，因为这个事情比较花时间，所以在做这件事的同时可以去处理其他任务。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">},<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);    <span class="comment">//执行打印结果为  1,2,3; 属于异步执行。</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>同步任务：同步任务都是在主线程上执行，形成一个<code>执行栈</code></li><li>异步任务：JS的异步是通过回调函数实现的。一般而言，异步任务有如下三种类型<ul><li>普通事件：如<code>click , resize </code>等</li><li>资源加载：如<code>load , error</code>等</li><li>定时器：包括<code>setInerval , setTimeout</code>等</li></ul></li><li>JS执行机制<ul><li>先执行<code>执行栈中的同步任务</code></li><li>异步任务（回调函数）放在任务队列中。</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈开始执行。</li><li><code>事件循环(even loop)</code> 由于主线程不断地重复获得任务、执行任务、再获取任务、再执行。</li></ul></li></ul></li><li>location对象<ul><li>window对象提供了一个<code>location属性</code>用于<code>获取或设置窗体的URL</code>，并且可以用于解析URL。因为这个属性返回的是一个对象，所以我们将这个属性称为location对象。</li><li><code>URL</code>：统一资源定位符（Uniform Resource locator）是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<ul><li>URL的一般语法格式为<code>protocol://host[:port]/path/[?query]#fragment</code> 例如:<code>http://www.itcast.cn/index.html?name=andy&amp;age=19#link</code><table><thead><tr><th align="center">组成</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">protocol</td><td align="left">通信协议，通常的http, ftp, maito等</td></tr><tr><td align="center">host</td><td align="left">主机（域名）</td></tr><tr><td align="center">port</td><td align="left">端口号 （可选），省略时使用方案的默认端口号，如http默认端口号为80</td></tr><tr><td align="center">path</td><td align="left"><code>路径</code>由 零或多个’/‘符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td></tr><tr><td align="center">query</td><td align="left">参数 以键值对的形式，通过<code>&amp;</code>符号分隔开</td></tr><tr><td align="center">fragment</td><td align="left">片段 <code>#</code>后面的内容常见于链接，锚点</td></tr></tbody></table></li></ul></li><li>location对象的属性<table><thead><tr><th align="center">location对象属性</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="center"><code>location.href</code></td><td align="left">获取或者设置整个URL</td></tr><tr><td align="center">location.host</td><td align="left">返回主机（域名）</td></tr><tr><td align="center">location.port</td><td align="left">返回端口号 如果未写返回空字符串</td></tr><tr><td align="center">location.pathname</td><td align="left">返回路径</td></tr><tr><td align="center"><code>location.search</code></td><td align="left">返回参数</td></tr><tr><td align="center">location.hash</td><td align="left">返回片段 <code>#</code>后面的内容常见于链接、锚点</td></tr></tbody></table></li><li>location对象中的方法<table><thead><tr><th align="center">location对象方法</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="center">location.assign()</td><td align="left">跟href一样也可以跳转页面（也称为重定向页面）记录历史可以后退页面</td></tr><tr><td align="center">location.replace()</td><td align="left">替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td align="center">location.reload()</td><td align="left">重新加载页面，相当于刷新按钮或者F5 如果参数为<code>true</code>则强制刷新，相当于ctrl+F5</td></tr></tbody></table></li><li>navigator对象<ul><li>navigator包含有关浏览器的信息，它有很多属性，常用的是<code>userAgent</code>，该属性可以返回由客户机发送服务器的user-agent头部值。</li><li>用于PC端和移动端的页面切换</li></ul></li><li>history对象<ul><li>window对象给我们提供history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL<table><thead><tr><th align="center">history对象方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">back()</td><td align="left">可以后退功能</td></tr><tr><td align="center">forward()</td><td align="left">前进功能</td></tr><tr><td align="center">go(参数)</td><td align="left">前进后退功能 参数如果是1 则前进一个界面，参数如果是-1则后退一个界面</td></tr></tbody></table></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> BOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记05</title>
      <link href="/2022/03/25/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B005/"/>
      <url>/2022/03/25/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——Web-APIs，DOM"><a href="#javascript学习笔记——Web-APIs，DOM" class="headerlink" title="javascript学习笔记——Web APIs，DOM"></a>javascript学习笔记——Web APIs，DOM</h1><h2 id="一、Web-APIs"><a href="#一、Web-APIs" class="headerlink" title="一、Web APIs"></a>一、Web APIs</h2><ol><li>Web APIs包含DOM(页面文档对象模型)，BOM(浏览器对象模型)。</li><li>JS基础学习ECMAScript 基础语法为后面做铺垫，Web APIs是JS的应用，大量使用JS基础语法做交互效果。</li><li>API 和 Web API<ul><li>API 是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</li><li>Web API 是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）;</li></ul></li></ol><h2 id="二、DOM"><a href="#二、DOM" class="headerlink" title="二、DOM"></a>二、DOM</h2><ol><li><p>DOM(文本对象流模型)，是W3C组织推荐的处理可扩展标记语言（HTML或XML）的标准编程接口。</p></li><li><p>DOM树</p><ul><li>文档：一个页面就是一个文档，DOM中使用<code>document</code>表示</li><li>元素：页面中所有标签都是元素，DOM中使用<code>element</code>表示</li><li>节点：网页中所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2FDOM3.png" alt="DOM树"> </li></ul></li><li><p>获取元素</p><ul><li><p>获取页面中元素可以使用以下方法</p><ul><li>根据ID获取</li><li>根据标签名获取</li><li>通过HTML5新增的方法获取</li><li>特殊元素获取</li></ul></li><li><p>通过ID获取</p><ul><li>使用<code>getElementById()</code>方法可以获取带有ID的元素对象</li><li>因为文档页面从上往下加载，所以先得有标签，script写在标签的下面</li><li>返回一个匹配到ID的Element对象，若在当前document中没有找到则返回null</li><li><code>console.dir()</code> 打印我们返回的元素对象，更好的查看里面的属性和方法</li></ul></li><li><p>根据标签名获取元素</p><ul><li><code>document.getElementByTagName()</code>,返回的是 获取过来元素对象的集合 以伪数组的形式存储的。</li><li>想要依次打印里面的元素对象可以采用遍历的形式。</li><li>如果页面中没有这个元素，则返回的是空的伪数组</li><li>还可以获取某个元素（父元素）内部所有指定标签名的子元素。<code>注：</code>父元素必须是单个对象。<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">"ol"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> ol=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'ol'</span>);</span></span><br><span class="line"><span class="javascript"> <span class="built_in">console</span>.log(ol[<span class="number">0</span>].getElementsByTagName(<span class="string">'li'</span>));</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          <span class="comment">//或者</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">//var ol=document.getElementById('ol');</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">//console.log(ol.getElementByTagName('li'));</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>通过HTML5新增方法获取</p><ul><li><code>document.getElementByClassName('类名');</code>  //根据类名返回元素对象集合  </li><li><code>document.querySelector('选择器');</code>  //根据指定选择器返回第一个元素对象<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>第一个盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>第二个盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> box=<span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);  <span class="comment">//返回第一个盒子</span></span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> nav=<span class="built_in">document</span>.querySelector(<span class="string">'#nav'</span>);  <span class="comment">//</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><code>document.querySelectorAll('选择器');</code>  //根据指定选择器返回所有对象</li></ul></li><li><p>获取特殊元素body ,html</p><ul><li>获取<code>body</code>元素<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyEle=<span class="built_in">document</span>.body;</span><br></pre></td></tr></tbody></table></figure></li><li>获取<code>html</code>元素<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> htmlEle=<span class="built_in">document</span>.documentElement;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>事件基础</p><ul><li>事件：触发响应的机制，网页中每个元素都可以触发JavaScript的事件，例如用户在点击某个按钮时产生的事件。然后去执行操作</li><li>事件是有三部分组成：<code>事件源</code>，<code>事件类型</code>，<code>事件处理程序</code>。<ul><li>事件源：事件被触发的对象</li><li>事件类型：如何触发，什么事件。比如鼠标点击触发，鼠标经过触发等。</li><li>事件处理程序：通过一个函数赋值的方式 完成</li></ul></li><li>执行事件的步骤<ul><li>获取事件源 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br></pre></td></tr></tbody></table></figure></li><li>绑定事件（注册事件） <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.onclick</span><br></pre></td></tr></tbody></table></figure></li><li>添加事件处理程序 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    alert(<span class="string">"点击此事件"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>常见的鼠标事件<ul><li>表格<table><thead><tr><th align="center">鼠标事件</th><th align="left">触发条件</th></tr></thead><tbody><tr><td align="center">onclick</td><td align="left">鼠标点击左键触发</td></tr><tr><td align="center">onmouseover</td><td align="left">鼠标经过触发</td></tr><tr><td align="center">onmouseout</td><td align="left">鼠标离开触发</td></tr><tr><td align="center">onfocus</td><td align="left">获取鼠标焦点触发</td></tr><tr><td align="center">onblur</td><td align="left">失去鼠标焦点触发</td></tr><tr><td align="center">onmousemove</td><td align="left">鼠标移动触发</td></tr><tr><td align="center">onmouseup</td><td align="left">鼠标弹起触发</td></tr><tr><td align="center">onmousedown</td><td align="left">鼠标按下触发</td></tr></tbody></table></li></ul></li></ul></li><li><p>操作元素</p><ul><li><p>改变元素内容</p> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.innerText;   <span class="comment">//不识别html标签</span></span><br><span class="line">element.innerHTML;  <span class="comment">//识别html标签</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这两个属性可以读写，可以获得元素里面的内容</li><li><code>innerText</code> 获取元素内容 ,去除空格和换行</li><li><code>innerHTML</code> 获取元素内容，保留空格和换行</li></ul></li><li><p>常用元素的属性操作</p><ul><li>innerText , innerHTML 改变元素内容</li><li>src , href</li><li>id , alt , title </li></ul></li><li><p>表单元素的属性操作</p><ul><li>利用DOM可以操作如下表单属性：<code>type, value, checked, selected, disabled</code></li></ul></li><li><p>样式属性操作</p><ul><li>可以通过js修改元素的大小，颜色，位置等样式</li><li><code>element.style</code>   行内样式操作</li><li><code>element.className</code>  类名样式操作</li><li><code> 注：</code>JS修改style样式操作，产生的是行内样式，CSS权重比较高</li></ul></li><li><p><code>element.className</code>  类名样式操作</p><ul><li>如果修改样式过多可以采用操作类名的方式更改元素样式</li><li>class因为是保留字，因此使用className来操作元素类名属性</li><li>className 会直接更改元素类名，会覆盖原先的类名<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> box=<span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span><br><span class="line">box.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">this</span>.innerHTML=<span class="string">"已经改变了盒子"</span></span><br><span class="line">  <span class="built_in">this</span>.className=<span class="string">"change"</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li><li>如果想要保留原想的类名，可以直接采用以下方式<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.className=<span class="string">"原先的类名 新增的类名"</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>排他思想</p><ul><li>如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环排他的思想</li><li>先把所有元素全部清除样式</li><li>再给当前元素设置样式</li></ul></li><li><p>复选框的全选与取消全选</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">var</span> all = <span class="built_in">document</span>.getElementById(<span class="string">'dd'</span>);  <span class="comment">//全选按钮</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>).querySelectorAll(<span class="string">'input'</span>);  <span class="comment">//单选按钮</span></span><br><span class="line"><span class="comment">//点击全选</span></span><br><span class="line">all.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) {</span><br><span class="line">list[i].checked = <span class="built_in">this</span>.checked;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//点击单选满足后全选</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) {</span><br><span class="line">list[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;  <span class="comment">//引入变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; list.length; j++) {</span><br><span class="line"><span class="keyword">if</span> (!list[j].checked) {</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">all.checked = flag;  <span class="comment">//设置全选按钮是否选中</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>获取属性值的方法</p><ul><li><code>element.属性</code>  获取内置属性（元素自身的属性）</li><li><code>element.getAttribute('属性');</code> 主要获取自定义的属性（标准）我们自定义的属性<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"122"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(<span class="string">"获取到的属性值："</span>+<span class="built_in">document</span>.getElementById(<span class="string">'id'</span>).getAttribute(<span class="string">'index'</span>));  <span class="comment">//输出的结果为 112</span></span></span><br><span class="line"><span class="javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>设置属性值</p><ul><li><code>element.属性='值';</code> 设置内置属性值</li><li><code>element.setAttribute('属性','值');</code>  主要针对于自定义属性</li></ul></li><li><p>移除属性</p><ul><li><code>element.removeAttribute('属性')</code> 用于移除元素属性</li></ul></li><li><p>H5自定义属性</p><ul><li>自定义属性的目的：为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</li><li>H5规定自定义属性<code>data-</code>开头作为属性名并赋值。</li></ul></li><li><p>获取H5自定义属性</p><ul><li>兼容性获取  element.getAttribute(‘data-index’);</li><li>H5新增 <code>element.dataset.index</code> 或者 <code> element.dataset['index']</code></li><li>如果自定义属性里面有多个以’-‘连接的单词，获取的时候采取驼峰命名法<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// &lt;div id="box" data-list-name="1"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> box=<span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">'data-list-name'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(box.dataset[<span class="string">'listName'</span>]);   <span class="comment">//均是输出1</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>节点操作</p><ul><li>利用节点的层次关系获取元素<ul><li>利用父子兄弟关系来获取元素</li><li>逻辑性强，但兼容性差</li></ul></li><li>节点概述：一般的，节点至少拥有nnodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）这三个基本属性。<ul><li>元素节点nodeType为1</li><li>属性节点nodeType为2</li><li>文本节点nodeType为3（文本节点包含文字、空格、换行等）</li></ul></li><li>节点层次：利用DOM树把节点划分为不同的层级关系，常见的有<code>父子兄弟层级</code>关系<ul><li>利用<code>parentNode</code>获得离元素最近的父亲节点。 如果找不到父节点则返回null。</li><li>子节点<code>parentNode.childNodes</code>返回包含指定节点子节点的集合，该集合为实时更新的集合。获得的所有子节点包含：元素节点，文本节点等。可以通过nodeType进行区分。</li><li><code>parentNode.children</code>是一个只读属性，返回所有<code>子元素节点</code>。其他子节点不反回。</li><li><code>parentNode.firstChild</code>返回第一个子节点，不管是文本节点还是元素节点</li><li><code>parentNode.lastChild</code> 返回最后一个子节点，不管是文本节点还是元素节点</li><li><code>parentNode.firstElementChild</code> 获取第一个子元素节点。（IE9以上支持）</li><li><code>parentNode.lastElementChild</code> 获取最后一个子元素节点。（IE9以上支持）</li><li>实际开发若需要兼容性好则采用<code>parentNode.children</code>数组来获取第一个和最后一个子元素。</li><li><code>node.nextSibling</code> 返回当前元素的下一个兄弟节点，找不到则返回null,包含所有节点。</li><li><code>node.previousSibling</code> 返回当前元素的上一个兄弟节点，找不到则返回null,包含所有节点。</li><li><code>node.nextElementSibling</code> 返回当前元素的下一个兄弟<code>元素节点</code>，找不到则返回null,包含所有节点。 （IE9以上支持）</li><li><code>node.previousElementSibling</code> 返回当前元素的下一个兄弟<code>元素节点</code>，找不到则返回null,包含所有节点。 （IE9以上支持）</li></ul></li><li>创建节点<ul><li><code>document.createElement('tagName')</code> 创建由tagName 指定的HTML元素。因为这些元素原先不存在，是根据需求动态生成的，所以也称为<code>动态创建元素节点</code>。</li><li>添加节点<ul><li><code>node.appendChild(child)</code> 将一个节点添加到指定父节点的子节点列表的末尾。类似于CSS里面的after伪元素。</li><li><code>node.insertBefore(child,指定元素)</code> 将一个节点添加到父节点的<code>指定子节点</code>前面。类似于CSS里面的before伪元素。<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> ul=<span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> inputValue=<span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>);</span></span><br><span class="line"><span class="javascript">     btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span></span><br><span class="line"><span class="javascript">   <span class="keyword">if</span>(inputValue.value!=<span class="literal">null</span>)</span></span><br><span class="line"><span class="javascript">   {</span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> res=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);  <span class="comment">//创建节点</span></span></span><br><span class="line"><span class="javascript">     res.innerHTML=inputValue.value;  <span class="comment">// 节点赋值</span></span></span><br><span class="line"><span class="javascript">     ul.insertBefore(res,ul.children[<span class="number">0</span>]);  <span class="comment">//向前插入元素</span></span></span><br><span class="line"><span class="javascript">     inputValue.value=<span class="string">""</span>;   <span class="comment">//输入框清空</span></span></span><br><span class="line"><span class="javascript">   }</span></span><br><span class="line"><span class="javascript">  <span class="keyword">else</span>{</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"输入内容不能为空"</span>);  <span class="comment">//提示</span></span></span><br><span class="line"><span class="javascript">     }</span></span><br><span class="line"><span class="javascript">    }</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>删除节点<ul><li><code>node.removechild(child)</code> 从DOM中删除一个子节点，返回删除节点。</li></ul></li><li>复制节点<ul><li><code>node.cloneNode()</code> 返回调用该方法节点的一个副本。也称为克隆节点，拷贝节点</li><li>括号为空或者是里面为<code>false</code> 浅拷贝 只复制标签不复制里面的内容。</li><li>括号中为<code>true</code>则为深拷贝，既复制标签，也要复制里面的内容。</li></ul></li><li>三种动态创建元素<ul><li><code>document.write();</code> 直接将内容写入页面的内容流，当文档流执行完毕，则会导致页面全部重绘。</li><li><code>element.innerHTML();</code> 将内容写入某个DOM节点，不会导致页面全部重绘,创建多个元素效率更高（不要采用字符串拼接的方式，采用数组转换为字符串的方式），结构稍微复杂。 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> create=<span class="built_in">document</span>.querySelector(<span class="string">'.create'</span>);</span><br><span class="line">create.innerHTML=<span class="string">'a'</span>; </span><br></pre></td></tr></tbody></table></figure></li><li><code>document.createElement();</code> 创建多个元素效率会低一些，但结构简单清晰。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> create=<span class="built_in">document</span>.querySelector(<span class="string">'.create'</span>);</span><br><span class="line"><span class="keyword">var</span> a=<span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">create.appendChild(a);</span><br></pre></td></tr></tbody></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2></li></ul></li></ul></li><li><p>DOM：文档对象模型，处理可扩展标记语言的标准<code>编程接口</code>。通过接口可以改变网页的内容、结构、样式。</p></li><li><p>创建</p><ul><li>document.write</li><li>innerHTML</li><li>createElement</li></ul></li><li><p>增加元素</p><ul><li>appendChild</li><li>insertBefore</li></ul></li><li><p>删除元素</p><ul><li>removeChild</li></ul></li><li><p>改：主要修改dom元素的属性 </p><ul><li>修改元素属性：src， href, title等</li><li>修改普通元素内容：innerHTML, innerText</li><li>修改表单元素：value, tupe, disabled等</li><li>修改元素样式：style, className</li></ul></li><li><p>查找DOM元素</p><ul><li>DOM提供的API方法：getElementById(), getElementByTagsName()等比较古老的方法</li><li>H5提供的新方法：querySelector(), querySelectorAll()</li><li>利用节点操作获取元素：父（parentNode）, 子（children）， 兄弟（previousElementSibling、 nextElementSibling）</li></ul></li><li><p>属性操作</p><ul><li>setAttribute():设置DOM的属性值</li><li>getAttribute():得到DOM的属性值</li><li>removeAttribute():移除属性值</li></ul></li><li><p>事件操作</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JS学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记04</title>
      <link href="/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B004/"/>
      <url>/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——JS内置对象-JavaScript中的数据类型"><a href="#javascript学习笔记——JS内置对象-JavaScript中的数据类型" class="headerlink" title="javascript学习笔记——JS内置对象,JavaScript中的数据类型"></a>javascript学习笔记——JS内置对象,JavaScript中的数据类型</h1><h2 id="一、JavaScript内置对象"><a href="#一、JavaScript内置对象" class="headerlink" title="一、JavaScript内置对象"></a>一、JavaScript内置对象</h2><ol><li><p>JavaScript中的对象分为三种：自定义对象，内置对象，浏览器对象</p><ul><li>自定义对象和内置对象是JS 基础内容，属于ECMAScript；第三种浏览器对象属于JS独有的 （JS API）</li><li>内置对象：JS自带的一些对象，这些对象供开发者使用，并提供一些常用的或是最基本而非常用的功能（属性和方法）。</li><li>内置对象的最大优点就是帮助我们快速开发</li><li>JS中提供的内置对象：Math、Date、Array、String等</li></ul></li><li><p>Math数学对象</p><ul><li>不是一个构造函数，所以不需要 new 来调用，而是直接使用里面的属性和方法</li><li>常用的方法和属性<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI   <span class="comment">//圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.floor();  <span class="comment">//向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.ceil();  <span class="comment">//向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round();  <span class="comment">//四舍五入  特殊情况Math.round(1.5)结果为2  Math.round(-1.5)结果为-1</span></span><br><span class="line"><span class="built_in">Math</span>.abs();   <span class="comment">//取绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.Max();   <span class="comment">//Math.main()</span></span><br></pre></td></tr></tbody></table></figure></li><li>随机数方法<code>random()</code><ul><li>random()返回一个随机小数  0&lt;=x&lt;1 ,方法中不加参数</li><li>得到两个数之间的随机整数（不包含最大值）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min,max</span>)</span>{</span><br><span class="line">    min=<span class="built_in">Math</span>.ceil(min);</span><br><span class="line">    max=<span class="built_in">Math</span>.floor(max);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min))+min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>得到两个数之间的随机数（包含这连个数）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntInclusive</span>(<span class="params">min,max</span>)</span>{</span><br><span class="line">    min=<span class="built_in">Math</span>.ceil(min);</span><br><span class="line">    max=<span class="built_in">Math</span>.floor(max);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>))+min;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>日期对象</p><ul><li>是一个构造函数，必须使用 new 来调用创建日期对象</li><li>如果没有参数则返回系统的当前时间：<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></tbody></table></figure></li><li>参数的写法<ul><li>数字型：2022,02,22  (逗号进行分割) <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>,<span class="number">2</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date1);  <span class="comment">//输出月份会比实际月大一</span></span><br></pre></td></tr></tbody></table></figure></li><li>字符串型： ‘2022-02-22 12:22:12’</li></ul></li><li>日期格式<table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">getFullYear()</td><td align="center">获取当年</td><td align="left">dObj.getFullYear()</td></tr><tr><td align="center">getMonth()</td><td align="center">获取当月（0-11）</td><td align="left">dObj.getMonth()</td></tr><tr><td align="center">getDate()</td><td align="center">获取当天日期</td><td align="left">dObj.getDate()</td></tr><tr><td align="center">getDay()</td><td align="center">获取星期几（周日0 到周六6）</td><td align="left">dObj.getDay()</td></tr><tr><td align="center">getHours()</td><td align="center">获取当前小时</td><td align="left">dObj.getHours()</td></tr><tr><td align="center">getMinutes()</td><td align="center">获取当前分钟</td><td align="left">dObj.getMinutes()</td></tr><tr><td align="center">getSeconds()</td><td align="center">获取当前秒</td><td align="left">dObj.getSexonds()</td></tr></tbody></table></li><li>时间格式化<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params"></span>)</span>{</span><br><span class="line"> <span class="keyword">var</span> time=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> <span class="keyword">var</span> h=time.getHours();</span><br><span class="line"> h=h&lt;<span class="number">10</span>?  <span class="string">'0'</span>+h:h;</span><br><span class="line"> <span class="keyword">var</span> m=time.getMinutes();</span><br><span class="line"> m=m&lt;<span class="number">10</span>? <span class="string">'0'</span>+m:m;</span><br><span class="line"> <span class="keyword">var</span> s=time.getSeconds();</span><br><span class="line"> s=s&lt;<span class="number">10</span>? <span class="string">'0'</span>+s:s;</span><br><span class="line"> <span class="built_in">console</span>.log(h+<span class="string">':'</span>+m+<span class="string">':'</span>+s);</span><br><span class="line">}</span><br><span class="line">time();</span><br></pre></td></tr></tbody></table></figure></li><li>获取日期的总的毫秒形式<ul><li>Date()对象基于1970年1月1日起的毫秒，我们经常用总的毫秒数来计算时间，因为其更精确</li><li>通过valurOf()  或者 getTime() 获得时间戳<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf());  <span class="comment">//输出时间戳</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getTime());  <span class="comment">//输出时间戳</span></span><br><span class="line"><span class="keyword">var</span> date1= +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date1);   <span class="comment">//输出时间戳</span></span><br><span class="line"> <span class="comment">// H5新增的</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br></pre></td></tr></tbody></table></figure></li><li>倒计时案例（用户输入时间转换为时间戳，再用时间戳和当前时间戳相减，再将毫秒转换为时间）<ul><li>d=parseInt(总秒数/60/60/24);  //<code>时间戳转换为天</code></li><li>h=parseInt(总秒数/60/60%24);  //<code>时间戳转换为时</code></li><li>m=parseInt(总秒数/60%60);</li><li>s=parseInt(总秒数%60);   <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">countDown</span>(<span class="params">time</span>)</span>{</span><br><span class="line"><span class="keyword">var</span> nowTime=+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> inputTime=+<span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line"><span class="keyword">var</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(inputTime&gt;nowTime)</span><br><span class="line">{</span><br><span class="line"> t=(inputTime-nowTime)/<span class="number">1000</span>;  <span class="comment">//将毫秒转换为秒</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"时间小于当前时间！"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> d=<span class="built_in">parseInt</span>(t/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line"> d=d&lt;<span class="number">10</span>? <span class="string">'0'</span>+d:d;</span><br><span class="line"><span class="keyword">var</span> h=<span class="built_in">parseInt</span>(t/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>);</span><br><span class="line">   h=h&lt;<span class="number">10</span>? <span class="string">'0'</span>+h:h;</span><br><span class="line"><span class="keyword">var</span> m=<span class="built_in">parseInt</span>(t/<span class="number">60</span>%<span class="number">60</span>);</span><br><span class="line">  m=m&lt;<span class="number">10</span>? <span class="string">'0'</span>+m:m;</span><br><span class="line"><span class="keyword">var</span> s=<span class="built_in">parseInt</span>(t%<span class="number">60</span>);</span><br><span class="line">  s=s&lt;<span class="number">10</span>? <span class="string">'0'</span>+ s : s;</span><br><span class="line"><span class="built_in">console</span>.log(d+<span class="string">'天'</span>+h+<span class="string">'时'</span>+m+<span class="string">'分'</span>+s+<span class="string">'秒'</span>);</span><br><span class="line">             }</span><br><span class="line">           <span class="keyword">var</span> inputTime1=prompt(<span class="string">"请输入结束时间"</span>);</span><br><span class="line">           countDown(inputTime1);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul></li><li><p>数组对象</p><ul><li>创建定长的数组 <code>var arr=new Array(10)</code> 数组长度为10</li><li>创建有初始值的数组 <code>var arr=new Array(2,3,4)</code>  代表创建<code>[2,3,4]</code>数组</li><li>检测是否为数组<ul><li>instanceof 运算符<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line">   <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//输出true</span></span><br><span class="line"><span class="keyword">var</span> obj={};</span><br><span class="line">   <span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//输出false</span></span><br></pre></td></tr></tbody></table></figure></li><li>Array.isArray(检测参数); <code>H5新增方法，IE9以上版本支持</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));  <span class="comment">//输出true</span></span><br><span class="line"><span class="keyword">var</span> obj={};</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(obj));  <span class="comment">//输出false</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>添加和删除数组元素的方法<table><thead><tr><th align="center">方法名</th><th align="left">说明</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="center">push(参数1,参数2…)</td><td align="left">末尾添加一个或多个元素，注意修改原数组</td><td align="left">返回新的长度</td></tr><tr><td align="center">pop()</td><td align="left">删除数组最后一个元素，把数组的长度减一，无参数，修改原数组</td><td align="left">返回它删除元素的值</td></tr><tr><td align="center">unshif(参数1…)</td><td align="left">向数组的开头添加一个或多个元素，注意修改原数组</td><td align="left">返回新的长度</td></tr><tr><td align="center">shift()</td><td align="left">删除数组第一个元素，把数组的长度减一，无参数，修改原数组</td><td align="left">返回第一个元素的值</td></tr></tbody></table></li><li>数组排序<ul><li><code>reverse()</code>  颠倒数组中的元素的顺序，无参数。会改变原来的数组，返回新数组<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">22</span>];</span><br><span class="line">arr.reverse();    <span class="comment">//进行翻转</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">//输出[22,40,30,20,10]</span></span><br></pre></td></tr></tbody></table></figure></li><li><code>sort()</code> 对数组中的元素进行排序。会改变原来的数组，返回新数组<code>***</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           <span class="keyword">var</span> arr=[<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">3</span>];</span><br><span class="line">           arr.sort();       <span class="comment">//进行排序</span></span><br><span class="line">           <span class="built_in">console</span>.log(arr);   <span class="comment">//输出[1,17,3,4,7]</span></span><br><span class="line"></span><br><span class="line">           arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>{</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">               <span class="comment">// return b-a;  //会以降序排列</span></span><br><span class="line">})</span><br><span class="line">  <span class="built_in">console</span>.log(arr);    <span class="comment">//输出[ 1, 3, 4, 7, 17]</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>数组索引方法<table><thead><tr><th align="center">方法名</th><th align="left">说明</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="center">indexOf()</td><td align="left">数组中查找给定元素的第一个索引</td><td align="left">如果存在返回索引号，如果不存在则返回 -1</td></tr><tr><td align="center">lastIndexOf()</td><td align="left">在数组中的最后一个的索引</td><td align="left">如果存在返回索引号，如果不存在则返回 -1</td></tr></tbody></table><ul><li>返回案例<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'yellow'</span>,<span class="string">'blue'</span>,<span class="string">'pink'</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(arr.indexOf(<span class="string">'blue'</span>));    <span class="comment">//输出值为2</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'blue'</span>));  <span class="comment">// 输出值为4</span></span><br></pre></td></tr></tbody></table></figure></li><li>数组去重,用旧数组中的元素取遍历新数组，若有则不在存了<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         <span class="keyword">var</span> arr=[<span class="string">'q'</span>,<span class="string">'w'</span>,<span class="string">'e'</span>,<span class="string">'z'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>,<span class="string">'f'</span>,<span class="string">'q'</span>,<span class="string">'z'</span>];</span><br><span class="line"><span class="keyword">var</span> newarr=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(newarr.indexOf(arr[i])==-<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">newarr.push(arr[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"去重后的数组为"</span>+newarr);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>数组转换为字符串<ul><li>toString()：把数组转换成字符串，逗号分隔每一项。返回一个字符串</li><li>join(‘分隔符’)：方法用于把数组中的所有元素转换为一个字符串。返回一个字符串</li></ul></li><li>数组中某几个元素操作<table><thead><tr><th align="center">方法名</th><th align="left">说明</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="center">concat()</td><td align="left">连接两个或多个数组，不影响原数组</td><td align="left">返回一个新数组</td></tr><tr><td align="center">slice()</td><td align="left">数组截取 slice(begin,end)</td><td align="left">返回被截取项目的新数组</td></tr><tr><td align="center">splice()</td><td align="left">数组删除 splice(第几个开始，删除个数)</td><td align="left">返回被删除项目的新数组 注：这个会影响原数组</td></tr></tbody></table></li><li>基本包装类型：就是把简单数据类型包装为复杂数据类型，基本过程如下：<ul><li>把简单数据类型包装为复杂数据类型<code>var temp=new String('abcd');</code></li><li>把临时变量的值给str <code>str=temp;</code></li><li>销毁这个临时变量 <code>temp=null;</code></li></ul></li></ul></li><li><p>字符串对象</p><ul><li><p>字符串的不可变：指的是里面的值不可变，虽然看上去可以改变内容，但实际是地址变了，内存中新开辟了一个内存空间。</p></li><li><p>根据字符返回位置</p><ul><li>字符串<code>所有</code>的方法都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串。<table><thead><tr><th align="center">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">indexOf(‘要查找的字符串’,开始的位置)</td><td align="left">返回指定内容在元素字符串中的位置，找不到就返回-1，开始的位置是index索引号</td></tr><tr><td align="center">lastIndexOf()</td><td align="left">以后往前找，只找第一个匹配的</td></tr></tbody></table></li></ul></li><li><p>根据位置返回字符（重点）<code>***</code></p><table><thead><tr><th align="center">方法名</th><th align="left">说明</th><th align="left">使用</th></tr></thead><tbody><tr><td align="center">charAt(index)</td><td align="left">返沪指定位置的字符（index字符串的索引号）</td><td align="left">str.cahrAt(3)</td></tr><tr><td align="center">cahrCodeAt(index)</td><td align="left">获取指定位置处字符串的ASClLL码(index索引号)</td><td align="left">str.charCodeAt(3)</td></tr><tr><td align="center">str[index]</td><td align="left">获取指定位置处的字符</td><td align="left">H5,IE8+支持 和charAt()等效</td></tr><tr><td align="center"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>使用这个方法可以统计字符串中出现最多的字母以及出现的次数<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">           <span class="keyword">var</span> str=<span class="string">"qqwdaffasieotgnsayqpdgbgyawew"</span>;</span><br><span class="line">  <span class="keyword">var</span> obj={}</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.length;i++)</span><br><span class="line">       {</span><br><span class="line">     <span class="keyword">var</span> ss=str.charAt(i);</span><br><span class="line">     <span class="keyword">if</span>(obj[ss])</span><br><span class="line">     {</span><br><span class="line">    obj[ss]++;</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">else</span>{</span><br><span class="line">    obj[ss]=<span class="number">1</span>;</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> max=<span class="number">0</span>,res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)</span><br><span class="line">  {</span><br><span class="line">   <span class="keyword">if</span>(obj[k]&gt;max)</span><br><span class="line">   {</span><br><span class="line">max=obj[k];</span><br><span class="line">res=k;</span><br><span class="line">   }</span><br><span class="line">  }</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"出现次数最多的字母为："</span>+res+<span class="string">"  出现次数为："</span>+max);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>字符串的操作方法（重点）<code>***</code></p><table><thead><tr><th align="center">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">concat(str1,str2,str3…)</td><td align="left">常用于连接两个或多个字符串。拼接字符串等效于+，<code>+</code>更常用</td></tr><tr><td align="center">substr(start,length)</td><td align="left">从start位置开始（索引号），length为取的个数</td></tr><tr><td align="center">slice(start,end)</td><td align="left">从start位置开始截取到end位置，end取不到（两个均为索引号）</td></tr><tr><td align="center">substring(start,end)</td><td align="left">从start位置开始截取到end位置，end取不到，基本与slice相同但是不接受负值</td></tr></tbody></table><ul><li>替换字符串 <code>replace('被替换的字符','替换成为的字符')</code> 注：只会替换第一个字符<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">var</span> str=<span class="string">"qqwdaffasieotgnsayqpdgbgyawew"</span>;  <span class="comment">//替换字符串中所有a为*</span></span><br><span class="line"><span class="keyword">while</span>(str.indexOf(<span class="string">'a'</span>)!=-<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"> str=str.replace(<span class="string">'a'</span>,<span class="string">'*'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></tbody></table></figure></li><li>字符串转换为数组 <code>split('分隔符')</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> str=<span class="string">"pink,blue,yellow,pink,red,skyblue"</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="string">','</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">//输出数组</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'|'</span>))    <span class="comment">//输出字符串以 '|'分隔</span></span><br><span class="line">      <span class="comment">//之前学习的数组转换为字符串使用 join('分隔符')</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>大小写转换 <code>toUpperCase()</code>转换为大写，<code>toLowerCase()</code>  转换为小写 </p> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"abcdsfr"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase())</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="二、JavaScript中的数据类型"><a href="#二、JavaScript中的数据类型" class="headerlink" title="二、JavaScript中的数据类型"></a>二、JavaScript中的数据类型</h2><ol><li>简单数据类型与复杂数据类型<ul><li>简单数据类型（基本数据类型，值类型）： 在存储的变量中存储的是值本身<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer=<span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> timer);  <span class="comment">//输出的为Object</span></span><br></pre></td></tr></tbody></table></figure></li><li>复杂数据类型（引用类型）：在存储的变量中存储的仅仅是地址（引用），因此叫做应用类型。通过new关键字创建的对象（系统对象，自定义对象），如Object,Array,Date等</li></ul></li><li>堆和栈<ul><li>栈（操作系统）： 由操作系统自动分配释放存放函数的参数值、局部变量的值等。其他操作方式类似于数据结构中的栈。<code>简单数据类型存放到栈里面</code>。</li><li>堆（操作系统）： 存放复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。<code>复杂数据类型存放到堆里面</code></li><li>简单类型传参 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>{</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//输出11</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> x=<span class="number">10</span>;</span><br><span class="line">fn(x);</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">//输出10</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Js基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记03</title>
      <link href="/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B003/"/>
      <url>/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——数组，函数，作用域，对象"><a href="#javascript学习笔记——数组，函数，作用域，对象" class="headerlink" title="javascript学习笔记——数组，函数，作用域，对象"></a>javascript学习笔记——数组，函数，作用域，对象</h1><h2 id="二、JavaScript数组"><a href="#二、JavaScript数组" class="headerlink" title="二、JavaScript数组"></a>二、JavaScript数组</h2><ol><li><p>数组：数组是指一组数据的集合，其中的每个数据被称为元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存放在单个变量名下的方式。</p></li><li><p>数组创建的方式：</p><ul><li>利用new创建数组<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//创建一个空的新数组</span></span><br></pre></td></tr></tbody></table></figure></li><li>利用数组字面量创建数组<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.利用数组字面量的方式创建数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名=[];</span><br><span class="line"><span class="comment">//2.利用数组字面量的方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名=[<span class="string">'小白'</span>,<span class="string">'小黑'</span>,<span class="string">'大黄'</span>];</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>获取数组元素:</p><ul><li>数组索的引<ul><li>索引：用来访问数组元素的序号（数组下标从0开始）</li><li>数组可以通过索引访问、修改、设置对应的数组元素。</li></ul></li><li>数组的长度：使用“数组名.length”可以访问数组元素的数量（数组长度）</li></ul></li><li><p>数组中新增元素</p><ul><li>通过修改length长度新增数组元素</li><li>通过修改数组索引新增数组元素<ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据。</li></ul></li></ul></li><li><p>冒泡排序</p></li></ol><h2 id="JavaScript中的函数"><a href="#JavaScript中的函数" class="headerlink" title="JavaScript中的函数"></a>JavaScript中的函数</h2><ol><li>函数就是封装了一段可以被重复调用执行调用的代码块。 目的就是让大量代码重复使用</li><li>声明函数(<code>命名函数</code>)，函数不调用，自己不执行<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>调用函数 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名();   <span class="comment">//通过调用函数名来执行函数体代码</span></span><br></pre></td></tr></tbody></table></figure></li><li>利用函数的参数实现函数重复不同的代码<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>,形参<span class="number">2.</span>...</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">函数名(实参<span class="number">1</span>,实参<span class="number">2.</span>..);</span><br></pre></td></tr></tbody></table></figure></li><li>函数的返回值<ul><li>函数只是实现基本的功能，最终的结果需要返回给函数调用者。</li><li>只要函数遇见 return  就把后面的结果返回给调用者。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="keyword">return</span> 需要返回的结果;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>return终止函数：return后面的代码不会被执行！</li><li>return只能返回一个值，若以逗号隔开，则只返回<code>以最后一个值为准</code>。 </li><li>函数若存在return则返回return后面的值，若函数没有return则返回undefined</li><li>break、continue、return的区别<ul><li>break:结束当前的循环体（如for,while）</li><li>continue:跳出本次循环，继续执行下次循环（如for,while）</li><li>return:不仅能够退出循环，还能返回return语句中的值，同时还可以结束当前函数体中的代码</li></ul></li></ul></li><li>arguments的使用<ul><li>当我们不确定有多少个参数传递时，可以用<code>arguments</code>来获取。arguments实际上是当前函数的一个内置对象。</li><li>所有函数都内置一个arguments对象，arguments对象中存储了<code>传递的所有参数</code>。</li><li>arguments展示形式是一个伪数组，因此可以进行遍历，伪数组具有以下特点：<ul><li>具有length属性</li><li>按索引方式进行存储</li><li>不具有数组的<code>push()</code>和<code>pop()</code>方法</li></ul></li></ul></li><li>函数的另一种声明方式(<code>匿名函数</code>) <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是函数表达式~"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>fun是变量名不是函数名</li><li>函数表法式申明方式跟声明变量差不多，只不过变量里面存的是值，函数表达式里面存的是函数</li></ul></li></ol><h2 id="三、JavaScript中的作用域"><a href="#三、JavaScript中的作用域" class="headerlink" title="三、JavaScript中的作用域"></a>三、JavaScript中的作用域</h2><ol><li>作用域<ul><li>通常来说，一段程序代码中所用到的名字并不总是有效可用的，而限定这个名字可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</li><li>也可理解为：代码名字（变量）在某个范围内起作用和效果 </li><li>JS的作用域（es6之前）：<code>全局作用域</code>和<code>局部作用域</code>  <ul><li>在<code>es6</code>中新增块级作用域</li></ul></li><li>全局作用域：整个script标签 或者是一个单独的js文件</li><li>局部作用域（函数作用域）：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用</li></ul></li><li>变量作用域的分类<ul><li>全局变量：在全局作用域下的变量 在全局下都可以使用。<ul><li><code>注：</code>如果在函数内部没有申明，直接赋值的变量也属于全局变量。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="keyword">var</span> num=<span class="number">30</span>;</span><br><span class="line">num2=<span class="number">200</span>;</span><br><span class="line">}</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">//将会输出200</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>局部变量： 在局部作用域下的变量，或者是在函数内部的变量。函数的形参也可看做局部变量</li><li>从执行效率来对比全局变量与局部变量<ul><li>全局变量只有当浏览器关闭的时候才会销毁，比较占内存资源。</li><li>局部变量 当程序执行结束就会销毁，比较节约内存资源</li></ul></li></ul></li><li>作用域链<ul><li>根据内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作<code>作用域链</code>。</li></ul></li></ol><h2 id="四、JavaScript预解析"><a href="#四、JavaScript预解析" class="headerlink" title="四、JavaScript预解析*"></a>四、JavaScript预解析<code>*</code></h2><ol><li>几种不同的输出结果 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//1.直接输出</span></span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">//num is not defined</span></span><br><span class="line"><span class="comment">//2. 输出在前，定义在后</span></span><br><span class="line"> <span class="built_in">console</span>.log(num);</span><br><span class="line"> <span class="keyword">var</span> num=<span class="number">10</span>;    <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="comment">// 3.命名函数</span></span><br><span class="line"> fun();</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>{</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">11</span>);  <span class="comment">//输出11</span></span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//4. 使用匿名函数</span></span><br><span class="line"> fuc();</span><br><span class="line"> <span class="keyword">var</span> fuc=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">11</span>);  <span class="comment">//fuc is not a function</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li><li>javascript代码又浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码时分为两步：<code>预解析</code>和<code>代码执行</code>。<ul><li>预解析：JS引擎会把js里面所有的var还有function提升到当前作用域的最前面</li><li>代码执行：按照代码书写的顺序从上往下执行</li></ul></li><li>预解析分为 变量预解析（变量提升）函数预解析（函数提升）<ul><li>变量提升： 就是把变量声明提升到当前作用域的最前面，  不提升赋值操作。</li><li>函数提升：就是把所有的函数声明提升到当前作用于的最前面， 不调用函数。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">fun();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line">         <span class="comment">//执行结果输出undefined</span></span><br></pre></td></tr></tbody></table></figure></li><li>另外一种结合了<code>如果在函数内部没有申明，直接赋值的变量也属于全局变量</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">         fun();</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="keyword">var</span> a=b=c=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line">}</span><br><span class="line">         <span class="comment">//会输出5个10，最后一个a为未定义  （a is not defined）</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="五、JavaScript对象"><a href="#五、JavaScript对象" class="headerlink" title="五、JavaScript对象"></a>五、JavaScript对象</h2><ol><li><p>对象是一组无序的相关<code>属性</code>和<code>方法</code>的集合，所有的事物都是对象，例如字符串，数值，数组，函数等。</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法： 事物的行为，在对象中用方法来表示（常用动词）</li></ul></li><li><p>创建对象的三种方式</p><ul><li>利用<code>字面量</code>创建对象</li><li>利用<code>new Object</code>创建对象</li><li>利用<code>构造函数</code>创建对象</li></ul></li><li><p>利用字面量创建对象</p><ul><li>对象字面量：是‘{}’，里面包含了表达合格具体事物（对象）的属性和方法</li><li>里面的属性和方法采取键值对的形式 ， 键——属性名：值——属性值(数字类型、字符串类型、布尔类型、函数类型)。</li><li>方法后面跟着匿名函数</li><li><code>使用对象**</code><ul><li>调用对象的属性，采用 <code>对象名.属性名</code> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br></pre></td></tr></tbody></table></figure></li><li>另外一种方法为 <code>对象名['属性名']</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'name'</span>]);</span><br></pre></td></tr></tbody></table></figure></li><li>调用对象的方法  对象名.方法名(); <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.func();</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><p>利用 new Object 来创建对象</p><ul><li>创建空对象，追加属性<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.uname=<span class="string">"fanda"</span>;</span><br><span class="line">obj.age=<span class="number">19</span>;</span><br><span class="line">obj.func=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"创建方法"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>利用构造函数创建对象</p><ul><li>因为前面两种创建对象的方式一次只能创建一个对象.</li><li>构造函数︰是一种特殊的函数，主要用来<code>初始化对象</code>，即为对象成员变量赋初始值，它总与<code>new</code>运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</li><li>构造函数的语法格式<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.属性=值;</span><br><span class="line">    <span class="built_in">this</span>.方法=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{};</span><br><span class="line">}</span><br><span class="line"><span class="keyword">new</span> 构造函数名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的函数名首字母要大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname,age,sex</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name=uname;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">    <span class="built_in">this</span>.sex=sex;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> ldh=<span class="keyword">new</span> Star(<span class="string">'刘德华'</span>,<span class="number">43</span>,<span class="string">'男'</span>);  <span class="comment">//构造函数不需要return就可以返回结果</span></span><br><span class="line"><span class="keyword">var</span> zxy=<span class="keyword">new</span> Star(<span class="string">'张学友'</span>,<span class="number">56</span>,<span class="string">'男'</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>构造函数与对象 </p><ul><li>构造函数：抽象了对象的公共部分，封装到函数里面，它泛指某一大类。</li><li>创建对象：特指某一个，通过new关键字创建对象的过程也称为对象的实例化。</li></ul></li><li><p>new关键字执行过程</p><ul><li><code>new</code>构建函数可以在内存中创建一个空的对象</li><li><code>this</code>就会指向刚才创建的空对象</li><li>执行构造函数里面的代码，给这个空对象添加属性和方法 </li><li>返回这个对象</li></ul></li><li><p>对象的遍历</p><ul><li><code>for...in</code> 用于对数组或者对象的属性进行循环遍历<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for(变量 in 对象){ }</span></span><br><span class="line"><span class="keyword">var</span> obj={</span><br><span class="line">    <span class="attr">uname</span>:<span class="string">'fanda'</span>;</span><br><span class="line">    age:<span class="number">21</span>;</span><br><span class="line">    sex:<span class="string">'男'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">console</span>.log(k);   <span class="comment">//输出得到属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]);  <span class="comment">// 输出得到属性值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Js基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记02</title>
      <link href="/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B002/"/>
      <url>/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——JS运算符"><a href="#javascript学习笔记——JS运算符" class="headerlink" title="javascript学习笔记——JS运算符"></a>javascript学习笔记——JS运算符</h1><h2 id="一、JS运算符"><a href="#一、JS运算符" class="headerlink" title="一、JS运算符"></a>一、JS运算符</h2><ol><li><p>运算符：（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><ul><li>JavaScript中常用的运算符：<ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul></li></ul></li><li><p>算数运算符（<code>+</code> , <code>-</code> , <code>*</code> , <code>/</code> , <code>%</code>）</p><ul><li>直接用浮点数进行算数运算可能会出现问题，<code>浮点数的精度问题</code>，浮点数值的最高精度为17个小数，但在进行算数运算时其精确度远远不如小数。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3.4</span>+<span class="number">1.2</span>);   <span class="comment">//得到的结果是 0.30000000000000004</span></span><br></pre></td></tr></tbody></table></figure></li><li>表达式与返回值<ul><li>表达式：是由数字，运算符，变量等以能求得数值的有意义排列方法所得的组合。（由数字，运算符，变量组成的式子）。</li><li>返回值：表达式最终都有一个结果返回给我们，我们称为返回值。  </li></ul></li></ul></li><li><p>递增和递减运算符</p><ul><li>递增（++）<ul><li>放在变量前面时为前置递增运算符（++age类似于 age=age+1）<code>先自加1，后返回值</code></li><li>放在变量后面时称为后置递增运算符   <code>先返回原值，后自加1</code></li></ul></li><li>递减（–）<ul><li>放在变量前面时为前置递减运算符  <code>先自减1，后返回值</code></li><li>放在变量后面时称为后置递减运算符 <code>先返回原值，后自减1</code></li></ul></li></ul></li><li><p>比较运算符</p><ul><li>比较运算符：是两个运算符进行比较时所使用的运算符，比较运算后会返回一个布尔值（true/false）作为比较运算的结果。<table><thead><tr><th align="center">运算符名称</th><th align="left">说明</th><th align="left">案例</th><th align="left">结果</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="left">小于号</td><td align="left">1&lt;2</td><td align="left">true</td></tr><tr><td align="center">&gt;</td><td align="left">大于号</td><td align="left">1&gt;2</td><td align="left">false</td></tr><tr><td align="center">&gt;=</td><td align="left">大于等于号</td><td align="left">2&gt;=2</td><td align="left">true</td></tr><tr><td align="center">&lt;=</td><td align="left">小于等于号</td><td align="left">3&lt;=2</td><td align="left">false</td></tr><tr><td align="center">==</td><td align="left">判等号</td><td align="left">12==12</td><td align="left">true</td></tr><tr><td align="center">!=</td><td align="left">不等号</td><td align="left">12!=12</td><td align="left">false</td></tr><tr><td align="center">===  !==</td><td align="left">全等，要求值和数据类型都一致</td><td align="left">12===’12’</td><td align="left">false</td></tr></tbody></table></li></ul></li><li><p>逻辑运算符</p><ul><li>与（&amp;&amp;）</li><li>或（||）</li><li>非（ ! ）</li><li>短路运算（逻辑中断）：当多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</li></ul></li><li><p>赋值运算符</p><ul><li><code>=</code> , <code>+=</code> , <code>-=</code> , <code>*=</code> , <code>/=</code> , <code>%=</code></li></ul></li><li><p>运算符优先级</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">顺序</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">小括号</td><td align="center">()</td></tr><tr><td align="center">2</td><td align="center">一元运算符</td><td align="center">++ – !</td></tr><tr><td align="center">3</td><td align="center">算数运算符</td><td align="center">先* / % 后 + -</td></tr><tr><td align="center">4</td><td align="center">关系运算符</td><td align="center">&gt; &gt;= &lt; &lt;=</td></tr><tr><td align="center">5</td><td align="center">相等运算符</td><td align="center">== ！= === ！==</td></tr><tr><td align="center">6</td><td align="center">逻辑运算符</td><td align="center">先&amp;&amp;后或</td></tr><tr><td align="center">7</td><td align="center">赋值运算符</td><td align="center">=</td></tr><tr><td align="center">8</td><td align="center">逗号运算符</td><td align="center">,</td></tr></tbody></table></li></ol><h2 id="二、JavaScript流程控制——分支"><a href="#二、JavaScript流程控制——分支" class="headerlink" title="二、JavaScript流程控制——分支"></a>二、JavaScript流程控制——分支</h2><ol><li><p>流程控制：就是来控制我们的代码按照什么结构顺序来执行</p></li><li><p> 流程控制的3种结构：顺序结构，分支结构和循环结构</p></li><li><p>顺序流程控制</p><ul><li>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照<code>代码的先后顺序</code>，依次执行，程序中大多数的代码都是这样执行的。</li></ul></li><li><p>分支流程控制</p><ul><li><p>由上到下执行代码的过程中，根据<code>不同的条件</code>，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果。</p></li><li><p>JS语言提供了两种分支语句：if语句，switch语句</p></li><li><p>if语句：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>三元表达式</code>：</p><ul><li>语法结构：条件表达式?表达式1 : 表达式2</li><li>如果条件为真，则返回 表达式1 的值 ，若条件为假则 返回 表达式2的值<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> result=num&gt;<span class="number">5</span> ? <span class="string">'是的'</span> : <span class="string">'不是的'</span>;  <span class="comment">//结果为 '是的'</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>switch语句：</p><ul><li>break 若前面的case没有添加break, 则不会退出，继续执行下一个case，不论值是否相等。</li><li>表达式的值和value的值是全等关系，数据类型相等，数值相等。</li><li>代码示例：<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(表达式){</span><br><span class="line">          <span class="keyword">case</span> value1:</span><br><span class="line">              执行语句<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> value2:</span><br><span class="line">              执行语句<span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">           ......</span><br><span class="line">          <span class="attr">default</span>:</span><br><span class="line">               执行最后的语句;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> grade=prompt(<span class="string">"请输入你的成绩"</span>);</span><br><span class="line"><span class="keyword">switch</span>(grade%<span class="number">10</span>){</span><br><span class="line"> <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"优秀"</span>); <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"良好"</span>); <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"合格"</span>); <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不合格"</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>switch语句与if else if语句的区别： </p><ul><li>一般情况下两个语句可以相互替换</li><li>switch…case语句通常处理case为比较固定的值的情况，而if…else 语句更加灵活，常用于范围判断。</li><li>switch语句进行条件判断后直接执行到程序的条件语句，效率更高。 而if …else 语句有几种条件，就得判断多少次。</li><li>当分支较少时，if…else语句的执行效率比switch语句高。</li><li>当分支较多时，switch语句的执行效率比较高，而且结构更清晰。</li></ul></li></ul></li></ol><h2 id="三、JavaScript流程控制——循环"><a href="#三、JavaScript流程控制——循环" class="headerlink" title="三、JavaScript流程控制——循环"></a>三、JavaScript流程控制——循环</h2><ol><li>循环的<code>目的</code>：在实际问题中，有许多具有<code>规律</code>的重复操作，因此在程序中要完成这项操作就需要重复执行某些语句。</li><li>for循环<ul><li>在程序中，一组被重复执行的语句被称之为<code>循环体</code>，能否继续<code>重复执行</code>，取决于循环的<code>终止条件</code>。由循环体及循环的终止条件组成的语句，被称之为<code>循环语句</code>。</li><li>for循环主要用于把某些代码循环若干次。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件; 条件表达式; 操作表达式){</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>循环嵌套（双重for循环）</li><li>while循环<ul><li>while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。</li><li>while循环语法结构<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>do while循环<ul><li>do…while循环语句其实是while循环语句的一个变体，该循环会<code>先执行一次代码块</code>，然后对条件表达式进行判断，如果为真就会重复执行循环体，否则就会退出循环。</li><li>do… while循环语法结构<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd{</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">}<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>continue break<ul><li>continue关键字用于立即跳出本次循环，继续下一次循环（本次循环体中continue之后的代码就会少执行一次）。</li><li>代码示例<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">  {</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>){<span class="keyword">continue</span>;}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'循环下执行'</span>+i);</span><br><span class="line">}   </span><br><span class="line">                 <span class="comment">// 循环下执行1</span></span><br><span class="line">                 <span class="comment">//循环下执行2</span></span><br><span class="line">                 <span class="comment">// 循环下执行4 </span></span><br><span class="line">                 <span class="comment">// 循环下执行5</span></span><br></pre></td></tr></tbody></table></figure></li><li>beak关键字<ul><li>break关键字用于立即跳出循环（循环结束）</li><li>示例代码<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">   {</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">3</span>){<span class="keyword">break</span>;}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'循环下执行'</span>+i);</span><br><span class="line"> }   </span><br><span class="line">                <span class="comment">// 循环下执行1</span></span><br><span class="line">                <span class="comment">//循环下执行2</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习基础笔记01</title>
      <link href="/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B001/"/>
      <url>/2022/03/21/JavaScript%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript学习笔记——初始js，JS变量，数据类型"><a href="#javascript学习笔记——初始js，JS变量，数据类型" class="headerlink" title="javascript学习笔记——初始js，JS变量，数据类型"></a>javascript学习笔记——初始js，JS变量，数据类型</h1><h2 id="一、初识JS"><a href="#一、初识JS" class="headerlink" title="一、初识JS"></a>一、初识JS</h2><ol><li><p>JavaScript历史</p><ul><li>布兰登.艾奇</li><li>1995年诞生Javascript</li></ul></li><li><p>JavaScript是什么</p><ul><li>Javascript是世界上最流行的语言之一，是一种运行在客户端的脚本语言（Script是脚本的意思）</li><li>脚本语言：不需要编译，运行过程由JS解释器（js引擎）逐行来进行解释并执行</li><li>现在也可以基于Node.js技术进行服务端器编程</li></ul></li><li><p>JavaScript的作用</p><ul><li>表单动态校验（密码强度检测）（JS产生最初的目的）</li><li>网页特效</li><li>服务端开发（Node.js）</li><li>桌面程序（Electron）</li><li>APP(Cordova)</li><li>控制硬件-物联网（Ruff）</li><li>游戏开发（cocos2d-js）</li></ul></li><li><p>JS脚本语言-编程类语言</p><ul><li>实现业务逻辑和页面控制（决定功能）</li></ul></li><li><p>浏览器执行JS介绍</p><ul><li>浏览器分为两个部分：渲染引擎和JS引擎<ul><li><code>渲染引擎</code>： 用来解析HTML和CSS，俗称内核，比如chrome的内核时blink,老版本的webkit</li><li><code>JS引擎</code>：也称为JS解释器，用来读取网页中的JavaScript代码，对其处理后运行。比如chrome浏览器的V8</li></ul></li></ul></li><li><p>JS的组成</p><ul><li>JavaScript由JavaScript语法（ECMAScript），页面文档对象模型（DOM），浏览器对象模型（BOM）</li><li><code>ECMAScript</code>规定JS编程语言和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</li><li><code>DOM——文档对象模型（Document Object Model）</code> 是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各个元素进行操作（大小，位置，颜色等）</li><li><code>BOM——浏览器对象模型（Browser Object Model）</code>，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出窗、控制浏览器页面跳转、获取分辨率等。</li></ul></li><li><p>JS的3种书写位置</p><ul><li>行内式的JS,直接写到元素的内部<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点击"</span>  <span class="attr">onclick</span>=<span class="string">"alert('行内JS，点击显示');"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>注意单双引号的使用：在<code>HTML</code>中推荐使用双引号，在<code>JS</code>中推荐使用单引号。 </li></ul></li><li>内联式的JS<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">alert(<span class="string">'内联式的JS'</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>外部JS<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/main.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>JavaScript输入输出语句</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th><th align="center">归属</th></tr></thead><tbody><tr><td align="center">alert(msg)</td><td align="center">浏览器弹出警示框</td><td align="center">浏览器</td></tr><tr><td align="center">console.log(msg)</td><td align="center">浏览器控制台打印输出信息</td><td align="center">浏览器</td></tr><tr><td align="center">prompt(info)</td><td align="center">浏览器弹出输入框，用户可输入</td><td align="center">浏览器</td></tr></tbody></table></li></ol><h2 id="二、JS中的变量"><a href="#二、JS中的变量" class="headerlink" title="二、JS中的变量"></a>二、JS中的变量</h2><ol><li><p>变量的概念</p><ul><li>变量：适用于存放数据的容器，我们通过变量名获取数据，甚至修改和使用数据</li><li>变量的本质是程序在内存中申请的一块用来存放数据的空间。</li></ul></li><li><p>变量的使用</p><ul><li>变量在使用中分为两步：声明变量，赋值</li><li>声明变量：<code>var ago</code>。var（variable）是一个JS的关键字，用来声明变量。使用该关键字声明变量之后，计算机会自动为变量分配内存空间。<code>ago</code>为声明的变量名</li><li>声明变量并赋值称为变量的初始化<code>var ago=21;</code></li></ul></li><li><p>变量语法扩展</p><ul><li>更新变量：一个变量被重新赋值后，它原有的值将会被覆盖，变量值将以最后一次赋值为准</li><li>同时声明多个变量 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*var name='张三';</span></span><br><span class="line"><span class="comment">var age=18;</span></span><br><span class="line"><span class="comment">var sex='man'; */</span></span><br><span class="line"><span class="keyword">var</span> name=<span class="string">'张三'</span>,age=<span class="number">18</span>,sex=<span class="string">'man'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li>声明变量的特殊情况<table><thead><tr><th align="center">情况</th><th align="left">说明</th><th align="left">结果</th></tr></thead><tbody><tr><td align="center">var age;console.log(age);</td><td align="left">只声明，不赋值</td><td align="left">undefined</td></tr><tr><td align="center">console.log(age)</td><td align="left">不声明 不赋值 直接使用</td><td align="left">报错</td></tr><tr><td align="center">age=10;console.log(age)</td><td align="left">不声明 只赋值</td><td align="left">输出10</td></tr></tbody></table></li></ul></li><li><p>变量命名规范</p><ul><li>由字母（A-Za-z）、数字（0-9）、下划线（_）、美元符号（$）组成</li><li>严格区分大小写，var app;和var APP; 是两个变量</li><li>不能以数字开头，如18age为错误命名</li><li>不能是关键字、保留字。如：var, for, while等</li><li>变量名必须有意义。</li><li>遵守驼峰命名法，首字母小写，后面单词的首字母大写。myFirstName</li></ul></li></ol><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><ol><li><p>为什么需要数据类型</p><ul><li>在计算机中，不同的数据所占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。</li></ul></li><li><p>变量的数据类型</p><ul><li>JavaScript是一种弱类型或者说动态语言，这意味着不用提前声明变量类型，在程序运行过程中，类型会被自动确定。</li><li>JavaScript拥有动态数据类型，同时也意味着相同的变量可以作用不同的类型。<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">10</span>;  x=<span class="string">'string'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>数据类型的分类</p><ul><li><p><code>简单数据类型</code>（Number，String，Boolean，Undefined，Null）</p><table><thead><tr><th align="center">简单数据类型</th><th align="left">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">Number</td><td align="left">数字型，包含 整数值和浮点型值，如21，0.21</td><td align="center">0</td></tr><tr><td align="center">Boolean</td><td align="left">布尔值类型，如true,false，等价于1和0</td><td align="center">false</td></tr><tr><td align="center">String</td><td align="left">字符串类型，如“张三”，注：JS里面字符串都带引号</td><td align="center">“”</td></tr><tr><td align="center">Undefined</td><td align="left">var a;声明了变量a但没给a赋值，此时a=Undefined</td><td align="center">Undefined</td></tr><tr><td align="center">Null</td><td align="left">var a=null; 声明变量a为空值</td><td align="center">null</td></tr></tbody></table></li><li><p>数字型</p><ul><li>数字最大值：Number.MAX_VALUE</li><li>数字最小值：Number.MIN_VALUE</li><li><code>无穷大</code>：Infinity</li><li><code>无穷小</code>： -Infinity</li><li>NaN : Not a Number 代表一个非数字</li><li><code>isNaN()</code> :用来判断非数字，如果<code>是数字</code>返回<code>false</code>,如果<code>不是数字</code>则返回<code>true</code> </li></ul></li><li><p>字符串类型</p><ul><li>字符串嵌套：JS可以用单引号嵌套双引号，或者用双引号嵌套单引号（外双内单，外单内双）；</li><li>字符串长度：通过字符串的<code>length</code>属性可以获取整个字符串长度。</li><li>字符串的拼接：多个字符串可用<code>+</code>号进行拼接，其拼接方式为：<code>字符串+任何类型=拼接后的新字符串</code>。</li><li>字符串转义符：类似于HTML里面的特殊字符，字符串也有特殊字符，称之为转义符。<table><thead><tr><th align="center">转义符</th><th align="center">解释说明</th></tr></thead><tbody><tr><td align="center"><code>\n</code></td><td align="center">换行符，n是newline的意思</td></tr><tr><td align="center"><code>\\</code></td><td align="center">斜杠 \</td></tr><tr><td align="center"><code>\'</code></td><td align="center">单引号 ‘</td></tr><tr><td align="center"><code>\"</code></td><td align="center">双引号 “</td></tr><tr><td align="center"><code>\t</code></td><td align="center">tab缩进</td></tr><tr><td align="center"><code>\b</code></td><td align="center">空格，b是blank的意思</td></tr></tbody></table></li></ul></li><li><p>布尔型 Boolean</p><ul><li>布尔型与数字型相加的时候，true的值为1，false的值为0</li></ul></li><li><p>通过<code>typeof</code>来判断数据类型</p> <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);   <span class="comment">// 输出number</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><code>复杂数据类型</code>（object）</p></li></ul></li><li><p>数据类型的转换</p><ul><li><p>数据类型的转换：把一种数据类型的变量转换为另一种数据类型。</p></li><li><p>常用的三种数据类型的转换</p><ul><li>转换为字符串</li><li>转换为数字型</li><li>转换为布尔型</li></ul></li><li><p>转换为字符串：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th><th align="left">案例</th></tr></thead><tbody><tr><td align="center"><code>toString()</code></td><td align="center">转换成字符串</td><td align="left">var num=1; alert(num.toString());</td></tr><tr><td align="center"><code>String()强制转换</code></td><td align="center">转换成字符串</td><td align="left">var num=1;alert(String(num));</td></tr><tr><td align="center"><strong><code>加号拼接</code>字符串</strong></td><td align="center">和字符串拼接的结果都是字符串</td><td align="left">var num=1;alert(num+”我是字符串”)</td></tr></tbody></table></li><li><p>转换为数字型（重点）</p><table><thead><tr><th align="center">方式</th><th align="left">说明</th><th align="left">案例</th></tr></thead><tbody><tr><td align="center"><code>parseInt(string)</code>函数</td><td align="left">将string类型转为整数数值型</td><td align="left">parseInt(‘78’)</td></tr><tr><td align="center"><code>parseFloat(string)</code>函数</td><td align="left">将string类型转为浮点数数值型</td><td align="left">paeseFloat(‘78’)</td></tr><tr><td align="center">Number()强制类型转换</td><td align="left">将string类型转换为数值型</td><td align="left">Number(‘78’)</td></tr><tr><td align="center">js隐式转换(- * /)</td><td align="left">利用<code>算式运算</code>隐式转换为数值型</td><td align="left">‘12’-0</td></tr></tbody></table></li><li><p>转换为布尔型</p><ul><li>代表<code>空</code>、<code>否定</code>的值会被转换为<code>false</code>,如0、’’、NaN、null、undefined</li><li>其余值会被转换为<code>true</code><table><thead><tr><th align="center">方式</th><th align="left">说明</th><th align="left">案例</th></tr></thead><tbody><tr><td align="center">Boolean()函数</td><td align="left">其他类型转换为布尔型</td><td align="left">Boolean(‘true’)</td></tr></tbody></table><h2 id="四、执行对比"><a href="#四、执行对比" class="headerlink" title="四、执行对比"></a>四、执行对比</h2></li></ul></li></ul></li><li><p>解释型语言和编译型语言<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2Fjava%26javascript.png" alt="解释型语言和编译型语言对比"></p></li><li><p>标识符、关键字、保护字</p><ul><li>标识符：就是指开发人员为变量、属性、函数、参数起的名字<code>（标识符不能是关键字或保留字）</code></li><li>关键字：是指JS本身已经使用过的字，不能再用它们充当变量名、方法名。包括：break , case , catch , continue , default , delete , do , else , finally , for , if , in ,instanceof , new , return , switch , this , throw , try , typeof , var , void , with , while 等</li><li>保留字：实际上就是预留的“关键字”,即使现在还不是关键字，但未来有可能会成为关键字。 包括：boolean , byte , char , class , const , debugger , double , enum , export , extends , fimal , float , goto , implements , import , int , interface , long , mative , package , private , protected , public , short , static , super 等。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css学习基础笔记06</title>
      <link href="/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B006/"/>
      <url>/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B006/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法学习——伸缩布局"><a href="#CSS基础语法学习——伸缩布局" class="headerlink" title="CSS基础语法学习——伸缩布局"></a>CSS基础语法学习——伸缩布局</h1><h2 id="一、伸缩布局（CSS3）"><a href="#一、伸缩布局（CSS3）" class="headerlink" title="一、伸缩布局（CSS3）"></a>一、伸缩布局（CSS3）</h2><ol><li><p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向；</p></li><li><p>侧轴：与主轴垂直的轴称作为侧轴，默认是垂直方向<br> <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Frow.png" alt="主轴与侧轴"></p></li><li><p>方向：默认主轴从左向右，默认侧轴从上到下。主轴与侧轴<code>并不是固定不变的</code>，通过<code>flex-direction</code>可以交换</p><ul><li>flex-direction: row | row-reverse |column | column-reverse</li><li>row:横向，从左到右</li><li>row-reverse: 横向，从右到左</li><li>column: 竖向，从上到下</li><li>column-reverse: 竖向，从下到上<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fcolumn.png" alt="几种方向排列对比"></li></ul></li><li><p>justify-content 调整主轴对齐</p><table><thead><tr><th align="center">值</th><th align="left">描述</th><th align="left">理解</th></tr></thead><tbody><tr><td align="center">flex-start</td><td align="left">默认值，项目位于容器的开头。让子元素从父容器的开头开始排序</td><td align="left">让子元素从父元素开头开始</td></tr><tr><td align="center">flex-end</td><td align="left">项目位于容器的结尾</td><td align="left">让子元素从父容器的后面开始排序</td></tr><tr><td align="center">center</td><td align="left">项目位于容器的中心</td><td align="left">让子元素在父元素的中间显示</td></tr><tr><td align="center">space-between</td><td align="left">项目位于各行之间留有空白的容器中</td><td align="left">左右的盒子贴近父盒子，中间的平均分布空白区域</td></tr><tr><td align="center">space-around</td><td align="left">项目位于各行之前，之间，之后都留有空白的容器内</td><td align="left">相当于给每个盒子都添加了margin的左右边距</td></tr></tbody></table><p>  <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fflex.gif" alt="flex布局"></p></li><li><p>align-items 调整侧轴对齐（垂直对齐，针对一行使用）</p><table><thead><tr><th align="center">值</th><th align="left">描述</th><th align="left">理解</th></tr></thead><tbody><tr><td align="center">stretch</td><td align="left">默认值，项目被拉伸以适应容器</td><td align="left">让子元素的高度拉伸适用父容器（子元素不给高度的前提下）</td></tr><tr><td align="center">center</td><td align="left">项目位于容器的中心</td><td align="left">垂直居中</td></tr><tr><td align="center">flex-start</td><td align="left">项目位于容器的开头</td><td align="left">垂直对齐开始位置</td></tr><tr><td align="center">flex-end</td><td align="left">项目位于容器的尾部</td><td align="left">垂直对齐结束位置</td></tr><tr><td align="center"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>均为设置高度，默认对齐会撑开盒子，其它对齐方式则不会。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fflex-items.png"></li></ul></li><li><p>flex-wrap 控制是否换行</p><ul><li>当我们主盒子的内容宽度多于父盒子宽度的时候处理。</li></ul><table><thead><tr><th align="center">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">nowrap</td><td align="left">默认值，规定灵活的项目不拆行或不拆列。不换行则收缩显示</td></tr><tr><td align="center">wrap</td><td align="left">规定灵活的项目在必要的时候拆行或拆列</td></tr><tr><td align="center">wrap-reverse</td><td align="left">规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序</td></tr></tbody></table><p>  <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fwrap3.png" alt="换行的三种方式"></p></li><li><p>align-content 堆栈（由flex-wrap产生的独立行）对齐</p><ul><li>垂直对齐，一般在多行使用</li><li>必要条件(只有均满足这个属性设置才会有效果)<ul><li>对父元素设置自由属性 <code>display:flex</code></li><li>设置排列方式为横向排列 <code>flex-direction:row</code></li><li>并设置换行 <code>flex-wrap:wrap</code></li></ul><table><thead><tr><th align="center">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">stretch</td><td align="left">默认值，项目被拉伸以适应容器</td></tr><tr><td align="center">center</td><td align="left">项目位于容器的中心</td></tr><tr><td align="center">flex-start</td><td align="left">项目位于容器的开头</td></tr><tr><td align="center">flex-end</td><td align="left">项目位于容器的结尾</td></tr><tr><td align="center">space-between</td><td align="left">项目位于各行之间留有空白的容器中</td></tr><tr><td align="center">space-around</td><td align="left">项目位于各行之前，之间，之后都留有空白的容器内</td></tr></tbody></table></li></ul></li><li><p>flex-flow是flex-direction、flex-wrap的简写形式</p><ul><li><code>flex-flow: flex-direction flex-wrap</code></li><li>flex-flow:排列方式  是否换行</li><li><code>flex-flow: row wrap </code>相当于 <code>flex-direction:row; flex-wrap:wrap;</code></li></ul></li><li><p>order控制子项目的排列顺序，正序方式排列，从小到大。</p><ul><li>用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认值为0 </li><li>将order属性放在需要排序的div里面</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css学习基础笔记05</title>
      <link href="/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B005/"/>
      <url>/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B005/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法学习——溢出的文字隐藏，精灵技术，CSS3动画"><a href="#CSS基础语法学习——溢出的文字隐藏，精灵技术，CSS3动画" class="headerlink" title="CSS基础语法学习——溢出的文字隐藏，精灵技术，CSS3动画"></a>CSS基础语法学习——溢出的文字隐藏，精灵技术，CSS3动画</h1><h2 id="一、溢出的文字隐藏"><a href="#一、溢出的文字隐藏" class="headerlink" title="一、溢出的文字隐藏"></a>一、溢出的文字隐藏</h2><ol><li><code>work-break</code>:自动换行（主要处理英文单词）<ul><li>normal: 使用浏览器默认的换行规则</li><li>break-all：允许在单词内换行</li><li>keep-all: 只能在 半角空格 或 连字符 处换行</li></ul></li><li><code>white-space</code><ul><li>设置或检索对象内文本显示方式，通常我们使用于强制一行显示内容。</li><li>normal: </li><li>nowrap: 强制在同一行内显示所有文本，直到文本结束或者遭遇<code>&lt;br/&gt;</code>标签才换行</li></ul></li><li><code>text-overflow</code>: 文本溢出<ul><li><code>text-ocerflow: clip | ellipsis</code></li><li>设置或检索是否使用一个省略标记（……）标示对象内文本溢出</li><li>clip:不显示省略号，只是简单的裁剪</li><li>ellipsis: 当对象文本溢出时显示省略号标志</li><li><code>注：</code>必须强调在一行内显示，text-overflow才有效果</li></ul></li></ol><h2 id="二、CSS精灵技术（sprite）-小妖精-雪碧"><a href="#二、CSS精灵技术（sprite）-小妖精-雪碧" class="headerlink" title="二、CSS精灵技术（sprite） 小妖精 雪碧"></a>二、CSS精灵技术（sprite） 小妖精 雪碧</h2><ol><li><p><code>精灵技术产生的背景</code>：由于网站中会有较多小的背景图作为修饰，当图片过多时，服务器就会频繁的接收和发送请求，这会大大降低页面的加载速度。为了减少服务器接收和发送请求的次数，提高网页加载速度，出现了CSS精灵技术。</p></li><li><p>精灵技术的本质：是一种处理网页背景图像的方式，它将一个页面涉及到的零星背景集中到一张图上去。当用户请求时，只需要发送一次请求，页面中的所有背景图像即可展示出来。</p></li><li><p>精灵图的应用，整个页面的小图标背景在一张图上，需要使用背景时引用这张大图，然后通过<code>background-position:</code>设置位置偏移来显示出需要的背景。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fsprite.png" alt="精灵图样张"></p></li><li><p><code>注：</code>若背景图片不算多，可以不用使用精灵图。因而存在维护麻烦的问题。</p></li><li><p>字体图标（iconfont）</p><ul><li>字体图标的优点：<ul><li>可以做出和图片一样可以做的事情，改变透明度，旋转等</li><li>本质是文字，可以很随意改变颜色，产生阴影，透明效果等</li><li>本身体积小，但携带的信息并没有消弱</li><li>几乎支持所有的浏览器</li><li>移动端设备比较常用</li></ul></li><li>字体图标使用流程（感觉比较麻烦）<ul><li>UI人员设计字体图标效果图（svg）</li><li>前端人员上传生成兼容性的字体文件包</li><li>前端人员下载兼容字体文件包到本地</li><li>把字体文件包引入到HTML页面中</li></ul></li></ul></li><li><p>滑动门</p><ul><li><p>为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动。</p></li><li><p>核心技术：CSS精灵（主要是背景位置），盒子padding撑开宽度，以适应不同字数的导航栏</p></li><li><p>经典布局</p> <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span> 书写文字内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>具体实现步骤：</p><ul><li><p>a设置背景左侧，padding撑开合适宽度。</p></li><li><p>span设置背景右侧，padding撑开合适宽度，剩下的由文字继续撑开宽度。</p></li><li><p>之所以要a标签包含span是因为整个导航栏都需要点击。</p><p><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2F1-w1.gif" alt="滑动门演示"></p></li></ul></li></ul></li></ol><h2 id="三、CSS动画"><a href="#三、CSS动画" class="headerlink" title="三、CSS动画"></a>三、CSS动画</h2><ol><li><p>过渡（CSS3）</p><ul><li>在CSS3里使用<code>transition</code>可以实现补间动画（过渡效果)，并且当前元素只要有”属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现<code>平滑的过渡</code>，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。</li><li>transition：要过度的属性 花费的时间 运动曲线 何时开始；（如果有多组属性变化可用逗号隔开）<table><thead><tr><th align="center">属性</th><th align="left">描述</th><th align="center">CSS</th></tr></thead><tbody><tr><td align="center">transition</td><td align="left">简写属性，用于一个属性中设置四个过渡属性</td><td align="center">3</td></tr><tr><td align="center">transition-property</td><td align="left">规定应用过渡的CSS属性名称</td><td align="center">3</td></tr><tr><td align="center">transition-duration</td><td align="left">定义过渡效果花费的时间，默认为0，单位为秒(s)</td><td align="center">3</td></tr><tr><td align="center">transition-timing-funtion</td><td align="left">规定过渡效果的时间曲线，默认为“ease”</td><td align="center">3</td></tr><tr><td align="center">transition- delay</td><td align="left">规定过渡效果何时开始，默认为0</td><td align="center">3</td></tr></tbody></table></li><li>运动曲线：linear(匀速)，esse(逐渐慢下来)，ease-in(加速)，ease-out(减速)，ease-in-out(先加速后减速)。</li><li><code>注：</code>transition要添加在div里面而不是hover里面，如果加在hover里面则会在鼠标移开时瞬间返回原样，无还原过渡动画。</li></ul></li><li><p>2D变形（CSS3）transform</p><ul><li><code>transform是CSS3中具有颠覆性的特征之一</code>，可以实现元素的位移、旋转、倾斜、缩放</li><li>位移 <code>translate(x,y)</code><ul><li>transform:translate(x,y) 移动，平移。</li><li>移动数值填写百分比不是以父级为参考，而是以自己的长或宽作为参考。</li></ul></li><li>缩放 <code>scale(x,y)</code><ul><li>可以对元素进行水平和垂直方向的缩放</li><li>若只写一个参数，宽度与高度都缩放</li><li></li></ul></li><li>旋转 <code>rotate(deg)</code><ul><li>deg代表旋转的度数，正值代表顺时针旋转，负值代表逆时针旋转</li><li>旋转中心点的设置：  transform-origin:center center(默认)</li><li>left top  左上角</li><li>left bottom 左下角</li><li>设置精确单位 transform-origin:20px 20px;</li></ul></li><li>倾斜 skew(deg,deg)<ul><li>transform:skew(30deg,30deg)</li></ul></li></ul></li><li><p>3D变形（CSS3）transform</p><ul><li>记住坐标：<ul><li>X左边为负，右边为正</li><li>Y上边是负，下边为正</li><li>Z里面是负，外面是正</li></ul></li><li><code>rotateX（deg）</code>代表元素绕着X轴旋转</li><li><code>rotateY(deg)</code> 代表元素绕着Y轴旋转</li><li><code>rotateZ(deg) </code> 类似于之际使用rotate进行旋转</li></ul></li><li><p>透视（perspective）</p><ul><li>透视原理：近大远小</li><li>浏览器透视：把近大远小的所有图像透视到屏幕上</li><li>perspective:一般作为一个属性设置给父元素，作用于所有3D转换的子元素</li><li>视距越大透视效果越不明显，视距越小透视效果越明显。</li><li><code>transform:translate3d(x,y,z)</code> ; x,y可以是数值px，也可以是百分比。但z值只能为数值</li><li><code>backface-visibility:hidden</code> 不是正面对屏幕，就隐藏</li></ul></li></ol><h2 id="四、动画（CSS3）animation"><a href="#四、动画（CSS3）animation" class="headerlink" title="四、动画（CSS3）animation"></a>四、动画（CSS3）animation</h2><ol><li>动画是CSS3具有颠覆性的特征之一，可通过设置多个结点来精确控制一个或一组动画，常用来实现复杂的动画效果。<ul><li><code>animation:动画名称 动画时间 动画曲线 何时开始 播放次数 是否反向播放</code></li><li>动画名称自定义</li></ul></li><li>定义动画 <code>@keyframes</code><ul><li>需要先定义动画才能应用动画</li><li>定义动画：<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyfranes</span> 动画名称 {   </span><br><span class="line">  <span class="selector-tag">from</span>{ 开始位置(<span class="number">0%</span>) } </span><br><span class="line">  <span class="selector-tag">to</span>{结束位置(<span class="number">100%</span>)} </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>无限循环播放动画：<code>animation-iteration-count:infinite</code></li><li>停止动画：<code>animation-play-state:paused</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css学习基础笔记04</title>
      <link href="/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B004/"/>
      <url>/2022/03/20/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法学习——定位，元素显示与隐藏，CSS高级技巧"><a href="#CSS基础语法学习——定位，元素显示与隐藏，CSS高级技巧" class="headerlink" title="CSS基础语法学习——定位，元素显示与隐藏，CSS高级技巧"></a>CSS基础语法学习——定位，元素显示与隐藏，CSS高级技巧</h1><h2 id="CSS定位（position）"><a href="#CSS定位（position）" class="headerlink" title="CSS定位（position）"></a>CSS定位（position）</h2><ol><li><p>元素的定位属性</p><ul><li><p>元素的定位属性主要包括定位模式和边偏移两个部分</p></li><li><p>边偏移</p><table><thead><tr><th align="center">边偏移属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">top</td><td align="left">顶部偏移量，定义元素对其父元素上边线的距离</td></tr><tr><td align="center">bottom</td><td align="left">底部偏移量，定义元素对其父元素下边线的距离</td></tr><tr><td align="center">left</td><td align="left">左侧偏移量，定义元素对其父元素左边线的距离</td></tr><tr><td align="center">right</td><td align="left">右侧偏移量，定义元素对其父元素右边线的距离</td></tr></tbody></table></li><li><p>定位模式（定位的分类）</p><table><thead><tr><th align="center">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">static</td><td align="left">自动定位（默认定位方式）</td></tr><tr><td align="center">relative</td><td align="left">相对定位，相对于其原文档流的位置进行定位</td></tr><tr><td align="center">absolute</td><td align="left">绝对定位，相对于其上一个已经定位的父元素进行定位</td></tr><tr><td align="center">fixed</td><td align="left">固定定位，相对于浏览器窗口进行定位</td></tr></tbody></table></li><li><p>静态定位（static）</p><ul><li>静态定位为默认定位模式，对于边偏移无效。一般用于<code>清除定位</code></li></ul></li><li><p>相对定位（relative）</p><ul><li>将元素相对于它在的标准流中的位置进行定位</li><li>通过<code>相对定位</code>后通过边偏移属性改变元素的位置，但是原来所占有的位置会继续占有</li><li>每次移动位置是以自己的左上角为基点进行移动。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Frelative.png" alt="相对定位图解"></li></ul></li><li><p>绝对定位(absolute)</p><ul><li>绝对定位完全脱离标准流的,它不占有位置</li><li>若父元素<code>没有</code>设置定位,则子元素会以浏览器作为标准进行偏移,若父元素设置定位,则以最近父元素位置作为基准进行偏移</li></ul></li><li><p>固定定位(fixed)</p><ul><li>固定定位是绝对定位的一种特殊形式</li><li>固定定位的元素跟父级没有任何关系,只认浏览器</li><li>固定定位完全脱离标准流,不占有位置,不随着滚动条滚动</li><li><code>注:</code>IE6等低版本浏览器不支持固定定位</li><li><code>注:</code>固定定位的盒子一定要写宽和高,除非有内容撑开不用谢</li></ul></li><li><p>sticky 定位（新增类似于fixed和relative的结合）</p><ul><li>设置了sticky的元素，在屏幕范围（viewport）时该元素的位置<code>并不受到定位影响</code>（设置是top、left等属性<code>无效</code>），当该元素的位置将要<code>移出偏移范围时</code>，定位又会变成<code>fixed</code>，根据设置的left、top等属性成固定位置的效果。</li><li><code>特点1</code>：不脱离文档流，仍然保留元素原本在文档流中的位置。</li><li><code>特点2</code>：当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置</li><li><code>特点3</code>：元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于屏幕范围（viewport）来计算元素的偏移量。</li></ul></li></ul></li><li><p>子绝父相<code>**</code></p><ul><li>孩子元素使用<code>绝对定位</code>(不占有位置,脱离标准流),父级元素使用<code>相对定位</code>(占有位置,不脱离标准流)</li></ul></li><li><p>绝对定位的盒子水平/垂直居中</p><ul><li>普通定位的盒子在设置宽度后使用<code>margin: 0 auto </code>可以实现水平居中,添加绝对定位后则失效</li><li>定位的盒子实现水平/垂直居中有一个算法:<ul><li>首先left:50%</li><li>左走自己宽度的一半</li></ul></li></ul></li><li><p>叠放次序(z-index)</p><ul><li>当多个元素同时发生定位时,定位元素之间有可能发生重叠。</li><li>z-index默认值为0,取值越大,定位元素在层叠元素中越居上。</li><li>如果取值相同,根据书写顺序后来居上。</li><li>后面的数字一定不能加单位。</li><li>只有<code>相对定位</code>,<code>绝对定位</code>,<code>固定定位</code>有此属性,其余标准流,浮动,静态定位都无此属性。</li></ul></li><li><p>对以上四种定位的总结</p><table><thead><tr><th align="left">定位模式</th><th align="left">是否脱标占有位置</th><th align="left">是否可以使用边偏移</th><th align="left">移动位置基准</th></tr></thead><tbody><tr><td align="left">静态 static</td><td align="left">不脱标,正常模式</td><td align="left"><code>不</code>可使用</td><td align="left">正常模式</td></tr><tr><td align="left">相对定位 relative</td><td align="left">不脱标,占有位置</td><td align="left">可以使用</td><td align="left">相对自身位置移动</td></tr><tr><td align="left">绝对定位 absolute</td><td align="left">脱标,不占有位置</td><td align="left">可以使用</td><td align="left">相对于定位父级移动位置</td></tr><tr><td align="left">固定定位 fixed</td><td align="left">脱标,不占有位置</td><td align="left">可以使用</td><td align="left">相对于浏览器移动位置</td></tr></tbody></table></li><li><p>定位模式转换</p><ul><li><code>和浮动一样</code>,元素添加绝对定位和相对定位后(都是脱标不占位),元素模式也会发生转换,都转换为行内块模式</li><li>一些行内元素,若需要添加浮动,或者是绝对定位,相对定位,则不在需要添加模式转换<code>display:inline-block</code>,可以直接设置宽度和高度。</li></ul></li></ol><h2 id="二、元素的显示与隐藏"><a href="#二、元素的显示与隐藏" class="headerlink" title="二、元素的显示与隐藏"></a>二、元素的显示与隐藏</h2><ol><li>在CSS中有3个显示和隐藏的单词比较常见，他们分别是<code>display</code>,<code>visibility</code>,<code>overflow</code></li><li><code>display</code>显示<ul><li><code>display:none</code>隐藏对象，与它相反的是<code>display:block</code>,除了转换为块级元素外，同时还有显示元素的意思。</li><li>特点：隐藏元素后不在保留位置。</li></ul></li><li><code>visibility</code>可见性<ul><li>设置或检索是否显示对象</li><li>visible:对象可视</li><li>hidden：对象隐藏</li><li>特点：隐藏之后继续保持原有位置</li></ul></li><li>overflow溢出<ul><li>检索或设置当前对象的内容超过其指定高度或宽度时如何管理内容</li><li>visible:不剪切内容也不添加滚动条（默认）</li><li>auto：超出自动显示滚动条，不超出不显示滚动条</li><li>hidden：不显示超过对象尺寸的内容，超过部分隐藏掉</li><li>scroll：不管超不超出内容，总是显示隐藏条</li></ul></li></ol><h2 id="三、CSS高级技巧"><a href="#三、CSS高级技巧" class="headerlink" title="三、CSS高级技巧"></a>三、CSS高级技巧</h2><ol><li><p>CSS用户界面样式</p><ul><li>所谓用户界面样式，就是更让一些用户操作样式。比如：更改用户的鼠标样式，表单轮廓等。</li></ul></li><li><p>鼠标样式cursor</p><ul><li>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</li><li><code>cursor:default 小白| pointer 小手| move 移动|text 文本</code></li></ul></li><li><p>轮廓outline</p><ul><li>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用</li><li><code>outline: outline-color|| outline-style || outline-width</code></li><li>最直接的写法 outline: 0; 取消轮廓线</li></ul></li><li><p>防止拖拽文本域（resize）</p><ul><li>设置resize:none 可以防止 火狐，谷歌等浏览器随意拖动文本域</li></ul></li><li><p>vertical-align垂直对齐</p><ul><li>通常用来控制图片或默认表单与文字的对齐方式</li><li><code>vertical-align</code>:middle对于块级元素无效</li><li><code>vertical-align: baseline| middle | top | bottom</code><br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fvertical.png" alt="vertical-align三种模式"></li></ul></li><li><p>去除图片底部空白间隙</p><ul><li>可以看见上图<code>div</code>块元素添加边框后底部具有空白间隙。</li><li>有一个十分重要的特性，图片或者表单等<code>行内块元素</code>，它们的底线会和父级盒子的基线对齐。这样就造成了图片底部的空白间隙。</li><li>解决方法：<ul><li>给img标签添加<code>display:block;</code>转换为块级元素就不会存在此问题</li><li>设置img标签<code>vertical-align: top | middle;</code>因为是默认基线对齐才产生的空白间隙，只要设置对齐方式为middle或者top即可解决。（用的较多）</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css学习基础笔记03</title>
      <link href="/2022/03/19/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B003/"/>
      <url>/2022/03/19/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法学习——CSS三大特性，网页布局，浮动，清除浮动"><a href="#CSS基础语法学习——CSS三大特性，网页布局，浮动，清除浮动" class="headerlink" title="CSS基础语法学习——CSS三大特性，网页布局，浮动，清除浮动"></a>CSS基础语法学习——CSS三大特性，网页布局，浮动，清除浮动</h1><h2 id="一、CSS三大特性"><a href="#一、CSS三大特性" class="headerlink" title="一、CSS三大特性"></a>一、CSS三大特性</h2><ol><li><p>CSS层叠样式</p><ul><li>若样式冲突，遵循的原则是就近原则，哪个样式距离结构近就执行哪个样式</li><li>样式不冲突是不会层叠的</li></ul></li><li><p>CSS继承性</p><ul><li>子标签会继承父标签的某些样式，如文本颜色和字号</li><li><code>text- , font- , line- </code>这些元素开头的几乎都能继承  </li></ul></li><li><p>CSS优先性</p><ul><li>元素定义的样式会覆盖继承样式</li><li>权重相同时，css遵循就近原则，也就是靠近元素的优先级更大</li><li>CSS定义了一个<code>!important</code>命令，该命令赋予最大优先级</li></ul></li><li><p>CSS特殊性（Specificity）</p><ul><li>Specificity是一个四位的数字串，更像四个级别，从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可跨越。<code>继承的权重为0</code></li></ul><table><thead><tr><th align="center">继承或*的贡献值</th><th align="center">0，0，0，0</th></tr></thead><tbody><tr><td align="center">每个元素（标签）贡献值为</td><td align="center">0，0，0，1</td></tr><tr><td align="center">每个类，伪类贡献值为</td><td align="center">0，0，1，0</td></tr><tr><td align="center">每个ID贡献值为</td><td align="center">0，1，0，0</td></tr><tr><td align="center">每个行内样式贡献值为</td><td align="center">1，0，0，0</td></tr><tr><td align="center">每个!important贡献值为</td><td align="center">无穷大</td></tr></tbody></table><ul><li>权重叠加<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>{</span><br><span class="line">    <span class="attribute">color</span>:red</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">li</span>{</span><br><span class="line">    <span class="attribute">color</span>:green</span><br><span class="line">}  </span><br><span class="line"><span class="comment">/* 最终会显示红色 */</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="二、网页布局"><a href="#二、网页布局" class="headerlink" title="二、网页布局"></a>二、网页布局</h2><ol><li><p>网页布局的本质:把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。</p></li><li><p>盒子模型（box-model）</p><ul><li><p>盒子边框（border）</p><ul><li>语法：<code>border:border-width||border-style||border-color</code></li><li>边框样式用于定义页面中边框的风格</li><li>none:没有边框即忽略所有边框的宽度</li><li>solid: 边框为单实线</li><li>dashed:边框为虚线</li><li>dotted:边框为点线</li><li>double:边框为双实线</li><li>表格细线边框：<code>border-collapse:collapse</code>表示边框合并在一起</li><li>圆角边框：<code>border-radius:左上角 右上角 右下角 左下角</code></li></ul></li><li><p>内边距（padding）</p><ul><li>内容距离边框的距离</li><li><code>padding</code>只有一个值代表四边均为这个值，只有两个值，表示上下边距为第一个数值，左右边距为第二个数值</li><li>上 右 下 左</li></ul></li><li><p>外边距(margin)</p><ul><li>用于设置外边距，设置外边距会使元素之间变为”空白”，这段空白通常不能放置其他内容</li><li>外边距实现盒子水平居中对齐：必须是块级元素，设置宽度(width)<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">margin</span>: <span class="number">0</span> auto}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>清除内外边距，默认样式</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*{</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>注：</code>行内元素没有上下外边距，只有左右外边距</p></li><li><p><code>相邻块元素</code>外边距合并：同一列的两个盒子在上面一个设置下外边距，下面一个设置上外边距的时候会合并，最终间距为两个中的大者；如下：最终两个盒子间距为<code>100px</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>: <span class="number">#008000</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-class">.top</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css"><span class="attribute">margin-bottom</span>:<span class="number">100px</span> ;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-class">.bottom</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>嵌套块元素垂直外边距的合并：对于两个嵌套关系的块元素，如果父元素没有<code>上内边距</code>及<code>边框</code>，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。解决方案为：为父元素定义1像素上边框或上内边距，或者为父元素定义<code>overflow:hidden</code></p></li><li><p><code>注：</code>度属性width和高度属性height仅适用于<code>块级元素</code>，对行内元素无效（ img标签和input除外）。</p></li><li><p><code>注：</code>计算盒子模型的总高度时，还应考虑上下两个盒子<code>垂直外边距合并</code>的情况。</p></li><li><p><code>注：</code>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小。</p></li></ul></li><li><p>盒子模型布局稳定性</p><ul><li><code>width&gt;padding&gt;margin</code></li><li><code>margin</code>会有外边距合并，在IE6下面margin加倍的bug，所以最后使用</li><li><code>padding</code>会影响盒子大小，需要进行加减计算（比较麻烦）其次使用</li><li><code>width</code>最常用，我们经常使用宽度剩余法和高度剩余法来做</li></ul></li><li><p>CSS3盒模型</p><ul><li>CSS3中可通过<code>box-sizing</code>来指定盒模型，即可指定为<code>content-box</code>,<code>border-box</code>。这样我们计算盒子大小的方式就会发生改变。</li><li><code>box-sizing:content-box</code> 盒子大小为width+padding+border，content-box为默认值</li><li><code>box-sizing:border-box</code> 盒子大小为width,也就是说padding和border包含在width里面</li></ul></li><li><p>盒子阴影</p><ul><li><code>box-shadow</code>:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内外阴影；</li></ul></li></ol><h2 id="三、浮动（float）"><a href="#三、浮动（float）" class="headerlink" title="三、浮动（float）"></a>三、浮动（float）</h2><ol><li>CSS定位的三种机制：普通流（标准流）、浮动、定位</li><li>普通流（normal flow）</li><li>浮动流<ul><li>原本用于图文显示的文字环绕效果，后用于页面布局</li><li>设置浮动的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。不占位置，会影响标准流。浮动只有左右浮动。</li><li>浮动首先需要添加标准流父级，浮动元素总会找到离它最近的父级元素对齐，但是不会超出内边距的范围。</li><li><code>块级元素</code>添加浮动后具有行内块的特性</li><li><code>行内元素</code>添加浮动后也具有行内块特性</li></ul></li></ol><h2 id="四、版心与布局流程"><a href="#四、版心与布局流程" class="headerlink" title="四、版心与布局流程"></a>四、版心与布局流程</h2><ol><li><p>“版心”（可视区）是指网页中主体内容所在的区域/一般在浏览器窗口中水平居中显示。常见的宽度有960px,980px,1000px,1200px等。</p></li><li><p>布局流程</p><ul><li>确定页面版心（可视区）</li><li>分析页面中的行模块，以及每个行模块中的列模块</li><li>制作HTNL结构</li><li>CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制页面的各个模块。</li></ul></li><li><p>快捷命令<code>.top+.banner+(.main&gt;.left+.right)+.bottom</code>,点击tab键生成</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>清除浮动</p><ul><li>由于浮动元素<code>不再占用原文档流的位置</code>，所以它会对后面的<code>元素排版</code>产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。</li><li>并不是清除浮动，<strong>而是清除浮动后造成的影响</strong></li><li>清除浮动的本质：解决父级元素因为子级元素浮动造成的<code>高度为0</code>的问题。</li><li>清除浮动的方法（闭合浮动），用于在添加额外标签后添加样式<ul><li><code>选择器:{clear:属性值}</code></li><li>left:不允许左侧有浮动元素（清除左侧浮动的影响）</li><li>right:不允许右侧有浮动元素（清除右侧浮动的影响）</li><li>both:同时清除左右浮动的影响</li></ul></li></ul></li><li><p>清除浮动的方法</p><ul><li><p>额外标签法： 是wac推荐的做法是通过在浮动元素末尾添加一个空的标签，例如<code>〈div style="clear:both"&gt;&lt;/div&gt;</code>，或则其他标签br等亦可。</p><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义标签，结构化较差。 </li></ul></li><li><p>父级添加overflow属性方法</p><ul><li>可以通过触发BFC的方式清除浮动效果（块级格式化上下文）</li><li>可以给父级添加：<code>overflow：hidden|auto|scroll</code> 均可实现</li><li>优点：代码简洁</li><li>缺点：内容增多时容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</li></ul></li><li><p>使用after伪元素清除浮动</p><ul><li>本质也是额外标签法，但要将content中的内容不显示</li><li>以下<code>.clearfloat</code>为选择浮动元素的父级块元素</li></ul>  <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="selector-class">.clearfloat</span>:after{</span><br><span class="line">content: <span class="string">"."</span>;     <span class="comment">/* 内容为小点,尽量不要多加内容,否则旧版本浏览器会有间隙 */</span></span><br><span class="line"><span class="attribute">display</span>: block;    <span class="comment">/* 转换为块级元素 */</span></span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">visibility</span>: hidden;   <span class="comment">/* 隐藏盒子 */</span></span><br><span class="line"><span class="attribute">clear</span>: both;      <span class="comment">/* 清除浮动 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clearfloat</span>{</span><br><span class="line">*zoom: <span class="number">1</span>;    <span class="comment">/* *代表只有IE6,7浏览器能识别的特殊符号,带*号后只有IE6,7才执行.zoom就是IE浏览器清除浮动的方式 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>优点：符号闭合浮动的思想，结构语义化准确</li><li>缺点：由于IE6-7不支持 :after ，使用zoom:1触发hasLayout</li></ul></li><li><p>使用after和before双伪元素清除浮动</p><ul><li>优点：代码更简洁</li><li>缺点：由于IE6-7不支持 :after ，使用zoom:1触发hasLayout<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="selector-class">.clearfloat</span>:before,.clearfloat:after{</span><br><span class="line">content: <span class="string">""</span>;</span><br><span class="line"><span class="attribute">display</span>: table;  <span class="comment">/* 触发BFC,BFC可以清除浮动 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clearfloat</span>:after{</span><br><span class="line">clear: both;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.clearfloat</span>{</span><br><span class="line">*zoom: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css学习基础笔记02</title>
      <link href="/2022/03/18/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B002/"/>
      <url>/2022/03/18/Css%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法学习——样式表，标签显示模式，复合选择器，背景"><a href="#CSS基础语法学习——样式表，标签显示模式，复合选择器，背景" class="headerlink" title="CSS基础语法学习——样式表，标签显示模式，复合选择器，背景"></a>CSS基础语法学习——样式表，标签显示模式，复合选择器，背景</h1><h2 id="一、样式表"><a href="#一、样式表" class="headerlink" title="一、样式表"></a>一、样式表</h2><ol><li><p>内部样式表</p><ul><li>内部样式表将CSS代码写在HTML头部标签中，并且用style标签定义<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        选择器：{  属性名：属性值 }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>行内样式表（内联样式表）</p><ul><li>是通过标签的style属性来设置元素的样式<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;标签名 style="属性名:属性值;属性名2:属性值2"&gt; &lt;/标签名&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>外部样式表（外链式）</p><ul><li>从外部引入CSS文件通过link标签将外部样式文件链接到HTML文件中,<code>link</code>标签为但标签</li><li>rel：表示当前文件与被链接文档之间的关系。指定为”stylesheet“,表示被链接的文档为一个样式表<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css文件路径/外部链接网址"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>  <span class="attr">rel</span>=<span class="string">""</span><span class="attr">stylesheet</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>各种样式表之间的比较</p><table><thead><tr><th align="center">样式表</th><th align="left">优点</th><th align="center">缺点</th><th align="center">使用情况</th><th align="center">控制范围</th></tr></thead><tbody><tr><td align="center">行内样式表</td><td align="left">书写方便，权重高</td><td align="center">没有实现样式和结构相分离</td><td align="center">较少</td><td align="center">控制一个标签（少）</td></tr><tr><td align="center">内联样式表</td><td align="left">部分结构和样式分离</td><td align="center">没有彻底分离</td><td align="center">较多</td><td align="center">控制一个页面（中）</td></tr><tr><td align="center">外部样式表</td><td align="left">完全实现样式与结构分离</td><td align="center">需要引入</td><td align="center">最多，比较推荐使用</td><td align="center">控制整个站点（多）</td></tr></tbody></table></li></ol><h2 id="二、标签显示模式"><a href="#二、标签显示模式" class="headerlink" title="二、标签显示模式"></a>二、标签显示模式</h2><ol><li>块级元素（block-level）<ul><li>每个块元素通常会独自占用一整行，可以对其设置宽度，高度，对齐等属性，常用于网页布局和网页结构搭建，</li><li><code>&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等</code></li><li>特点：<ul><li>总是从新行开始</li><li>宽度、高度、内边距和外边距都是可以控制的</li><li>宽度默认为容器的100%</li><li>可以容纳内联元素和其他元素</li></ul></li></ul></li><li>行内元素（inline-level）<ul><li>行内元素(内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。</li><li><code>&lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;del&gt; &lt;span&gt; &lt;s&gt; &lt;ins&gt; &lt;u&gt;</code></li><li>特点：<ul><li>和相邻行内元素在一行</li><li>高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效</li><li>默认宽度就是它本身内容的宽度</li><li>行内元素只能容纳文本或则其他行内元素</li></ul></li></ul></li><li>行内块标签（inline-level）<ul><li>在行内元素中有几个特殊的标签，可以对它们设置宽高和对齐属性</li><li><code>&lt;input/&gt; &lt;img/&gt; &lt;td&gt;</code></li><li>特点： <ul><li>和相邻行内元素在一行上，但是之间会有空白间隙</li><li>默认宽度就是它本省内容发宽度</li><li>高度、行高、外边距以及内边距都可以控制</li></ul></li></ul></li><li>标签显示模式转换<ul><li>块转行内：<code>display:inline</code></li><li>行内转块：<code>display:block</code></li><li>块、行内元素转换为行内块： <code>display:inline-block</code></li></ul></li></ol><h2 id="三、CSS复合选择器"><a href="#三、CSS复合选择器" class="headerlink" title="三、CSS复合选择器"></a>三、CSS复合选择器</h2><ol><li>复合选择器：复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。</li><li>交集选择器<ul><li>是并且的意思，即……又…..关系<code>p.class</code></li></ul></li><li>并集选择器<ul><li>减少重读工作，有需要相同样式的标签：<code>div,p,.btn</code></li></ul></li><li>后代选择器<ul><li>后代选择器又称为包选择器。用来选择元素或元素组的后代。</li><li>把外层标签写在内层标签前面，中间以<code>空格</code>隔开。</li><li><code>div p</code> 选择div下面的p标签</li></ul></li><li>子元素选择器<ul><li>只能选择作为某个元素子元素的元素，其写法为父标签在前。子标签在后，中间以<code>&gt;</code>号隔开</li></ul></li><li>属性选择器<ul><li>属性选择由中括号来表示，如<code>a[title]</code>表示选中a标签中带有title属性的标签</li></ul><table><thead><tr><th align="center">选择器</th><th align="center">示例</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">E[attr]****</td><td align="center">a[title]</td><td align="center">存在attr属性即可</td></tr><tr><td align="center">E[attr=value]***</td><td align="center">input[type=text]</td><td align="center">存在attr属性，且attr属性值等于value</td></tr><tr><td align="center">E[attr*=value]***</td><td align="center">div[class*=jd]</td><td align="center">属性值中包含value字符，并且在任意位置</td></tr><tr><td align="center">E[attr^=value]***</td><td align="center">div[class^=at]</td><td align="center">属性值中包含value字符，并且在开始位置</td></tr><tr><td align="center">E[attr$=value]***</td><td align="center">div[class$=24]</td><td align="center">属性值中包含value字符并且在结束位置</td></tr></tbody></table></li><li>伪元素选择器<ul><li>E::first-letter 文本的第一个单词或则第一个字</li><li>E::first_line  文本第一行</li><li>E:：selection 可该表选中文本的样式</li><li>E::before 在E元素<code>内部</code>的开始位置创建一个元素，该元素为行内元素。且必须结合content属性使用</li><li>E::after 在E元素<code>内部</code>的结束位置创建一个元素<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="selector-class">.bottom</span><span class="selector-pseudo">::before</span>{</span><br><span class="line"><span class="attribute">content</span>: <span class="string">"加在前面"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.bottom</span><span class="selector-pseudo">::after</span>{</span><br><span class="line"><span class="attribute">content</span>: <span class="string">"加在结尾"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="四、CSS背景（background）"><a href="#四、CSS背景（background）" class="headerlink" title="四、CSS背景（background）"></a>四、CSS背景（background）</h2><ol><li><p>背景图片位置（image）</p><ul><li>background-reapet 图片是否平铺</li><li>background-position 可以设置图片的位置<code>left top center right</code>，也可为数字，百分比，两个数字前一个表示X,后一个表示Y</li></ul></li><li><p>背景附着：设置或检索背景图片随对象内容固定还是滚动的</p><ul><li>background-attachment:scroll||fixed</li><li>scroll:背景图像随对象内容滚动</li><li>fixed:背景图像固定</li></ul></li><li><p>背景简写(类似font)</p><ul><li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">div</span>{</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#008000</span> <span class="built_in">url</span>(<span class="string">./img/time.png</span>) no-repeat fixed center center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>背景透明（CSS3）</p><ul><li>background : rgba(0,0,0,0.5)</li></ul></li><li><p>背景缩放（CSS3）background-size</p><ul><li>background-size用于设置背景图片的尺寸，和设置img的大小一样。尽量只改一个值，防止缩放失真。</li><li>可以设置长度单位px或者百分比</li><li>设置<code>cover</code>时自动调整缩放比例，保证图片始终填满背景区域，如有溢出部分则会被<code>隐藏</code>。</li><li>设置为<code>contain</code>会自动调整缩放比例，保证图片始终<code>完整</code>的显示在背景区域。</li></ul></li><li><p>多背景（CSS3）</p><ul><li>以逗号隔开可设置多张背景，可用于自适应布局</li><li>为了避免背景色将图像覆盖，通常设置背景色在最后一组</li><li>多重阴影也可以设置：<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: -<span class="number">2px</span> -<span class="number">2px</span> <span class="number">3px</span> white,<span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#091921</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css基础学习笔记01</title>
      <link href="/2022/03/15/Css%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>/2022/03/15/Css%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础用法的相关标签01——字体，选择器，外观属性"><a href="#CSS基础用法的相关标签01——字体，选择器，外观属性" class="headerlink" title="CSS基础用法的相关标签01——字体，选择器，外观属性"></a>CSS基础用法的相关标签01——字体，选择器，外观属性</h1><h2 id="一、CSS字体"><a href="#一、CSS字体" class="headerlink" title="一、CSS字体"></a>一、CSS字体</h2><ol><li><p>font-size：(字号大小)</p><ul><li>相对长度单位：</li></ul><table><thead><tr><th align="center">相对长度单位</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">em</td><td align="center">相对于当前对象内文本的字体尺寸</td></tr><tr><td align="center">px</td><td align="center">像素，最常用的单位</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>绝对长度单位 <table><thead><tr><th align="center">绝对长度单位</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">in</td><td align="center">英寸</td></tr><tr><td align="center">cm</td><td align="center">厘米</td></tr><tr><td align="center">mm</td><td align="center">毫米</td></tr><tr><td align="center">pt</td><td align="center">点</td></tr></tbody></table></li></ul></li><li><p>font-family:(字体)</p><ul><li><code>中文</code>：微软雅黑,<code>英文</code>:Microsoft yaHei,<code>Unicode编码</code>：\5FAE\8F6F\96C5\9ED1</li><li>多个字体样式之间用英文逗号隔开</li><li>尽量使用偶数字号</li></ul></li><li><p>font-weight:(字体加粗)</p><ul><li>normal:正常字体，相当于数值中的400</li><li>bold：粗体，相当于数值中的700</li><li>bolder：定义比继承值更重的值</li><li>lighter：定义比继承制更轻的值</li></ul></li><li><p>font-style:(字体风格)</p><ul><li>normal:指定文本样式为正常</li><li>italic: 指定文本样式为斜体 ，（标签<code>&lt;em&gt;&lt;/em&gt;</code>也可以使得文字倾斜）</li><li>oblique: 指定文本样式为倾斜，单纯倾斜文字</li></ul></li><li><p>font:(综合设置样式 <code>*</code>)</p><ul><li>选择器{font: font-style  font-weight  font-size/line-height font-family}</li><li>其中不需要的属性可以省略，但至少要保留font-size和font-family属性</li></ul></li></ol><h2 id="二、选择器"><a href="#二、选择器" class="headerlink" title="二、选择器"></a>二、选择器</h2><ol><li><p>类选择器</p><ul><li>标签中采用 <code>class="类名"</code></li><li>使用时候<code>.类名</code>即可选择该类 </li></ul></li><li><p>多类名选择器</p><ul><li>一个标签可以引用多个类</li></ul></li><li><p>ID选择器</p><ul><li>标签中采用<code>id=“id名称”</code>进行引用</li><li>使用<code>#id名称</code>进行申明</li></ul></li><li><p>类选择器和ID选择器的区别：类选择器可以重复使用，类似于人名，ID选择器只可使用一次。类似于身份证号。</p></li><li><p>通配符选择器：</p><ul><li><code>*</code>代表所有选择器</li></ul></li><li><p>伪类选择器：</p><ul><li><p>为了向某些选择器添加特殊效果</p></li><li><p>链接伪类选择器：</p><ul><li> :link  未访问的链接</li><li> :visited 已经访问的链接</li><li>:hover  鼠标移动到连接上</li><li>:active 选中的链接</li><li>注：在编写代码时同一个链接元素的状态设置必须按照以上伪类顺序进行。</li></ul></li><li><p>结构（位置）伪类选择器 （CSS3）</p><ul><li><p>:first-child 选择属于其父元素的首个子元素的指定选择器</p></li><li><p>:last-child  选择属于其父元素的最后一个子元素的指定选择器</p></li><li><p>:nth-child(n)  匹配其父元素的第N个子元素，不论元素的类型, <code>even</code>表示选择位置为奇数的孩子标签，<code>odd</code>表示选择位置为偶数的孩子标签。也可使用公式</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>n)</span><br><span class="line">{</span><br><span class="line"> <span class="attribute">background</span>: orange;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>:nth-last-child(n)  选择器匹配属于其元素的第N个子元素的每个元素，不论元素的类型，从最后一个元素开始计数。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child{</span><br><span class="line"> <span class="attribute">background</span>: green;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>{</span><br><span class="line"> <span class="attribute">background</span>: pink;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"> <span class="attribute">background</span>: skyblue;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"> <span class="attribute">background</span>: orange;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/CSS%2Fstruct.png" alt="样式效果"></p></li></ul></li><li><p>目标伪类选择器</p><ul><li>:target目标伪类选择器可用于选择当前活动的目标元素。</li></ul></li></ul></li></ol><h2 id="三、CSS外观属性"><a href="#三、CSS外观属性" class="headerlink" title="三、CSS外观属性"></a>三、CSS外观属性</h2><ol><li><p>color:颜色（用于定义文本的颜色，其取值方式有如下3种:）</p><ul><li>预定义的颜色值，如red , green , blue等。</li><li>十六进制，如#FFO000，#FF6600，#29D794等。十六进制是最常用的定义颜色的方</li><li>RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)</li><li>也可使用rgba设置颜色并调整透明度rgba(255,255,0,0.6),表示透明度为60%</li></ul></li><li><p>line-height:行间距离</p><ul><li>行与行之间的距离，即为字符的垂直间距，一般为行高。行间距一般比字号多7~8个像素就主够</li></ul></li><li><p>text-align:水平对齐方式</p><ul><li>left:内容左对齐</li><li>right：内同右对齐</li><li>center：内容居中对齐</li></ul></li><li><p>text-indent:首行缩进</p><ul><li>用于设置首行文本的缩进，其属性值可以为不同单位的数值、em字符宽度的倍数、或者对于浏览器窗口宽度的百分比%，允许负值，建议使用em作为设置单位。</li></ul></li><li><p>letter-spacing:字间距</p><ul><li>针对于中文，英文无效 </li></ul></li><li><p>word-spacing :单词间距</p><ul><li>针对于英文，中文无效</li></ul></li><li><p>text-shadow:文字阴影</p><ul><li>text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色</li><li>h-shadow: <code>必选</code>,水平阴影的位置</li><li>v-shadow: <code>必选</code>，垂直阴影的位置</li><li>blur: 可选，阴影的距离</li><li>color: 可选，阴影的颜色</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS域名解析</title>
      <link href="/2022/03/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/03/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS域名解析服务"><a href="#DNS域名解析服务" class="headerlink" title="DNS域名解析服务"></a>DNS域名解析服务</h1><h2 id="一、DNs服务概述"><a href="#一、DNs服务概述" class="headerlink" title="一、DNs服务概述"></a>一、DNs服务概述</h2><ol><li>DNS(Domain Name System)域名系统，在TCP/IP 网络中有非常重要的地位，能够提供域名与IP地址的解析服务。</li><li>DNS是一个分布式数据库，命名系统采用层次逻辑结构，如同一棵倒置的树，这个逻辑的树状结构称为域名空间。    - 由于DNS划分了域名空间，所以各机构可以使用自己的域名空间来创建DNS信息    - DNS域名空间中，树的最大深度不超过127层，数的每个结点的最大长度可存储63个字符</li><li>DNS根域下面是顶级域，也是Internet域名注册授权机构管理，共有3种类型的顶级域。<ul><li>组织域：采用三个字符代号，表示DNS域中所包含的组织的主要功能或活动<ul><li>.com为商业机构组织</li><li>.edu为教育机构组织</li><li>.gov为政府机构组织</li><li>.mil为军事机构组织</li></ul></li><li>地址域：采用两个字符的国家或地区代号<ul><li>cn为中国</li><li>kr为韩国</li><li>us为美国</li></ul></li><li>单向域 ：这是一个特殊域，名字为in-addr.arpa，用于将IP地址映射到名字（反向查询）</li></ul></li><li>区（Zone）,资源记录<ul><li>区是DNS名称空间的一部分，其包含了一组存储在DNS服务器上的资源记录。</li><li>使用区的概念，DNS服务器回答关于自己区中主机的查询，每个区都有自己的授权服务器</li></ul></li><li>主域名服务器和辅助域名服务器<ul><li>当区的域名服务器启动时，它与该区的主控服务器进行连接并启动一次区传输，区辅助服务器定期与区主控制服务器通信，查看区数据是否改变。如果改变了，它就启动一次数据更新传输。</li><li>每个区必须有主服务器，另外每个区至少有一台辅组服务器，否则如果该区的主服务器崩溃了，就无法解析该区的名称。</li></ul></li><li>辅助服务器的优点：<ul><li><code>容错能力</code>：配置辅助服务器后，在该区主服务器崩溃的情况下客户仍能解析该区的名称。一般把主区的主服务器和区的辅助服务器安装在不同的子网上。</li><li><code>减少广域网链路的通信量</code>：如果某个去在远程有大量客户机，用户就可以在远程添加该区域的辅助服务器，并把远程的客户机配置成先查询这些服务器，这样就能防止远程客户机通过慢速链路通信来进行DNS查询。</li><li><code>减轻主服务器的负载</code>：辅助服务器能回答该区的查询，从而减少该区主服务器必须回答的查询次数。</li></ul></li></ol><h2 id="二、关于DNS的基本概念"><a href="#二、关于DNS的基本概念" class="headerlink" title="二、关于DNS的基本概念"></a>二、关于DNS的基本概念</h2><ol><li> <code>DNS服务器</code>：服务器程序的计算机，存储DNS数据信息。DNS服务器会尝试解析客户机的查询请求。</li><li><code>DNS缓存</code>： DNS服务器在解析客户请求时，如果本地没有该DNS 信息，则可以查询其他DNS服务器，当其他域名服务器返回查询结果时，该DNS服务器会将结果记录在本地缓存中，称为DNS缓存。当下一次客户机提交相同请求时，DNS服务器能够直接使用缓存中的DNS信息进行解析。</li><li><code>DNS查询方式</code>：递归查询和迭代查询 <ul><li>递归查询：一次沟通完。递归查询是一种DNS服务器的查询模式，在该模式下DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</li><li>迭代查询：当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</li><li>注释：一般情况下，从PC客户端到本地DNS服务器是属于递归查询。而DNS服务器之间的交互查询称为迭代。</li></ul></li><li>正向解析与反向解析<ul><li>正向解析：域名到IP地址1解析过程。</li><li>反向解析：从IP地址到域名的解析过程，反向解析的作用为服务器的身份验证。</li></ul></li></ol><h2 id="三、资源记录"><a href="#三、资源记录" class="headerlink" title="三、资源记录"></a>三、资源记录</h2><ol><li>SOA 资源记录<ul><li>每个区在区的开始处都包含了一个起始授权记录(Start of Authority Record)，称为SOA记录。</li><li>SOA记录定义了域的全局参数，进行整个域的管理配置。一个区域文件只允许存唯一的SOA记录。</li></ul></li><li>NS 资源记录<ul><li>NS(Name Server) 记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。</li><li>每个区在区根处直到包含一个NS 记录</li></ul></li><li>A 资源记录<ul><li>地址(A)资源记录把FQDN映射到IP地址。因为有此记录，所以DNS服务器能解析FQDN域名对应的IP地址。</li></ul></li><li>PTR 资源记录<ul><li>相对于A资源记录，针对（PTR）记录把IP记录地址映射到FQDN。用于反向查询，通过IP地址找到域名。</li></ul></li><li>CNAME 资源记录<ul><li>别名记录（CNAME）资源记录创建特定FQDN的别名。用户可以使用CNAME记录来隐藏用户网络的实现细节，使连接的客户机无法直到真正的域名。</li></ul></li><li>MX 资源记录<ul><li>邮件交换（MX）资源记录，为DNS域名指定邮件交换服务。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github基础使用</title>
      <link href="/2022/03/08/github%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/08/github%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="github仓库使用"><a href="#github仓库使用" class="headerlink" title="github仓库使用"></a>github仓库使用</h1><h2 id="一、仓库建立"><a href="#一、仓库建立" class="headerlink" title="一、仓库建立"></a>一、仓库建立</h2><ol><li><p>在登录后进入仓库创建界面，填写仓库名称和描述即可创建仓库<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fgithub.png" alt="创建仓库"></p></li><li><p>仓库主页的功能介绍</p><ul><li>修改项目介绍，点击edit</li><li>查看仓库名称，一般情况仓库名称即为项目名称</li><li><code>Create new file</code>创建文件、<code>upload files</code>上传文件、<code>Find file</code>搜索仓库文件</li><li><code>Clone or Download</code>直接下载或通过github克隆</li><li>点击事务卡片<code>issu</code>可以新建issu,在发现代码bug,但是目前没有成型代码需要讨论时使用。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fgithub2.png" alt="项目界面"></li></ul></li></ol><h2 id="二、仓库管理"><a href="#二、仓库管理" class="headerlink" title="二、仓库管理"></a>二、仓库管理</h2><ol><li><p>新建文件</p><ul><li>点击<code>create new file</code>新建文件</li><li>进入后填写文件名称和文件内容</li><li>填写每次提交的目的和描述，为了方便其他开发者知道本次添加或修改的原因</li><li>点击<code>Commit new file</code> 即可提交</li></ul></li><li><p>编辑文件</p><ul><li>点击<code>文件名</code>到文件详情页可以做删除和修改动作</li><li>点击<code>文件描述</code>可以查看该文件提交的详细信息</li><li>点击<code>修改</code>符号进行修改文件</li><li>填写修改的目的和具体描述</li><li>点击<code>Commit new file</code> 即可提交</li></ul></li><li><p>删除文件</p><ul><li>点击<code>文件名</code>进入文件详情页</li><li>点击<code>删除</code>按钮删除文件</li><li>填写修改的目的和具体描述</li><li>点击<code>Commit new file</code> 即可提交</li><li>删除后可点击<code>commits</code>查看已经删除的文件</li></ul></li><li><p>上传文件</p><ul><li>点击<code>upload files</code>即可选择上传文件</li><li>填写修改的目的和具体描述</li><li>点击<code>Commit new file</code> 即可提交  </li></ul></li><li><p>搜索仓库文件</p><ul><li>点击<code>Go to file</code>可以搜索文件</li><li>同时支持快捷键（t/T）</li></ul></li></ol><h2 id="三、Github-issues"><a href="#三、Github-issues" class="headerlink" title="三、Github issues"></a>三、Github issues</h2><ol><li>作用：发现代码bug，但是目前没有成型代码，需要讨论时用；或者使用开源项目出现问题时使用。</li><li>提出方与代码拥有着均有关闭issue的权限</li><li>pull request<ul><li>fork项目</li><li>修改自己仓库的项目代码</li><li>新建pull request</li><li>等待作者审核并合并修改</li></ul></li></ol><h2 id="四、github-从本地上传文件"><a href="#四、github-从本地上传文件" class="headerlink" title="四、github 从本地上传文件"></a>四、github 从本地上传文件</h2><ol><li>上传文件到主分支，<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init //初始化仓库</span><br><span class="line">git add . //添加文件到本地仓库</span><br><span class="line">git branch -M main //选择main分支，可以改名上传其它分支</span><br><span class="line">git commit -m "first commit" //添加文件描述信息</span><br><span class="line">git remote add origin https://github.com/xxx/xxxx.git //链接远程仓库，创建主分支</span><br><span class="line">git pull origin main // 把本地仓库的变化连接到远程仓库主分支</span><br><span class="line">git push -u origin main //此处上传的是main分支</span><br></pre></td></tr></tbody></table></figure></li><li>若上传失败，可以使用强制上传，上传后会完全覆盖代码，谨慎使用<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin main //强制push就成功了。</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="五、Git安装使用"><a href="#五、Git安装使用" class="headerlink" title="五、Git安装使用"></a>五、Git安装使用</h2><ol><li><p>下载并安装</p><ul><li>下载Git: <a href="https://www.git-scm.com/download/win">https://www.git-scm.com/download/win</a></li><li>点击安装</li></ul></li><li><p>Git工作区域</p><ul><li><p>工作区（Working Directory）、暂存区、Git仓库（Git Repsitory）<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fgit.png" alt="Git工作区域示意图"></p></li><li><p>git的基本流程命令</p><p><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/JS%2Fgit2.png" alt="git基本流程"></p></li></ul></li><li><p>命令行控制</p><ul><li><code>git status</code> 查看当前文件的状况</li><li><code>git add</code> 将文件从工作区提交到暂存区</li><li><code>git commit -m "提交描述"</code> 填写描述，文件从暂存区提交到本地仓库</li><li><code>git push</code> 将本地仓库文件提交到远程仓库</li><li><code>git init</code> 初始化仓库</li><li><code>git config  --global user.name 'username' </code> 初始化填写用户名</li><li><code>git config  --global user.email 'email@qq.com'</code> 初始化填写邮箱 这会用于github主页显示提交用户</li><li><code>git clone 仓库地址</code> 从远程仓库克隆到本地</li><li><code>git config --list</code> 检查自己的设置</li></ul></li></ol><h2 id="六、利用github搭建个人网站"><a href="#六、利用github搭建个人网站" class="headerlink" title="六、利用github搭建个人网站"></a>六、利用github搭建个人网站</h2><ol><li>访问https://个人用户名.github.io</li><li>搭建个人网站步骤<ul><li> 创建个人站点</li><li>新建仓库（仓库名必须是【用户名.github.io】）</li><li>在仓库下新建index.html文件即为网站主页</li></ul></li></ol><h2 id="七、git仓库的基本命令"><a href="#七、git仓库的基本命令" class="headerlink" title="七、git仓库的基本命令"></a>七、git仓库的基本命令</h2><ol><li>git项目搭建<ul><li>本地创库创建 <code>git init</code></li><li>从远程仓库获取项目<code>git clone url</code></li></ul></li><li>正常工作流<ul><li><code>git status</code>  查看仓库文件状态</li><li><code>git add .</code> 添加文件到暂存区</li><li><code>git commit -m "描述信息"</code>  提交暂存区的内容到本地仓库 -m 提交信息</li><li><code>git push</code> 提交到远程 ，<code>git push origin master</code> 指定切换到master分支提交</li></ul></li><li><strong>忽略文件：</strong>有些文件不需要纳入到版本控制中，比如数据库文件，临时文件，设计文件<ul><li>在主目录下建立“.gitignore”文件，此文件有如下规则<ul><li>忽略文件中的空行或以井号（#）开始的行会被忽略。</li><li>可以使用Linux通配符。例如（*）代表任意多个字符，问好（？）代表一个字符，方括号（[abc]）代表可选字符规范，大括号 （{string1，string2,…}）代表可选字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称最前面有一个路径分割符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面一个路径分割符（/），表示忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都被忽略）<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt    <span class="comment">#忽略所有 .txt 结尾的文件，这样的话上传就不会被选中</span></span><br><span class="line">!lib.txt  <span class="comment">#结合前面描述，但 lib.txt 除外，不被忽略</span></span><br><span class="line">/temp   <span class="comment"># 仅忽略项目根目录下的TODO文件，不包括其他目录temp文件</span></span><br><span class="line">build/   <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/* .txt  <span class="comment"># 会忽略 doc/note.txt 但不会忽略 doc/server/arch.txt</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li>生成公钥实现免密码登录<ul><li>在电脑 <code>C/用户/admin/.ssh</code>目录下</li><li>使用命令 <code>ssh-keygen -t rsa</code> 生成公钥</li><li>把公钥粘贴到远程代码仓库的对应位置</li></ul></li></ol><h2 id="八、Git分支"><a href="#八、Git分支" class="headerlink" title="八、Git分支"></a>八、Git分支</h2><ol><li>git分支中的常用命令<ul><li>列出所有的本地分支 <code>git branch</code></li><li>了出所有的远程分支 <code>git branch -r</code></li><li>新建一个分支，但仍保留在当前分支 <code>git branch [branch-name]</code> </li><li>新建一个分支，并切换到新建的分支上 <code>git checkout -b [branch] </code></li><li>合并指定分支到当前分支 <code>git merge [branch]</code></li><li>删除分支 <code>git branch -d [branch-name]</code></li><li>删除远程分支 <code>git push origin --delete [branch-name]</code>或者<code>git branch -dr [remote/branch]</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解浏览器</title>
      <link href="/2022/03/07/%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2022/03/07/%E4%BA%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="了解浏览器"><a href="#了解浏览器" class="headerlink" title="了解浏览器"></a>了解浏览器</h1><h2 id="一、浏览器的Layout-Tree和DOM-Tree"><a href="#一、浏览器的Layout-Tree和DOM-Tree" class="headerlink" title="一、浏览器的Layout Tree和DOM Tree"></a>一、浏览器的Layout Tree和DOM Tree</h2><ol><li>layout布局阶段：主线程通过遍历DOM 和计算好的样式来生成Layout Tree。</li><li>Layout Tree 上的每个结点都记录了x,y坐标和边框尺寸。</li><li>DOM Tree和Layout Tree并不是一一对应的，使用伪类控制的元素不会出现在DOM Tree结点中，只会出现在Layout Tree 结点中。这也是JS无法控制伪类的原因。设置了display:none的元素不会出现在Layout Tree中，只会出现在DOM Tree中。</li><li>Layout Tree和最后显示在屏幕上的结点是一致的</li></ol><h2 id="二、浏览器渲染流程"><a href="#二、浏览器渲染流程" class="headerlink" title="二、浏览器渲染流程"></a>二、浏览器渲染流程</h2><ol><li>主线程，合成线程，栅格线程<ul><li>主线程：DOM，style,layout,paint,layer</li><li>合成器线程：tiles ,   frame</li><li>栅格线程：raster, draw quads</li></ul></li><li>重排和重绘</li><li>布局绘制和JS都是在主线程运行的，当在一的时间内布局和绘制结束后还有剩余时间，JS就可以获得主线程控制权，若JS执行时间过长会导致没有及时归还主线程，主线程无法及时渲染下一帧动画，从而造成页面卡顿。<ul><li>优化动画：<code>requestAnimationFrame()</code> ,这个方法会在每一帧被调用。把JS运行任务分成更小的任务快，在每一帧的时间用完前暂停JS执行，归还主线程。在下一帧开始时主线程就可以按时执行布局和绘制。</li><li>Transform实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中。</li></ul></li></ol><h2 id="三、持续补充中……"><a href="#三、持续补充中……" class="headerlink" title="三、持续补充中……"></a>三、持续补充中……</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2022/03/06/HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/03/06/HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h1><h2 id="一、形象理解HTTP协议"><a href="#一、形象理解HTTP协议" class="headerlink" title="一、形象理解HTTP协议"></a>一、形象理解HTTP协议</h2><ol><li><p>什么是HTTP协议：HTTP协议即按一定规则，向服务器要数据，或发送数据。而服务器则按一定规则回应数据。</p></li><li><p>HTTP协议的工作流程</p><ul><li>原始状态客户端与服务器没有关系</li><li>建立连接，发送请求</li><li>沿着连接，返回响应信息</li><li>断开连接，两者再次没有关系</li></ul></li><li><p>HTTP请求信息和响应信息的格式</p><ul><li>请求：请求行、请求头信息、请求主体信息<ul><li>请求行：请求方法、请求路径、所用协议<ul><li>请求方法：GET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS</li><li>请求路径：URL的一部分</li><li>所用协议版本：一般是HTTP/1.1</li></ul></li><li>请求头信息</li><li>请求主体信息</li></ul></li><li>响应：响应行、响应头信息、响应主体信息<ul><li>响应行： 协议版本、状态码、状态文字</li><li>响应头信息：<code>content-type</code> , <code>content-length</code>等</li><li>响应主体</li></ul></li></ul></li><li><p>请求方法虽然是HTTP协议里面规定的，但web server未必允许或支持这些方法</p><ul><li>HEAD：和GET基本一致，只是返回的内容不同。比如我们只是想要确认一个内容是否还正常存在，不需要返回内容本身，这时可以使用HEAD</li><li>TRACE：使用代理上网，比如用代理访问new.163.com,想要看看代理有没有修改HTTP 请求，可以使用TRACE来测试一下，163.com的服务器就会把最后收到的请求发送回来。</li><li>OPTIONS：返回服务器可用的请求方法</li></ul></li><li><p>状态文字与状态码</p><table><thead><tr><th align="center">状态码</th><th align="center">作用</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息提示</td><td align="center">通告信息，可能还需要进一步交互</td></tr><tr><td align="center">2XX</td><td align="center">成功</td><td align="center">成功完成客户端请求的操作，并进行响应</td></tr><tr><td align="center">3XX</td><td align="center">重定向</td><td align="center">表示资源已移走，需要向新URL发送请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误</td><td align="center">由于客户端请求错误，无法成功响应</td></tr><tr><td align="center">5XX</td><td align="center">服务端错误</td><td align="center">由于服务端错误，无法成功响应</td></tr></tbody></table><ul><li><p>200：服务器成功返回网页</p></li><li><p>301/2：永久/临时重定向</p></li><li><p>307：重定向中还保持原来的请求数据 （POST方法）</p></li><li><p>304 Not Modified 未修改</p></li><li><p>失败的状态码</p><ul><li>404——请求的网页不存在</li><li>503——服务器暂时不可用</li><li>500——服务器内部错误</li></ul></li></ul></li></ol><h2 id="二、HTTP协议防盗链"><a href="#二、HTTP协议防盗链" class="headerlink" title="二、HTTP协议防盗链"></a>二、HTTP协议防盗链</h2><ol><li>当在网页中引用站外的图片时，可能会遇到无法访问的情况。</li><li>在网站的统计结果统计用户从何而来</li><li>在HTTP协议中，头信息有一个重要的选项:referer<ul><li>referer：代表网页的来源即上一页的地址</li><li>如果直接在浏览器上输入网址进入则没有referer选项</li></ul></li><li>如何配置apache服务器，用于图片防盗链<ul><li>在web服务器层面，根据http协议referer头信息来判断如果来自站外，则统一重写到一个很小的防盗链提醒图片上去。<ul><li>打开apache重写模块mode_rewrite</li><li>在需要防盗链的网站或目录写.htaccess文件，并指定防盗链规则（[NC]表示不区分大小写）<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RewritrEngine</span> <span class="literal">On</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteCond</span></span> <span class="variable">%{REQUEST_FILENAME}</span> .*\.(jpg|jpeg|gif|png)<span class="meta"> [NC]   </span></span><br><span class="line"><span class="meta">RewriteCond %{HTTP_REFERER} !loaclhost [NC]</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteRule</span></span> .*  nofound.png  // 此处添加防盗链图片地址</span><br></pre></td></tr></tbody></table></figure></li><li>指定：分析referer信息，如果不是来自本站则重写</li><li>重写规则：是jpeg,jpg,gif,png图片时，referer头与localhost不匹配时重写</li><li>怎么重写：统一rewrite到另一个防盗链图片</li></ul></li></ul></li></ol><h2 id="三、HTTP协议与缓存控制"><a href="#三、HTTP协议与缓存控制" class="headerlink" title="三、HTTP协议与缓存控制"></a>三、HTTP协议与缓存控制</h2><ol><li>http协议缓存控制：<ul><li>现象：网页图片加载时，第一次请求时 200 ok，第二次请求时 304 Not Modified 未修改状态</li><li>原因：在网络上，有一些缓存服务器，另外浏览器自身也有缓存功能。当我们第一次访问某图片时，正常的加载图片，返回值为200。基于一个前提——图片不会经常改动，服务器在返回200的同时，还返回该图片的“签名”——ETag ，（签名可以理解为图片的“指纹”），当浏览器再次访问该图片时，去服务器校验“指纹”，如果图片没有变化，直接使用缓存中的图片，这样减轻了服务器负担。</li></ul></li><li>如果网站比较大，有N台缓存级服务器，那么这N台缓存服务器，如何处理主服务器上文件<ul><li>要不要缓存</li><li>缓存多久</li><li>缓存服务器与主服务器之间，有http协议，采用cache-control来控制</li></ul></li><li>缓存服务器、<ul><li>在主服务器上，打开apache的expires扩展，利用该扩展来控制图片，css,html等文件控制是否缓存及缓存生命周期。</li><li>在.htaccess中，具体语法如下<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ExpriesDefault</span> <span class="string">"&lt;base&gt; [plus] {&lt;num&gt; &lt;type&gt;}*"</span></span><br><span class="line"><span class="attribute">ExpriesByType</span> type/encoding <span class="string">"&lt;base&gt; [plus] {&lt;num&gt; &lt;type&gt;}*"</span></span><br></pre></td></tr></tbody></table></figure></li><li><code>ExpiresDefault</code> 是设置默认的缓存参数，<code>ExpiresByType</code> 是按照文件类型来设计独特的缓存参数</li><li>Base :基于哪个时间点来计算缓存有效期</li><li>Access/now:基于请求/响应的那一瞬间，比如从此瞬间到1个月之后</li><li>Modification：基于被请求文件的最后修改日期来计算，比如 被修改日期的一周内任然有效</li><li>Num：缓存时间的大小</li><li>Type：缓存时间的单位</li></ul></li><li>设置服务器不要有缓存信息<ul><li>比如有些个人信息不允许环迅服务器缓存，必到主服务器去请求。</li><li>Control-cache：no-store,must-revalidate ; //意味着不允许缓存，必须去主服务器验证。</li></ul></li></ol><h2 id="四、HTTP协议与内容压缩"><a href="#四、HTTP协议与内容压缩" class="headerlink" title="四、HTTP协议与内容压缩"></a>四、HTTP协议与内容压缩</h2><ol><li>Content-Length代表返回主体的长度，Content-Encoding:gzip 作用，Content-length是压缩后的长度<ul><li>为了提高网页在网络上的传输速度，服务器对主体信息进行压缩，如常见的gzip压缩，deflate压缩，compress压缩，以及google chrom的sdch压缩。</li><li>压缩的过程<ul><li>服务器返回压缩内容</li><li>客户端接收到压缩，再解压缩，最后渲染的界面</li></ul></li></ul></li><li>如何在apache服务器中启用压缩功能<ul><li>开启deflate模块，或gzip模块</li><li>在conf文件中写如下代码<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;ifmodule mode_deflate.c&gt;</span></span><br><span class="line">    <span class="attribute">DeflateCompressionLevel</span> <span class="number">6</span>  #压缩级别为<span class="number">6</span>，可选<span class="number">1</span>-<span class="number">9</span>，推荐为<span class="number">6</span></span><br><span class="line">    <span class="attribute">AddOutputFilterByTyoe</span> DEFLATE text/plain  # 压缩文本文件</span><br><span class="line">    <span class="attribute">AddOutputFilterByTyoe</span> DEFLATE text/html # 压缩html文件</span><br><span class="line">    <span class="attribute">AddOutputFilterByTyoe</span> DEFLATE text/xml # 压缩xml文件</span><br><span class="line"><span class="section">&lt;/ifmodule&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li><li>为什么要指定文件类型来压缩<ul><li>压缩需要耗CPU资源</li><li>图片/视频等文件，压缩效果不好</li><li>一般压缩文本格式</li></ul></li><li>服务器如何知道浏览器是否支持gzip的<ul><li>客户端允许发一个Accept-Encoding头信息与服务器协商</li></ul></li></ol><h2 id="五、分块传输与反向ajax"><a href="#五、分块传输与反向ajax" class="headerlink" title="五、分块传输与反向ajax"></a>五、分块传输与反向ajax</h2><ol><li>http协议与持久i按揭+分块传输——&gt;反向ajax<ul><li>反向ajax又叫comt，server push，服务器堆技术</li><li>应用范围：网页聊天服务器、google mail网页聊天</li><li>原理：一般而言，HTTP协议特点，连接&lt;——&gt;断开</li><li>具体断开时间：服务器响应content-length，收到指定length长度内容时断开连接</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络08——网络安全基础</title>
      <link href="/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C08%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C08%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——网络安全基础"><a href="#计算机网络——网络安全基础" class="headerlink" title="计算机网络——网络安全基础"></a>计算机网络——网络安全基础</h1><h2 id="一、网络安全概述"><a href="#一、网络安全概述" class="headerlink" title="一、网络安全概述"></a>一、网络安全概述</h2><ol><li>网络安全通信所需要的基本属性：<ul><li>机密性</li><li>消息完整性</li><li>可访问与可用性</li><li>身份认证</li></ul></li><li>网络安全威胁<ul><li>窃听</li><li>插入</li><li>假冒</li><li>劫持</li><li>拒绝服务<code>DoS</code>和分布式拒绝服务<code>DDoS</code></li><li>映射</li><li>嗅探</li><li>IP欺骗</li></ul></li></ol><h2 id="二、数据加密"><a href="#二、数据加密" class="headerlink" title="二、数据加密"></a>二、数据加密</h2><ol><li>数据加密<ul><li>明文：未加密的消息</li><li>密文：被加密的消息</li><li>伪装消息以隐藏消息的过程，即明文转变为密文的过程</li><li>解密：密文转变为明文的过程</li></ul></li><li>传统加密方式<ul><li>替代密码：用密文字母代替明文字母。移位密码加密函数： <table><tbody><tr><td bgcolor="#FF7F50">E<sub>k</sub>(M)=(M+k)mod q</td></tr></tbody></table></li><li>解密函数： <table><tbody><tr><td bgcolor="#FF7F50">D<sub>k</sub>(C)=(K+k)mod q</td></tr></tbody></table></li><li>换位密码：根据一定的规则重新排列明文</li><li>q：字母表长度， k：移动位数，M：明文所处位置。</li></ul></li><li>现代密码分类<ul><li>对称密钥加密：加密密钥和解密密钥相同（密钥保密）</li><li>非对称密钥加密：加密密钥和解密密钥不同（公钥和私钥）</li></ul></li><li>对称密钥密码分类：<ul><li>分组密码：DES、AES、IDEA等<ul><li>DES：56位密钥，54位分组</li><li>三重DES：使用两个密钥（共112位），执行三次DES算法</li><li>AES：分组128位，密匙128/192/256位</li><li>IDEA：分组64位，密钥128位</li></ul></li><li>流密码</li></ul></li><li>非对称/公开密钥加密<ul><li>密钥成对使用，其中一个用于加密，另一个用于解密，且加密密钥可以公开，也称公开密钥加密。</li><li>典型的公钥算法：Diffe-Hellman算法、RSA算法<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Frsa.png" alt="RSA算法"></li></ul></li></ol><h2 id="三、-消息完整性与数据签名"><a href="#三、-消息完整性与数据签名" class="headerlink" title="三、 消息完整性与数据签名"></a>三、 消息完整性与数据签名</h2><ol><li>消息完整性检测方法<ul><li>密码散列函数<ul><li>特性：定向输出、单向性（无法根据散列值逆推报文）、抗碰撞性（无法找到具有相同散列值的两个报文）</li><li>典型散列函数：<code>MD5</code>:128位散列值，<code>SHA-1</code>:160位散列值</li></ul></li></ul></li><li>报文认证<ul><li>报文认证是使消息的接收者能够检验收到的消息是否是真是的认证方法。来源真是、未被篡改。</li><li>报文摘要（数字指纹）</li><li>报文认证方法：<ul><li>简报报文验证：仅使用报文摘要，无法验证来源真实性</li><li>报文认证码：使用共享认证密匙，但无法防止接收方篡改</li></ul></li></ul></li><li>数字签名<ul><li>身份认证、数据完整性、不可否认性</li><li>简单数字签名：直接对报文签名</li><li>签名报文摘要</li></ul></li></ol><h2 id="四、身份认证"><a href="#四、身份认证" class="headerlink" title="四、身份认证"></a>四、身份认证</h2><ol><li>身份认证<ul><li>口令：会被窃听</li><li>加密口令：可能遭受回放（重放）攻击</li><li>加密一次性随机数：可能遭受中间人攻击</li></ul></li></ol><h2 id="五、密钥分发中心与证书认证"><a href="#五、密钥分发中心与证书认证" class="headerlink" title="五、密钥分发中心与证书认证"></a>五、密钥分发中心与证书认证</h2><ol><li>密钥分发中心<ul><li>基于KDC的密钥生成和分发<ul><li>通信发起方生成密钥，KDC进行分发</li><li>KDC生成并分发密钥</li></ul></li></ul></li><li>证书认证机构<ul><li>认证中心CA：将公钥与特定的实体绑定<ul><li>认证一个实体的真实身份</li><li>为实体颁发数字证书（实体身份和公钥绑定）</li></ul></li></ul></li></ol><h2 id="六、防火墙与入侵检测系统"><a href="#六、防火墙与入侵检测系统" class="headerlink" title="六、防火墙与入侵检测系统"></a>六、防火墙与入侵检测系统</h2><ol><li>防火墙的基本概念<ul><li>防火墙：能够隔离组织内部网络与公共互联网，允许某些分组通过，而阻止其他分组进入或离开内部网络的软件、硬件或者软件硬件结合的一种措施。</li><li>前提：从外部到内部和从内部到外部的所有流量都经过防火墙</li></ul></li><li>防火墙分类<ul><li>无状态分组过滤器：基于特定的规则对分组是通过还是丢弃进行决策。使用访问控制列表（ACL）实现防火墙规则。</li><li>有状态分组过滤器：跟踪每个TCP建立连接、拆除，根据状态确定是否允许分组通过。</li><li>应用网关：鉴别用户身份或针对授权用户开放特定服务。</li></ul></li><li>入侵检测系统IDS<ul><li>入侵检测系统（IDS）是当观察到潜在的恶意流量时，能够产生警告的设备或系统。</li></ul></li></ol><h2 id="七、网络安全协议"><a href="#七、网络安全协议" class="headerlink" title="七、网络安全协议"></a>七、网络安全协议</h2><ol><li>安全电子邮件<ul><li>电子邮件安全需求<ul><li>机密性</li><li>完整性</li><li>身份认证性</li><li>抗抵赖性</li></ul></li><li>安全电子邮件标准：<code>PGP</code></li></ul></li><li>安全套接字层SSL<ul><li>SSL是介于应用层和传输层之间的安全协议</li><li>SSL协议栈 <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2FSSL6.png" alt="SSL协议栈"></li><li>SSL握手过程<ul><li>协商密码组</li><li>生成密钥</li><li>服务器/客户认证与鉴别</li></ul></li></ul></li><li>虚拟专用网VPN和IP安全协议IPSec<ul><li>VPN：建立在公共网络上的安全通道，实现远程用户、分支机构、业务伙伴等与机构总部网路的安全连接，从而建立针对特定组织机构的专用网路。</li><li>关键技术：隧道技术，如IPSec</li><li>典型的网路层安全协议——IPSec<ul><li>提供机密性、身份鉴别、数据完整性验证和防重放攻击服务。</li><li>体系结构：认证头AH协议、封装安全负荷ESP协议</li><li>运行模式：<code>传输模式</code>（AH传输模式、ESP传输模式）、<code>隧道模式</code>（AH隧道模式、ESP隧道模式）</li></ul></li></ul></li></ol><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><ol><li>网络安全基本属性</li><li>典型数据加密算法</li><li>消息完整性、数字签名以及身份认证原理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络07——无线与移动网络</title>
      <link href="/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C07%E2%80%94%E2%80%94%E6%97%A0%E7%BA%BF%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C07%E2%80%94%E2%80%94%E6%97%A0%E7%BA%BF%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——无线与移动网络"><a href="#计算机网络——无线与移动网络" class="headerlink" title="计算机网络——无线与移动网络"></a>计算机网络——无线与移动网络</h1><h2 id="一、无线网络"><a href="#一、无线网络" class="headerlink" title="一、无线网络"></a>一、无线网络</h2><ol><li>无线网络基本结构<ul><li>无线主机</li><li>无线链路</li><li><code>基站</code></li><li>网路基础设施</li><li>自组织网络（Ad Hoc网络）</li></ul></li><li>无线链路与无线网络特征<ul><li>无线链路与有线链路的区别<ul><li>信号强度衰减</li><li>干扰</li><li>多径传播</li><li>隐藏终端</li></ul></li></ul></li></ol><h2 id="二、-移动网络"><a href="#二、-移动网络" class="headerlink" title="二、 移动网络"></a>二、 移动网络</h2><ol><li><p>移动网络的基本原理</p><ul><li>不同的移动性需求</li><li>网络层地址保持不变的重要性</li><li>有线基础设施的支持</li></ul></li><li><p>寻址</p><ul><li>永久地址和转交地址<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fxunzhi.png" alt="永久地址和转交地址"></li></ul></li><li><p>移动结点的路由选择</p><ul><li>间接路由选择：由归属代理转发数据给外部地址</li><li>直接路由选择：由通信代理通过归属代理获得转交地址，直接发送到外部代理</li></ul></li></ol><h2 id="三、无线局域网IEEE-802-11"><a href="#三、无线局域网IEEE-802-11" class="headerlink" title="三、无线局域网IEEE 802.11"></a>三、无线局域网IEEE 802.11</h2><ol><li><p>IEEE 802.11体系结构</p><ul><li>基站AP</li><li>基本服务集BSS——AP发现：<ul><li>主动扫描探测帧</li><li>被动扫描信标帧</li></ul></li></ul></li><li><p>IEEE 802.11的MAC协议</p><ul><li>CSMA/CA——带碰撞避免的CSMA:CSMA/AC通过RTS和CTS帧交换，可以实现信道的预约占用，避免数据帧传输过程中的冲突。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2FIEEE%20802.png" alt="带碰撞避免的CSMA3    t"></li></ul></li><li><p>IEEE 802.11帧</p><ul><li>IEEE 802.11的帧类型：控制帧、数据帧和管理帧</li><li>MAC首部：长度30字节，包括4个地址字段（主要使用目的地址、源地址、AP地址）</li></ul></li></ol><h2 id="四、蜂窝数据"><a href="#四、蜂窝数据" class="headerlink" title="四、蜂窝数据"></a>四、蜂窝数据</h2><ol><li>蜂窝网络体系结构<ul><li>基站系统BSS:基站控制器、收发基站</li><li>移动交换中心MSC</li><li>网关MSC</li></ul></li><li>蜂窝网路中的移动性管路<ul><li>间接路由选择方法</li></ul></li><li>移动通信2G/3G/4G/5G网络<ul><li>2G网络：信令和语音信道都是数字式的</li><li>3G网络：无线通信与互联网等多媒体通道结合</li><li>4G网络：高效率数据业务，不同频段、不同业务环境间的无缝漫游</li><li>5G网络：超高容量、超可靠性、随时随地可接入性</li></ul></li></ol><h2 id="五、移动IP网络"><a href="#五、移动IP网络" class="headerlink" title="五、移动IP网络"></a>五、移动IP网络</h2><ol><li>代理发现<ul><li>代理通告：外部代理或归属代理使用一种现有路由器发现协议的扩展协议来通告其他服务。周期性的在所有连接的链路上广播一个类型字段为9（路由器发现）的ICMP报文。</li><li>代理请求：移动结点广播一个代理请求报文，该报文是一个类型值为10的ICMP 报文。收到该请求的代理将直接向该移动结点单播一个代理通告。</li></ul></li><li>向归属代理注册——移动结点和/或外部代理向一个移动结点的归属代理注册或注销COA所使用的协议。<ul><li>移动结点向外部代理发送一个移动IP注册报文</li><li>外部代理记录移动结点的永久IP地址，并发送注册请求给归属代理</li><li>归属代理接收注册请求并发送注册应答</li><li>外部代理接收注册应答，然后将其转发给移动结点</li></ul></li></ol><h2 id="六、其他典型无线网络简介"><a href="#六、其他典型无线网络简介" class="headerlink" title="六、其他典型无线网络简介"></a>六、其他典型无线网络简介</h2><ol><li>WinMax<ul><li>IEEE 802.16,城域网技术，传输距离更远，接入带宽更高</li></ul></li><li>蓝牙<ul><li>IEEE 802.15.1，小范围，低功率，低成本，自组织。</li></ul></li><li>ZigBee<ul><li>IEEE 802.15,4,低功率，地数据数率，低工作周期。 </li></ul></li></ol><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><ol><li>无线网络基本结构</li><li>移动网络基本原理</li><li>CSMA/CA</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 移动网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络06——物理层</title>
      <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C06%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C06%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——物理层"><a href="#计算机网络——物理层" class="headerlink" title="计算机网络——物理层"></a>计算机网络——物理层</h1><h2 id="一、数据通信基础"><a href="#一、数据通信基础" class="headerlink" title="一、数据通信基础"></a>一、数据通信基础</h2><ol><li><p>数据通信基本概念</p><ul><li>消息：人类能够感知的描述称为消息</li><li>信息：信息对事物状态或存在方式的不确定性表述，<code>信息是可以度量的</code>。</li><li>通信：本质就是在一点精确或近似地再生另一点的信息</li><li>通信系统：能够实现通信功能的各种技术、设备和方法的总体</li><li>信号：通信系统中，在传输通道中传播的<code>信息的载体</code></li><li>数据：对客观事物的性质状态以及相互关系等进行记载的<code>符号</code>及其组合</li><li>信道：信道是以传输介质为基础的信号通道</li></ul></li><li><p>数据通信系统模型</p><ul><li><p>通信系统的构成：信源、发送设备、信道、接收设备、信宿和噪声源等部分<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Ftongxinxitong.png" alt="通信系统的构成"></p></li><li><p>模拟通信</p><ul><li>模拟信号：信号的因变量是<code>连续</code>的</li></ul></li><li><p>数字通信</p><ul><li>数字信号：信号的因变量是<code>离散</code>的</li></ul></li><li><p>数据通信方式</p><ul><li>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）、</li><li>并行通信和串行通信</li><li>异步通信和同步通信</li></ul></li><li><p>数据通信系统的功能：</p><ul><li>信道利用</li><li>接口及信号产生</li><li>同步</li><li>差错检测和纠正</li><li>寻址与路由</li><li>网络管理</li><li>安全保证</li></ul></li></ul></li></ol><h2 id="二、物理介质"><a href="#二、物理介质" class="headerlink" title="二、物理介质"></a>二、物理介质</h2><ol><li>导引型传输介质<ul><li>架空明线：指平行且相互分离或绝缘的架空裸线线路，通常采用铜线或铝线等金属导线</li><li>双绞线： 两根相互绝缘的铜线并排绞合在一起，减少对相邻导线的电磁干扰（屏蔽双绞线<code>STP</code>、非屏蔽双绞<code>UTP</code>线）</li><li>同轴电缆：抗电磁干扰性能好。现在主要用于频带传输，如有线电视</li><li>光纤：基本原理是利用光的全反射。通信容量达、距离远、抗电磁干扰性好、保密性好。（<code>多模光纤</code>和<code>单模光纤</code>）</li></ul></li><li>非导引型传输介质<ul><li>地波传播：低频信号，沿地球表面传播</li><li>天波传播：较高频信号，利用电离层的反射传播</li><li>视线传播：高频信号，点对点直线传播，中继传输</li></ul></li></ol><h2 id="三、信道与信道容量"><a href="#三、信道与信道容量" class="headerlink" title="三、信道与信道容量 *"></a>三、信道与信道容量 <code>*</code></h2><ol><li>信道分类与模型<ul><li>狭义信道：信号传输介质</li><li>广义信道：信号传输介质和通信系统的一些变换装置</li><li>调制信道：信号从调制器的输出端传输到解调器的输入端经过的部分</li><li>编码信道：数字信号由编码器输出端传输到译码器输入端经过的部分<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fxindaohuafen.png" alt="信道的划分结构"></li></ul></li><li>信道传输特性<ul><li>恒参信道：各种有线信道和部分无线信道，传输特性变化小、缓慢，如微波视线传播链路和卫星链路等。<ul><li>对信号幅值产生固定的衰减</li><li>对信号输出产生固定的时延</li></ul></li><li>随参信道：传输特性随时间随机快速变化<ul><li>信号的传输衰减随时间随机变化</li><li>信号的传输时延随时间随机变化</li><li>存在多径传播现象</li></ul></li></ul></li><li>信道容量<ul><li>信道容量：指信道无差错传输信息的最大平均信息速率</li><li>连续信道容量<ul><li>（B-带宽、M-信号码源状态数、S/N-信噪比，s-信号功率，N-噪声功率）</li><li>理想无噪声信道的通信容量，奈奎斯特公式：<table><tbody><tr><td bgcolor="#FF7F50">C=2B log<sub>2</sub>M </td></tr></tbody></table></li><li>有噪声连续通信的信道容量，香农公式：<table><tbody><tr><td bgcolor="#FF7F50">C=B log<sub>2</sub>(1+S/N) </td></tr></tbody></table> </li></ul></li><li>离散信道容量 </li></ul></li></ol><h2 id="四、基带传输"><a href="#四、基带传输" class="headerlink" title="四、基带传输"></a>四、基带传输</h2><ol><li>基带传输基本概念<ul><li>模拟基带信号：模拟信号发出的原始电信号</li><li>数字基带信号：数字信号发出的基带信号</li><li>模拟基带信号可以通过信源编码转换为数字基带信号</li><li>基带传输：直接在信道中传送基带信号</li><li>数字基带传输系统<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fshuzijidai.png" alt="数字基带传输系统"></li><li>信号码型：<ul><li>单极不归零码</li><li>双极不归零码</li><li>单极归零码</li><li>双极归零码</li><li>差分码</li></ul></li><li>基带传输码型：<ul><li>AMI码——信号交替反转码：零电平编码二进制信息0，二进制信息1（传号）则交替用正电平和负电平表示</li><li>双相码——曼彻斯特码：正（高）电平跳到负（低)电平表示1，负电平跳到正电平表示0</li><li>米勒码</li><li>CMI码</li><li>nBmB码</li><li>nBmT码</li></ul></li><li>注释：双相码:1（正到负），0（负到正）  差分双相码：1（起始跳变），0（起始无跳变）<code>*</code></li></ul></li></ol><h2 id="五、频带传输"><a href="#五、频带传输" class="headerlink" title="五、频带传输 *"></a>五、频带传输 <code>*</code></h2><ol><li>频带传输的基本概念：<ul><li>数字调制：利用数字基带信号控制载波信号的某些特征参数，使载波信号的这些参数的变化反应数字基带信号的信息，进而将数字基带信号变换为数字通带信号的过程</li><li>键控法：利用两种不同的<code>幅值</code>、<code>频率</code>或<code>相位</code>来分别表示0或1</li></ul></li><li>频带传输中的三种调制方式<ul><li>二进制数字调制<ul><li>二进制幅移键控：载波信号幅值随基带信号变化</li><li>二进制频移键控：随基带信号变化而选择不同频率载波信号</li><li>二进制相移键控：载波信号相位随基带信号变化</li><li>二进制差分相移键控：基带信号控制相邻码元载波相对相位是否是变化，<code>1：</code>相对相位改变 ， <code>0：</code>相对相位不变</li></ul></li><li>多进制数字调制</li><li>正交幅值调制QAM</li></ul></li></ol><h2 id="六、物理层接口规程"><a href="#六、物理层接口规程" class="headerlink" title="六、物理层接口规程"></a>六、物理层接口规程</h2><ol><li>物理层接口概述<ul><li>物理层接口的四大特性：机械特性、电气特性、功能特性、规程特性<ul><li>机械特性：通信实体间硬件连接接口的机械特点</li><li>电器特性：在物理连接上，导线的电气连接及有关电路的特征</li><li>功能特性：物理接口各条信号线的用途</li><li>规程特性： 通信协议，指明利用接口传输比特流的全过程，以及各项用于传输的事件发生的合法顺序</li></ul></li><li>物理层接口规范定义DTE和DCE之间的接口特性<ul><li>DTE：数据终端设备</li><li>DCE：数据电路端接设备</li></ul></li></ul></li></ol><h2 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h2><ol><li>信道容量</li><li>基带传输编码</li><li>频带传输与调制技术</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络05——数据链路层</title>
      <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C05%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——数据链路层与局域网"><a href="#计算机网络——数据链路层与局域网" class="headerlink" title="计算机网络——数据链路层与局域网"></a>计算机网络——数据链路层与局域网</h1><h2 id="一、数据链路层服务"><a href="#一、数据链路层服务" class="headerlink" title="一、数据链路层服务"></a>一、数据链路层服务</h2><ol><li>数据链路层服务<ul><li>链路：通信链路连接的相邻结点的通信信道</li><li>链路层数据单元：帧</li></ul></li><li>主要功能包括：<ul><li>组帧</li><li>链路接入：点对点链路、广播链路</li><li>可靠交付（可靠传输方法多用于高出错率链路）</li><li>差错控制</li></ul></li></ol><h2 id="二、差错控制"><a href="#二、差错控制" class="headerlink" title="二、差错控制"></a>二、差错控制</h2><ol><li><p>差错控制的四种基本方式：</p><ul><li>检查重发</li><li>前向纠错：接收方进行差错纠正</li><li>反馈校验：接收端将收到的数据原封不动发回发送端</li><li>检错丢弃</li></ul></li><li><p>差错编码的基本原理 <code>*</code></p><ul><li>香农信道编码定理：理论上可以通过编码使得数据传输过程不发生错误，或者将错误概率控制在很小的数值之下。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fxiangnong.png" alt="香农信道编码执行过程"></li></ul></li><li><p>差错编码的检查与纠错能力</p><ul><li>汉明距离：两个等长码字之间，对应位不同的位数</li><li>编码集的汉明距离：该编码集中任意两个码字之间汉明距离的最小值</li><li>差错编码的检错或纠错能力与编码集的汉明距离有关<ul><li>检错编码：如果编码集的汉明距离d<sub>s</sub>=r+1，则该差错编码可以检测r位的差错</li><li>纠错编码：如果编码集的汉明距离d<sub>s</sub>=2r+1，则该差错编码可以纠正r位的差错</li></ul></li></ul></li><li><p>典型的差错编码</p><ul><li>奇偶检验码：<ul><li>奇校验：编码后的码字中“1”的个数为奇数</li><li>偶检验：编码后的码字中“1”的个数为偶数</li></ul></li><li>汉明码：可以实现单个比特差错纠正</li><li>循环冗余码CRC：检错能力强，编码效率高，实现简单 <code>*</code></li></ul></li></ol><h2 id="三、多路访问控制协议"><a href="#三、多路访问控制协议" class="headerlink" title="三、多路访问控制协议"></a>三、多路访问控制协议</h2><ol><li>信道划分MAC协议<ul><li>多路访问控制MAC：广播信道上用于协调各个结点的数据发送</li><li>信道划分MAC协议：<ul><li>频分多路复用：在频域内将信道带宽划分为多个子信道</li><li>时分多路复用：将通信信道的传输信号在时域内划分为多个等长的时隙</li><li>波分多路复用：在一根光纤中，传输多路不同波长的光信号</li><li>码分多路复用：从编码域进行划分，使得编码后的信号在同一信道中混合传输</li></ul></li></ul></li><li>随机访问MAC协议<ul><li>ALOHA协议<ul><li>纯ALOHA：直接发送——&gt;信道侦听——&gt;冲突重发</li><li>时隙ALOHA：时隙开始时发送——&gt;信道侦听——&gt;冲突则下——&gt;时隙以概率P重发</li></ul></li><li>载波监听多路访问协议CSMA，发送前监听信道是否空闲<ul><li>非坚持CSMA：忙则等待随机时间后再侦听</li><li>1-坚持CSMA：忙则持续侦听</li><li>p-坚持CSMA：闲则概率P在最近时隙发送</li></ul></li><li>带冲突检测的载波监听多路访问协议CSMA/CD<ul><li>监听空闲后发送，发送时检测碰撞，碰撞后等待重发</li></ul></li></ul></li><li>受控接入MAC协议<ul><li>集中式控制：由一个主机负责调度其他通信站接入信道，从而避免冲突。<ul><li>其主要方法：轮询技术，又分为轮叫轮询和传递轮询</li></ul></li><li>分散式控制： 典型方法有令牌技术，如令牌环网</li></ul></li></ol><h2 id="四、局域网"><a href="#四、局域网" class="headerlink" title="四、局域网"></a>四、局域网</h2><ol><li>数据链路层寻址与ARP<ul><li>MAC地址：每个接口对应一个MAC地址，且全球唯一，长度48位。</li><li>地址解析协议（ARP）：根据本网内目的主机或默认网关的IP地址获取其MAC地址。查询/响应的方式。</li></ul></li><li>以太网<ul><li><code>IEEE802.3</code>标准</li><li>采用<code>CSMA/CD</code>访问控制方法 <code>*</code></li><li>以太网技术<ul><li>10Base-5，10Base-T</li><li>快速以太网100Base-TX,100Base-T4，100Base-FX</li><li>千兆以太网</li><li>万兆以太网 </li></ul></li></ul></li><li>交换机<ul><li>转发与过滤：可以依据接收道的链路层帧的目的MAC地址，选择性地转发到相应的端口，以目的MAC地址为主键，查找交换表。</li><li>自学习：交换机通过<code>自学习</code>构建交换表</li><li>优点：<ul><li>消除冲突，提高性能</li><li>支持异质链路</li><li>易于进行网络管理</li></ul></li></ul></li><li>虚拟局域网（VLAN）<ul><li>一种基于交换机（支持VLAM功能）的逻辑分割广播域的局域网应用形式</li><li>不受物理位置的限制，以软件的方式划分和管理局域网中的工作组</li><li>能够抑制<code>广播风暴</code></li><li>划分方法：<ul><li>基于交换机端口</li><li>基于MAC地址</li><li>基于上层协议类型或地址</li></ul></li></ul></li></ol><h2 id="五、点对点链路协议"><a href="#五、点对点链路协议" class="headerlink" title="五、点对点链路协议"></a>五、点对点链路协议</h2><ol><li>点对点协议——PPP<ul><li>能够处理差错检测、支持多种上层协议、允许连接时协商IP地址、允许身份认证</li><li>典型应用：拨号上网</li><li>功能：<ul><li>成帧</li><li>链路控制协议<code>LCP</code></li><li>网络控制协议<code>NCP</code></li></ul></li></ul></li><li>高级数据链路控制——HDLC协议<ul><li>可应用于点对点链路和点对多点链路</li><li>帧定界：帧定界符是01111110<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fzhendingjie.png" alt="帧定界"></li><li>位填充：（透明传输）<ul><li>发送端：只要发现数据字段5个连续的1，就立即插入一个0，保证数据字段不会出现连续的6个1</li><li>接收端：发现数据流中5个连续的1，就删除其后的0，还原成原来的信息</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络04——网络层</title>
      <link href="/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C04%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——网络层"><a href="#计算机网络——网络层" class="headerlink" title="计算机网络——网络层"></a>计算机网络——网络层</h1><h2 id="一、网络层服务"><a href="#一、网络层服务" class="headerlink" title="一、网络层服务"></a>一、网络层服务</h2><ol><li>网络层的主要作用：将网络层数据报从<code>源主机</code>送达<code>目的主机</code>。</li><li>主要功能包括：<ul><li>转发：分组从输入接口转移到输出接口。</li><li>路由选择：决定分组经过的路由或路径。</li></ul></li><li>路由选择，分组转发<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fdatachange.jpg" alt="路由选择，分组转发示意图"></li></ol><h2 id="二、数据报网络与虚电路网络"><a href="#二、数据报网络与虚电路网络" class="headerlink" title="二、数据报网络与虚电路网络"></a>二、数据报网络与虚电路网络</h2><ol><li>数据报网络：按照目的主机地址进行路由选择网络。</li><li>数据报网络特点：（不可靠）<ul><li>无连接</li><li>每个分组作为一个独立的数据报进行发送，路径路径也可能不同</li><li>分组可能出现乱序和丢失</li></ul></li><li>虚拟电路网络：在网络层提供面向连接的分组交换服务</li><li>虚电路网络的特点：<ul><li>建立一条网络逻辑链接</li><li>不需要为每条虚电路分配独享资源（区别于电路交换）</li><li>根据虚拟电路号沿虚电路路径按序发送分组</li></ul></li></ol><h2 id="三、网络互联与网络互联设备"><a href="#三、网络互联与网络互联设备" class="headerlink" title="三、网络互联与网络互联设备"></a>三、网络互联与网络互联设备</h2><ol><li>异构网络互连<ul><li>异构网络：两个网络的通信技术和运行的协议不同。</li><li>异构网络连接的基本策略：<ul><li>协议交换</li><li>构建虚拟互联网络</li></ul></li></ul></li><li>路由器<ul><li>输入端口<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fluyouqichu.png" alt="路由器输入端口"></li><li>输出端口<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fluyouqicru.png" alt="路由器输出端口"></li><li>路由结构：基于内存交换、基于总线交换、基于网络交换</li><li>路由处理器：执行路由器的各种命令，包括<code>路由协议运行</code>、<code>路由计算</code>以及<code>路由表的更新和维护</code>等。</li></ul></li></ol><h2 id="四、网络层拥塞控制"><a href="#四、网络层拥塞控制" class="headerlink" title="四、网络层拥塞控制"></a>四、网络层拥塞控制</h2><ol><li>拥塞的定义：一种持久过载的网络状态，此时用户对网络资源（包括链路带宽、存储空间和处理器处理能力等）的总需求超过了网络固有的容量。</li><li>网络拥塞的原因：<ul><li>缓冲区容量有限；</li><li>传输线路的带宽有限；</li><li>网络结点的处理能力有限；</li><li>网络中某些部分发生故障 ；</li></ul></li><li>流量感知路由<ul><li>流量感知路由： 根据网络的负载情况动态调整，将网络流量引导到不同的链路上，均衡网络负载，从而延缓或避免拥塞发生。</li><li>解决网络负载的震荡现象<ul><li>多路径路由</li><li><code>缓慢转移</code>流量至另一条链路</li></ul></li></ul></li><li>准入控制<ul><li>准入控制：是一种广泛用于虚电路网络的拥塞预防技术。</li><li>基本思想：对新建虚电路进行审核，如果新建立的虚电路会导致网络变得拥塞，那么网路拒绝建立该新虚电路。</li><li>拥塞状况的量化：基于平均流量和瞬时流量</li></ul></li><li>流量调节<ul><li>感知拥塞</li><li>处理拥塞：将拥塞信息通知到其上游结点</li><li>处理放法：<ul><li>抑制分组：给拥塞数据的<code>源主机</code>返回一个抑制分组。</li><li>背压：让抑制分组在从拥塞结点到源结点的路径的<code>每一跳</code>，都能发挥抑制作用。</li></ul></li></ul></li><li>负载脱落<ul><li>负载脱落：路由器主动丢弃某些数据报。</li><li>如何选择丢弃数据报：<ul><li>丢弃新分组：如GBN</li><li>丢弃老分组： 如实时视频流</li></ul></li></ul></li></ol><h2 id="五、Internet网络层"><a href="#五、Internet网络层" class="headerlink" title="五、Internet网络层 *"></a>五、Internet网络层 <code>*</code></h2><ol><li>IPv4协议<ul><li>IP数据报格式,IP首部固定部分20字节<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2FIPv4.png" alt="IP数据报格式示意图"></li><li>IP数据分片<ul><li>标识：判断这些分片是否属于同一个IP数据报</li><li>标志：判断是否为最后一个分片</li><li>片偏移：判断各分片的先后顺序    2. IPv4编址</li></ul></li><li>IPv4地址长度：32位二进制</li><li>点分十进制标记法<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fluyouqicru.png" alt="点分十进制标记法"> </li><li>分类地址：A、B、C、D、E五类  （网络号，主机号）</li><li>特殊地址、私有地址<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2FABC.png" alt="地址分类"></li><li><code>子网划分</code>:将一个较大的子网划分为对个较小的网络的过程，较大子网具有较短的网络前缀，较小子网具有稍长的前缀。</li><li><code>超网</code>：将具有较小前缀的相对较小的子网合并为一个具有稍短前缀的相对较大的子网。</li><li><code>子网掩码</code>：用来定义一个子网的网络前缀长度。<ul><li>子网掩码延长1（r）位，该子网将被划分位两个（2<sup>r</sup>个）子网</li></ul></li><li>分组转发：查找转发表，最长前缀匹配</li><li>路由聚合：将相同路由的连续子网合并<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2Fziwangjuhe-.jpg" alt="路由聚合"><ol start="3"><li>动态主机配置协议——DHCP</li></ol></li><li>动态主机配置协议：为网络内的主机提供动态IP地址分配服务</li><li>运行过程：<ul><li>DHCP服务器发现</li><li>DHCP服务器提供</li><li>DHCP服务器请求</li><li>DHCP确认    4. 网络地址转换NAT——使用私有地址访问互联网</li></ul></li><li>从内网进入互联网的IP数据报：将其源IP地址替换为NAT服务器拥有的合法的公共IP地址，同时替换源端口号，并将替换关系记录到NAT转换表中。</li><li>从互联网返回的IP数据报：依据其目IP地址与目的端口号检索NAT转换表，得到内部私有IP地址与端口号，替换为目的IP地址和目的端口号，然后将IP数据报转发到内部网络。    5. 互联网控制报文协议（ICMP）——在主机或路由器间，实现差错信息报告</li><li>ICMP差错报告报文共有5种：<ul><li>终点不可达</li><li>源点抑制</li><li>时间超时</li><li>参数问题</li><li>路由重定向</li></ul></li><li>ICMP询问报文：回声（echo）请求/应答，时间戳（timestamp）请求/应答。    6. IPv6</li><li>解决IPv4地址耗尽的问题</li><li>IPv6报文首部长度固定40字节</li><li>IPv6地址长度128位</li><li>IPv4到IPv6的迁移：双协议线，隧道 </li></ul></li></ol><h2 id="六、路由算法与路由协议"><a href="#六、路由算法与路由协议" class="headerlink" title="六、路由算法与路由协议"></a>六、路由算法与路由协议</h2><ol><li>链路状态路由选择算法 <code>*</code><ul><li>链路状态路由选择算法是一种全局式路由选择算法。每个路由器通过从其他路由器获得链路状态信息构建出整个网络的拓扑图。</li><li>计算最短路径-Dijkstra算法</li></ul></li><li>距离向量路由选择算法 <code>*</code><ul><li>每个结点基于其与邻居结点间的直接链路距离，以及邻居交换过来的距离向量，计算并更新其到达每个目标结点的最短距离，然后将新的距离向量再通告给其他所有令居，直到距离向量不再改变。</li></ul></li><li>层次化路由选择——实现大规模网络路由选择最有效的，可行的解决方案。 <ul><li>划分自治系统：<ul><li>网关路由器</li><li>自治系统间路由协议</li></ul></li></ul></li><li>Internet路由选择协议<ul><li>内部网关协议<ul><li>RIP：基于<code>距离向量路由选择算法</code>，跳数作为距离度量，最大距离不超过15兆，每30秒交换一次距离向量。</li><li>OSPF：基于<code>链路状态路由选择算法</code></li></ul></li><li>外部网关协议：<code>BGP</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络03——传输层</title>
      <link href="/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——传输层"><a href="#计算机网络——传输层" class="headerlink" title="计算机网络——传输层"></a>计算机网络——传输层</h1><h2 id="一、传输层的基本服务"><a href="#一、传输层的基本服务" class="headerlink" title="一、传输层的基本服务"></a>一、传输层的基本服务</h2><ol><li><p>传输层的核心任务是 为应用进程之间提供端到端的逻辑通信服务。</p></li><li><p>传输层主要功能包括：</p><ul><li>传输层地址</li><li>应用层报文的分段和重组</li><li>报文的差错检测</li><li>进程间的端到端可靠数据传输控制</li><li>面向应用层实现复用与分解</li><li>端到端的流量控制</li><li>拥塞控制</li><li>传输层协议提供<code>逻辑通信</code>服务</li><li>传输层协议只需要在<code>端系统</code>中实现</li><li>通信的真正断点并不是主机，而是主机中运行的<code>应用进程</code></li></ul></li><li><p>传输层地址与端口号</p><ul><li>用统一的寻址方法对应用程序进行标识——<code>端口号</code></li><li>在全国范围内利用<code>“IP地址+端口号”</code>唯一标识一个通信端点</li><li>传输层端口号为<code>16</code>位整数，包含三类端口：</li><li>POP3：110端口、 SMTP：25端口、HTTP：80端口</li></ul><table><thead><tr><th align="center">端口类型</th><th align="center">数值特性</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">熟知端口号</td><td align="center">0——1023</td><td align="center"></td></tr><tr><td align="center">登记端口号</td><td align="center">1024——49151</td><td align="center">使用这个范围端口号必须在IANA登记以防止重复</td></tr><tr><td align="center">客户端口号或短暂端口号</td><td align="center">49152——65535</td><td align="center">留给客户进程选择使用</td></tr></tbody></table></li><li><p>无连接服务与面向连接服务</p><ul><li>无连接服务：数据传输之前无需与对端进行任何信息交换（即“握手”），直接构造传输层报文段并向接收端发送。（<code>UDP</code>）</li><li>面向连接服务：在数据传输之前，需要双方交换一些控制信息，建立逻辑连接，然后再传输数据，数据传输结束后还需要拆除连接。（<code>TCP</code>）</li></ul></li></ol><h2 id="二、传输层的复用与分解"><a href="#二、传输层的复用与分解" class="headerlink" title="二、传输层的复用与分解"></a>二、传输层的复用与分解</h2><ol><li>多路复用与多路分解：是传输层的一项<code>基本功能</code>，支持众多应用进程共用同一个传输层协议，并能够将接受到的数据准确交付给不同的应用进程。 </li><li>无连接的多路复用与多路分解<ul><li>UDP套接字：<code>&lt;目的IP地址，目的端口号&gt;</code></li><li>UDP套接字的端口号是UDP实现复用与分解的重要依据</li></ul></li><li>面向连接的多路复用与多路分解<ul><li>TCP套接字（标识一条TCP连接）：<code>&lt;源IP地址，源端口号，目标的P地址，目的端口号&gt;</code></li><li>当一个TCP报文段从网络层到达一台主机时，该主机根据这4个值来将报文分段到相应的套接字。</li></ul></li></ol><h2 id="三、停—等协议与滑动窗口协议"><a href="#三、停—等协议与滑动窗口协议" class="headerlink" title="三、停—等协议与滑动窗口协议"></a>三、停—等协议与滑动窗口协议</h2><ol><li>实现可靠传输的措施：<ul><li>差错检测：利用差错编码实现数据包传输过程中的比特差错检测。</li><li>确认：接收方向发送方反馈接收状态。</li><li>重传：发送方重新发送接收方没有正确接收的数据。</li><li>序号：确保数据按序提交。</li><li>计时器：解决数据丢失问题。</li></ul></li><li>停——等协议：主要特点就是每发送一个报文段后就停下来等待接收方的确认</li><li>停——等协议的基本工作原理：<ul><li>发送方发送经过差错编码和编码的报文段，等待接收方确认；（发送等待确认）</li><li>接收方如果正确接收报文段，即差错检测无误且序号正确，则接收报文段，并向发送方<code>发送ACK</code>，否则丢弃报文段，并向发送端<code>发送NAK</code>；（接收并确认/否认）</li><li>发送方如果收到ACK，则继续发送后续报文，否则重发刚刚发送的报文段。（继续发送/重发）</li></ul></li><li>滑动窗口协议（典型的流水线协议）<ul><li>流水线协议或管道协议——允许发送方在没有收到确认前连续发送多个分组。</li><li>流水线协议的改进：增加分组序号范围、发送方和（或）接收方必须缓存多个分组。</li><li>两种具有代表性的滑动窗口协议：回退N步（GBN）协议、选择重传（SR）协议。<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F952%2F8fa7986d04aaedb872384e647e414be8.png&amp;refer=http%3A%2F%2Fwww.pianshen.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1648731340&amp;t=78d0c6420112ac1c8c17d376009747a1"></li></ul></li></ol><h2 id="四、用户数据报协议（UDP）"><a href="#四、用户数据报协议（UDP）" class="headerlink" title="四、用户数据报协议（UDP）"></a>四、用户数据报协议（UDP）</h2><ol><li>UDP的数据结构<ul><li>源和目的端口号：用于UDP实现复用与分解。</li><li>长度字段：在UDP报文段中的字节数（首部和数据的总和）。</li><li>校验和：接收方用来检测报文段是否出现了差错。</li></ul></li><li>计算校验和<ul><li>对所有参数与运算的内容（包括UDP报文段）按16位（16位对齐）求和</li><li>求和过程遇到的任何溢出（即进位）都被回卷（即进位与和的最低为相加）</li><li>最后得到的和取反码</li></ul></li></ol><h2 id="五、传输控制协议（TCP）"><a href="#五、传输控制协议（TCP）" class="headerlink" title="五、传输控制协议（TCP）"></a>五、传输控制协议（TCP）</h2><ol><li><p>TCP报文段结构</p><ul><li>TCP首部和TCP数据部分</li></ul><p> <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/TCP.png"> </p></li><li><p>TCP连接管理</p><ul><li>连接建立——三次握手<ul><li>SYN连接请求</li><li>SYNACK确认</li><li>ACK确认</li></ul></li></ul><p> <img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/TCPhand.jpg"></p></li><li><p>TCP断开连接的过程——四次挥手</p><ul><li>可以是客户端先发送请求，也可以是服务端先发送请求。<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/Internet%2FTCPfour.png"></li></ul></li><li><p>TCP可靠数据传输</p><ul><li>TCP的可靠数据传输实现机制包括差错编码、确认、序号、重传、计时器等。</li><li>TCP的可靠数据传输是基于滑动窗口协议，但是发送窗口大小动态变化。<ul><li>封装TCP报文</li><li>发送一个报文后启动一个计时器</li><li>通过校验和发送数据差错</li><li>通过序号重新排序，丢弃重复的报文段</li><li>流量控制</li></ul></li></ul></li><li><p>TCP流量控制</p><ul><li>TCP协议利用窗口机制实现流量控制，但不是简单的滑动窗口协议。</li><li>TCP连接建立时，双方都为之分配固定大小的缓冲空间；TCP的接收端只允许另一端发送其缓冲区所能接纳的数据。<ul><li>接收端在给发送端发送确认段时，通告接收端口大小；</li><li>发送端在接下来发送数据段时，确保未确认段的应用层数据总量不超过接收端通告的接收窗口大小，从而确保接收端不会发生缓存溢出。</li></ul></li></ul></li><li><p>TCP拥塞控制</p><ul><li>窗口机制：通过调节窗口的大小实现对发送数据速率的调整。</li><li>窗口调整基本策略：AIMD（Additive Incease,Multiplicative Decrease）加性增加，乘性减少；网络未发生拥塞时，逐渐“加性”增大窗口大小，当网络拥塞时“乘性”快速减小窗口大小。</li><li>TCP的拥塞控制算法：包括了<code>慢启动</code>，<code>拥塞避免</code>，<code>快速重传</code>和<code>快速恢复</code>4个部分。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络第二章</title>
      <link href="/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2022/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——网络应用"><a href="#计算机网络——网络应用" class="headerlink" title="计算机网络——网络应用"></a>计算机网络——网络应用</h1><h2 id="一、计算机网络应用体系结构"><a href="#一、计算机网络应用体系结构" class="headerlink" title="一、计算机网络应用体系结构"></a>一、计算机网络应用体系结构</h2><ol><li>三种类型<ul><li>客户/服务器（C/S）结构。</li><li>P2P（Peer to Peer）结构  ——点对点结构（对等端可以进行直接通信）。</li><li>混合结构：既有中心服务器的存在，又有对等端（客户）间的直接通信。</li></ul></li></ol><h2 id="二、网络应用通信基本原理"><a href="#二、网络应用通信基本原理" class="headerlink" title="二、网络应用通信基本原理"></a>二、网络应用通信基本原理</h2><ol><li><code>C/S</code>通信的基本原理：<ul><li>服务器端运行的是服务器进程，被动的等待客户请求服务。</li><li>客户端运行的是客户进程，主动发起通信，请求服务器进程提供服务。</li><li>应用进程间遵循应用层协议交换应用层报文。</li></ul></li></ol><h2 id="三、域名系统（DNS）"><a href="#三、域名系统（DNS）" class="headerlink" title="三、域名系统（DNS）**"></a>三、域名系统（DNS）**</h2><ol><li><p>层次树状结构的命名方法</p><ul><li>国家顶级域名nTLD</li><li>通用顶级域名gTLD</li><li>基础结构域名</li></ul></li><li><p>域名服务器</p></li></ol><ul><li>域名解析<ul><li>将域名映射为IP地址的过程。</li></ul></li><li>域名服务器<ul><li>实现域名解析，需要建立分布式数据库，存储网络中域名和IP地址的对应关系。</li></ul></li><li>域名服务器分类<ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权威域名服务器</li><li>本地域名服务器 </li></ul></li></ul><ol start="3"><li>域名解析过程</li></ol><ul><li>递归查询 <ul><li>代替查询主机或其他域名服务器。</li><li>进行进一步的域名查询。</li><li>并将最终解析结果发送给查询主机或服务器。</li></ul></li><li>迭代查询<ul><li>只是将下一步要查询发服务器告知查询你主机或服务器。</li></ul></li></ul><h2 id="四、万维网应用结构"><a href="#四、万维网应用结构" class="headerlink" title="四、万维网应用结构"></a>四、万维网应用结构</h2><ol><li>万维网的结构包括：</li></ol><ul><li><p>Web服务器</p></li><li><p>浏览器</p></li><li><p>超文本传输协议（http)</p><ul><li>超文本传输协议，定义浏览器如何向Web服务器发送请求以及Web服务器如何向浏览器响应。</li><li>版本：HTTP/1.0 和 HTTP/1.1</li><li>HTTP连接非持久连接，持久连接。</li></ul></li><li><p>HTTP</p><ul><li><p>请求行：请求方法+URL+版本、首部行：值。</p></li><li><p>请求方法：GET、HEAD、POST、OPTION、PUT等。</p></li><li><p>状态行：版本+状态码+短语、首部行字段：值。</p></li><li><p>HTTP响应报状态码</p><table><thead><tr><th align="center">状态码</th><th align="center">作用</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息提示</td><td align="center">通告信息，可能还需要进一步交互</td></tr><tr><td align="center">2XX</td><td align="center">成功</td><td align="center">成功完成客户端请求的操作，并进行响应</td></tr><tr><td align="center">3XX</td><td align="center">重定向</td><td align="center">表示资源已移走，需要向新URL发送请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误</td><td align="center">由于客户端请求错误，无法成功响应</td></tr><tr><td align="center">5XX</td><td align="center">服务端错误</td><td align="center">由于服务端错误，无法成功响应</td></tr></tbody></table></li><li><p>某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p></li><li><p>弥补HTTP协议无状态的不足，有助于进行用户跟踪并提供针对性的服务。</p></li></ul></li></ul><h2 id="五、电子邮件系统结构"><a href="#五、电子邮件系统结构" class="headerlink" title="五、电子邮件系统结构"></a>五、电子邮件系统结构</h2><ol><li>电子邮件系统包括：邮件服务器、简单邮件传输协议（SMTP）、用户代理和邮件读取协议等。</li><li>SMTP 协议<ul><li>是<code>Internet</code>电子邮件中核心应用层协议，实现<code>邮件服务器之间</code>或<code>用户代理到邮件服务器之间</code>的邮件传输。</li><li>SMTP使用传输层TCP实现可靠数据传输，端口号25</li><li>SMTP通过三个阶段的应用层交互完成邮件传输，分别是：<code>握手阶段</code>、<code>邮件传输阶段</code>、<code>关闭阶段</code>。</li></ul></li><li>邮件读取协议<ul><li>第三版的邮件协议（Post Office Protocol-Version 3,POP3）</li><li>互联网邮件访问协议 （Internet Mail Access Protocol, IMAP）</li><li>HTTP</li></ul></li></ol><h2 id="六、文件传送协议（FTP）"><a href="#六、文件传送协议（FTP）" class="headerlink" title="六、文件传送协议（FTP）"></a>六、文件传送协议（FTP）</h2><ul><li>FTP：在互联网的两个主机之间实现文件互传的应用层协议。<ul><li>C/S模式，采用<code>控制连接</code>(21端口)传输控制命令，<code>数据连接</code>（20端口）传输文件内容。</li><li>如图所示：<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/FTP.png" alt="C/S模式"></li></ul></li></ul><h2 id="七、P2P应用"><a href="#七、P2P应用" class="headerlink" title="七、P2P应用"></a>七、P2P应用</h2><ul><li>P2P应用的优势<ul><li>充分聚集利用了端系统（对等方主机）的计算能力以及网络传输带宽。</li><li>对服务器的依赖很小。</li></ul></li><li>P2P示意图<br> <img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fbkimg.cdn.bcebos.com%2Fpic%2F960a304e251f95ca796fa994cb177f3e6709527d&amp;refer=http%3A%2F%2Fbkimg.cdn.bcebos.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1648649909&amp;t=d850cb6031d518925e083ccb9f1535c8" alt="P2P示意图"></li></ul><h2 id="八、socket编程基础"><a href="#八、socket编程基础" class="headerlink" title="八、socket编程基础"></a>八、socket编程基础</h2><ol><li>网络应用进程通信时需要通过API接口请求协议的服务，可以创建：<ul><li>数据报类型套接字SOCK_DGRAM</li><li>流式套接字SOCK_STREAM</li><li>原始套接字SOCK_RAW<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/SOCKET.png" alt="通过API接口请求协议的服务"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络01</title>
      <link href="/2022/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/"/>
      <url>/2022/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络学习笔记"><a href="#计算机网络学习笔记" class="headerlink" title="计算机网络学习笔记"></a>计算机网络学习笔记</h1><h2 id="一、计算机网络的基本知识"><a href="#一、计算机网络的基本知识" class="headerlink" title="一、计算机网络的基本知识"></a>一、计算机网络的基本知识</h2><h3 id="（1）计算机网络的基本概念"><a href="#（1）计算机网络的基本概念" class="headerlink" title="（1）计算机网络的基本概念"></a>（1）计算机网络的基本概念</h3><ol><li>计算机网络的概念：计算机网络是互连的，自治的计算机集合。</li><li>协议的定义：协议是网络实体之间数据交换过程中需要遵循的规则或约定，包括三要素：语法、语义、时序。</li><li>计算机网络的功能：硬件资源共享、软件资源共享、信息资源共享。</li><li>计算机网络的分类<ul><li>按照覆盖范围：个域网、局域网、城域网、广域网。</li><li>按照拓扑结构：星形、总线型、环形、网状、树形、混合拓扑结构等。</li><li>按照交换方式：电路交换网络、报文交换网络、分组交换网络。</li><li>按照网络用户属性：公用网、私有网。</li></ul></li></ol><h3 id="（2）计算机网络的结构"><a href="#（2）计算机网络的结构" class="headerlink" title="（2）计算机网络的结构"></a>（2）计算机网络的结构</h3><ol><li>网络边缘：连接到网络上的所有端系统。</li><li>接入网络：接入网络实现 <strong>网络边缘</strong> 的端系统与 <strong>网络核心</strong> 的连接与接入。</li><li>网络核心：网络核心是由通信链路互联的分组交换设备构成的网络，作用是实现网络边缘中主机之间数据的中继和转发。</li></ol><h3 id="（3）数据交换"><a href="#（3）数据交换" class="headerlink" title="（3）数据交换"></a>（3）数据交换</h3><ol><li>数据交换的概念：交换结点和传输介质的集合称为通信子网，即网络核心。</li><li>电路交换：（电话） 需要先建立一条专用的通信线路，即电路（电话拨号），然后利用该电路进行通信（电话通话），通信结束后需要拆除电路（挂断电话）。<ul><li>优点：实时性高，时延和时延抖动都较小。</li><li>缺点：  对于突发性数据传输，信道利用率低，且传输速率单一。</li></ul></li><li>报文交换： 以报文为单位在交换网络的各个结点之间以 <strong>存储-转发</strong> 的方式传送。<ul><li>优点：不需要建立连接，只有当报文被转发时才会占用相应的信道。</li><li>缺点：交换结点需要缓冲存储，报文需要排队，增加了延迟。</li></ul></li><li>分组交换：将一个完整的报文拆分为若干个分组，分组传输的过程通常也采用 <strong>存储-转发</strong> 的交换方式。<ul><li>优点：交换设备存储容量要求低、交换速度快、可靠传输效率高、更加公平。</li><li>缺点：分组长度与延迟时间、分组长度与误码率。</li></ul></li></ol><h3 id="（4）计算机网络性能"><a href="#（4）计算机网络性能" class="headerlink" title="（4）计算机网络性能"></a>（4）计算机网络性能</h3><ol><li>速率：是指网络单位时间内传送的数据量，也称为数据传输速率或数据速率。速率的基本单位是bit/s(位每秒)。</li><li>带宽：原本是指信号具有的频带宽度)即信号成分的最高频率与最低频率之差，单位为Hz（赫兹)。</li><li>时延：时延是指从网络中的一个结点到达另一个结点所需要的时间。<ul><li>分组交换的每跳传输过程主要产生四类时间延迟：结点处理时延、排队时延、传输时延和传播时延。</li></ul></li><li>时延带宽积：一段物理链路的传播时延与链路带宽的乘积。表示一段链路可以容纳的数据位数，也称为以位为单位的链路长度。</li><li>丢包率：常被用于评价和衡量网络性能的指标，在很大程度上可以反应网络的拥塞程度。<ul><li>丢包率=丢失分组总数/发送分组总数</li></ul></li><li>吞吐量：单位时间内源主机通过网络向目的主机实际送达的数据量。</li></ol><h3 id="（5）计算机网络体系结构（分层）"><a href="#（5）计算机网络体系结构（分层）" class="headerlink" title="（5）计算机网络体系结构（分层）"></a>（5）计算机网络体系结构（分层）</h3><ol><li>计算机网络体系结构：计算机网络所划分的层次以及各层次协议的集合称为计算机网络体系结构。</li><li>OSI模型<ul><li>物理层(比特流)、数据链路层(DT)、网络层(N)、传输层(TH)、会话层(SH)、表示层(PH)、应用层(AH)。</li></ul></li><li>TCP/IP模型<ul><li>应用层</li><li>运输层 （TCP  UDP）</li><li>网际层  (IP)</li><li>网络接口层 </li></ul></li><li>五层模型<ul><li>应用层</li><li>传输层</li><li>网络层</li><li>链路层</li><li>物理层</li></ul></li><li>三种体系结构的对比分析 <br><br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/blog_img%2Fblog1.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML表单验证知识复盘</title>
      <link href="/2022/01/27/HTML-form/"/>
      <url>/2022/01/27/HTML-form/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML表单校验"><a href="#HTML表单校验" class="headerlink" title="HTML表单校验"></a>HTML表单校验</h1><h2 id="一、HTML表单标签"><a href="#一、HTML表单标签" class="headerlink" title="一、HTML表单标签"></a>一、HTML表单标签</h2><p> 表单主要用于网页收集用户填写信息，表单中的输入可以有单选框，复选框，下拉列表，文字输入，数字输入，文本域，密码输入等。<br> </p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 1、action表示表单提交的服务地址，也可用js文件；</span></span><br><span class="line"><span class="comment">2、method表示提交方式，有post和get两种；</span></span><br><span class="line"><span class="comment">      3、表单中提交的数据为name=value&amp;name=value.....</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://loaclhost:8080"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交数据"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p></p><ol><li><p>提交基本文本信息，<code>type="text"</code>,设置最大长<code>度maxlength="11"</code><br>&nbsp;</p><form><br> <label>用户名：</label> <input type="text" name="username" valuse="" maxlength="11"><p></p></form></li><li><p>密码信息，<code>type="password"</code><br>&nbsp;</p><form><br><label>密 码：</label> <input type="password" name="paswd" valuse=""><p></p></form></li><li><p>单选框，<code>type="radio"</code><br>&nbsp;</p><form><br> <input type="radio" name="sex" valuse="0" checked="">男<br> <input type="radio" name="sex" valuse="1">女<p></p></form></li><li><p>复选框，<code>type="checkbox"</code><br>&nbsp;</p><form><br> <input type="checkbox" name="interest" valuse="0" checked="">运动<br> <input type="checkbox" name="interest" valuse="1">美食<br> <input type="checkbox" name="interest" valuse="2">摄影<br> <input type="checkbox" name="interest" valuse="3">游戏<p></p></form></li><li><p>下拉菜单<br>&nbsp;</p><form><p></p><select><option value="0">选项一</option><option value="1">选项二</option><option value="2">选项三</option></select><br><br><select>    <optgroup label="大类一">      <option value="0">选项一</option>      <option value="1">选项二</option>    </optgroup>    <optgroup label="大类二">        <option value="0">选项一</option>        <option value="1">选项二</option>        <option value="2">选项三</option>    </optgroup></select></form></li></ol> <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"0"</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"1"</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"2"</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"大类一"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"0"</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"1"</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"大类二"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"0"</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"1"</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"2"</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>文本域<br><label>输入你想输入的信息:</label>&nbsp;<textarea rows="4" cols="20"></textarea><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"4"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>提交按钮<br>&nbsp;<form action="" method="get"><br> 邮箱: <input type="email" name="mail" valuse="" placeholder="请输入你的邮箱地址" required=""> <input type="submit" value="提交邮箱地址"> <input type="reset" valuse="重置信息"></form></li></ol><h2 id="二、HTML表单提交的验证"><a href="#二、HTML表单提交的验证" class="headerlink" title="二、HTML表单提交的验证"></a>二、HTML表单提交的验证</h2><p>  表单的验证是对于用户填写数据是否符合要求的判断，只有当用户填写的数据满足表单设置需要时才会进行提交。</p><ol><li>HTNL5约束有效验证API，<code>checkValidity</code> 当元素的输入条件完全满足要求是<code>checkValidity</code>会变为<code>true</code>,否则其他条件时均为false。   <meta charset="utf-8">   <title>checkValidity验证</title>   <form action="../" method="post">       <input type="email" name="mail" id="test1" value="123@cc.com">       <input type="email" name="mail" id="test2" value="111">       <button onclick="checkstate()">点击验证</button>   </form><script>   var t1=document.getElementById("test1");   var t2=document.getElementById("test2");   function checkstate(){       console.log("点你就")      alert("输入框1的验证状态为："+t1.checkValidity() +"  输入框2的验证状态为："+t2.checkValidity());  }</script></li></ol>  <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"../"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"mail"</span> <span class="attr">id</span>=<span class="string">"test1"</span> <span class="attr">value</span>=<span class="string">"123@cc.com"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"mail"</span> <span class="attr">id</span>=<span class="string">"test2"</span> <span class="attr">value</span>=<span class="string">"111"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> t1=<span class="built_in">document</span>.getElementById(<span class="string">"test1"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> t2=<span class="built_in">document</span>.getElementById(<span class="string">"test2"</span>);</span></span><br><span class="line"><span class="javascript"><span class="comment">// alert("sssd")</span></span></span><br><span class="line"><span class="javascript">alert(<span class="string">"输入框1的验证状态为："</span>+t1.checkValidity() +<span class="string">"  输入框2的验证状态为："</span>+t2.checkValidity());</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>HTML约束条件验证setCustomValidity()用于设置表单验证不通过时用户可见的提示信息  <meta charset="utf-8">  <title>setCustomValidity()的应用</title>  输入：<input type="text" name="number" id="number" value="" placeholder="请输入6个数字" pattern="^\d{6}$" required="" oninput="checklong(this)">  <input type="submit" value="提交进行验证"><script type="text/javascript">  function checklong(obj)  {      var it=obj.validity;      if(it.valueMissing==true)      {          obj.setCustomValidity("输入的信息不能为空。。。。。。")      }      else if(it.patternMismatch==true)      {          obj.setCustomValidity("必须为6位数字哦")      }      else      {          obj.setCustomValidity("")      }  }</script></li></ol>   <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> username=<span class="built_in">document</span>.getElementById(<span class="string">"username"</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(number.validity)</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checklong</span>(<span class="params">obj</span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>{</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> it=obj.validity;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(it.valueMissing)</span></span><br><span class="line"><span class="javascript">   <span class="keyword">if</span>(it.valueMissing==<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">{</span></span><br><span class="line"><span class="javascript">obj.setCustomValidity(<span class="string">"输入信息不能为空"</span>);</span></span><br><span class="line"><span class="javascript">}<span class="keyword">else</span> <span class="keyword">if</span>(it.patternMismatch==<span class="literal">true</span>)</span></span><br><span class="line"><span class="javascript">{</span></span><br><span class="line"><span class="javascript">   obj.setCustomValidity(<span class="string">"必须是6个数字"</span>);</span></span><br><span class="line"><span class="javascript">}<span class="keyword">else</span>{</span></span><br><span class="line"><span class="javascript">obj.setCustomValidity(<span class="string">""</span>)</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript">}</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><p>HTML约束条件验证validity()展示各信息含义<br><img src="https://aiphoto-1305314152.cos.ap-chengdu.myqcloud.com/001-1.jpg" alt="约束条件验证validity()展示"></p></li><li><p>一些css的伪类选择器用于对表单进行美化 </p></li></ol><ul><li><code>:required</code>和<code>:optional</code>分别表示必填和选填内容。</li><li><code>:in-range</code>和<code>:out-of-range</code>分别表示输入内容在要求范围内和在要求范围外。</li><li><code>:validi</code>和<code>:invalid</code>分别表示输入内容符合表单验证要求和输入内容不符合表单验证要求。</li><li><code>:read-only</code>和<code>read-write</code>表示输入框具有的readonly或readwrite属性。</li></ul>                <meta charset="utf-8">        <title>一些常用的伪类选择器</title>        <style type="text/css">            input:required{                border-radius: 5px;                border: 2px solid green;            }            input:optional{                border: 2px solid hotpink;            }            input:in-range{                border-radius: 6px;                border: 1px solid #FF0000;            }            input:out-of-range{                border: 1px solid plum;            }            /* 取消选中样式 */            input{                outline: 0;            }            input#mail:valid ~label::after{content: "输入正确";}            input#mail:invalid ~label::after{content: "输入信息有误";}            input#mail:valid{                border: 1px solid aquamarine;               color: #008000;            }            input#mail:invalid{                border: 1px solid crimson;            }        </style>                必填项：<input type="text" name="username" id="user" value="" required=""><br><label for="user"><label>        选填项: <input type="text" name="usernamee" value=""><br>        100~9999之间： <input type="number" name="number" value="" max="9999" min="100"><br>        邮箱验证：<input type="email" name="email" id="mail" value="" placeholder="请输入邮箱" required=""><label></label>         <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:required</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border-radius</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:optional</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">2px</span> solid hotpink;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:in-range</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border-radius</span>: <span class="number">6px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:out-of-range</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid plum;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="comment">/* 取消选中样式 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">outline</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> ~<span class="selector-tag">label</span><span class="selector-pseudo">::after</span>{<span class="attribute">content</span>: <span class="string">"输入正确"</span>;}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> ~<span class="selector-tag">label</span><span class="selector-pseudo">::after</span>{<span class="attribute">content</span>: <span class="string">"输入信息有误"</span>;}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-id">#mail</span><span class="selector-pseudo">:valid</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid aquamarine;</span></span><br><span class="line"><span class="css">   <span class="attribute">color</span>: <span class="number">#008000</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-id">#mail</span><span class="selector-pseudo">:invalid</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">border</span>: <span class="number">1px</span> solid crimson;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"><span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span>{</span></span><br><span class="line"><span class="css"><span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">必填项：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">required</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">选填项: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"usernamee"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">100~9999之间： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">""</span>  <span class="attr">max</span>=<span class="string">"9999"</span> <span class="attr">min</span>=<span class="string">"100"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    邮箱验证：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"mail"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">"请输入邮箱"</span> <span class="attr">required</span> /&gt;</span><span class="tag">&lt;<span class="name">label</span> &gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">只读：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"read"</span> <span class="attr">id</span>=<span class="string">"read"</span> <span class="attr">value</span>=<span class="string">"天下武功,唯快不破"</span> <span class="attr">readonly</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>   经过上面的课程学习，对HTML的表单提交相关知识进行了巩固，一个表单中存在着众多知识点，同时表单也是页面中一个重要的组成部分。后面会对CSS的相关知识进行一定的学习和总结。</p></label></label>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/01/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/01/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇文章"><a href="#我的第一篇文章" class="headerlink" title="我的第一篇文章"></a>我的第一篇文章</h1><hr><h2 id="运用hexo搭建了一个博客，试着在里面写一些东西，对于新鲜事物的好奇。"><a href="#运用hexo搭建了一个博客，试着在里面写一些东西，对于新鲜事物的好奇。" class="headerlink" title="运用hexo搭建了一个博客，试着在里面写一些东西，对于新鲜事物的好奇。"></a>运用hexo搭建了一个博客，试着在里面写一些东西，对于新鲜事物的好奇。</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
